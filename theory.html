<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta charset="utf-8" />

    <!-- Begin Jekyll SEO tag v2.8.0 -->
    <title>PRISM | Programming really is simple mathematics.</title>
    <meta name="generator" content="Jekyll v4.4.1" />
    <meta property="og:title" content="PRISM" />
    <meta property="og:locale" content="en_US" />
    <meta
      name="description"
      content="Programming really is simple mathematics."
    />
    <meta
      property="og:description"
      content="Programming really is simple mathematics."
    />
    <link rel="canonical" href="https://se.constructor.ch/PRISM/theory.html" />
    <meta
      property="og:url"
      content="https://se.constructor.ch/PRISM/theory.html"
    />
    <meta property="og:site_name" content="PRISM" />
    <meta property="og:type" content="website" />
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="PRISM" />
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "WebPage",
        "description": "Programming really is simple mathematics.",
        "headline": "PRISM",
        "url": "https://se.constructor.ch/PRISM/theory.html"
      }
    </script>
    <!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/PRISM/assets/css/main.css" />
  </head>
  <body class="flex">
    <div class="flex-1 flex flex-row-reverse"></div>
    <div class="w-full md:w-[50rem]">
      <header class="mx-auto w-full text-white bg-navy-blue p-2">
        <a href="https://institute.constructor.org/">
          <img
            src="/PRISM/assets/images/C_IT_Logo_White_On_Transparent-cropped-min.svg"
            alt="Constructor Institute of Technology logo"
            class="h-3.5 block"
          />
        </a>

        <div class="mt-2">
          <a href="https://se.constructor.ch" class="text-lg">
            ← Chair of Software Engineering
          </a>
        </div>

        <a href="/PRISM/" class="text-2xl my-2 inline-block"> PRISM </a>
        <ul class="flex items-center gap-6">
          <li>
            <a href="/PRISM/">Home</a>
          </li>

          <li>
            <a href="/PRISM/theory">Theory</a>
          </li>
        </ul>
      </header>

      <div class="p-2">
        <main class="prose mx-auto">
          <h1 id="introduction">Introduction</h1>
          <p>
            This content is automatically generated from the Isabelle theory
            files.
          </p>

          <p>
            All the definitions and theorems in the paper have a corresponding
            theorem or definition here.
          </p>

          <h1 id="definitions">Definitions</h1>

          <h2 id="definitionsthy">Definitions.thy</h2>

          <p>
            <strong>record</strong> :: <em>‘a Program</em> = State :: “‘a set”
            Pre :: “‘a set” post :: “‘a rel”
          </p>

          <p><strong>basic</strong> :: <em>‘a CNF ⇒ ‘a Program set</em></p>

          <p>    basic p ≡ foldl (∪) ({}::’a Program set) (map (set) p)</p>

          <hr />
          <p><strong>S</strong> :: <em>‘a Program ⇒ ‘a set</em></p>

          <p>    S p = State p ∪ Pre p ∪ Field (post p)</p>

          <hr />
          <p><strong>used_states</strong> :: <em>‘a Program ⇒ ‘a set</em></p>

          <p>    used_states p ≡ Pre p ∪ Field (post p)</p>

          <hr />
          <p><strong>is_feasible</strong> :: <em>‘a Program ⇒ bool</em></p>

          <p>    is_feasible p = (Pre p ⊆ Domain (post p))</p>

          <hr />
          <p>
            <strong>all_feasible</strong> :: <em>(‘a Program) list ⇒ bool</em>
          </p>

          <p>    all_feasible [ ] = True</p>

          <p>    all_feasible (x # xs) = (all_feasible xs ∧ is_feasible x)</p>

          <hr />
          <p><strong>cnf_feasible</strong> :: <em>‘a CNF ⇒ bool</em></p>

          <p>    cnf_feasible [ ] = True</p>

          <p>    cnf_feasible (x # xs) = (all_feasible x ∧ cnf_feasible xs)</p>

          <hr />
          <p><strong>is_valid</strong> :: <em>‘a Program ⇒ bool</em></p>

          <p>    is_valid p ≡ S p = State p</p>

          <hr />
          <p><strong>all_valid</strong> :: <em>(‘a Program) list ⇒ bool</em></p>

          <p>    all_valid [ ] = True</p>

          <p>    all_valid (x#xs) = (all_valid xs ∧ is_valid x)</p>

          <hr />
          <p><strong>is_deterministic</strong> :: <em>‘a Program ⇒ bool</em></p>

          <p>    is_deterministic p = is_function (post p)</p>

          <hr />
          <p><strong>is_functional</strong> :: <em>‘a Program ⇒ bool</em></p>

          <p>    is_functional p ≡ ∀C⊆(S p). Image (post p) C ∩ C = {}</p>

          <hr />
          <p><strong>is_total</strong> :: <em>‘a Program ⇒ bool</em></p>

          <p>    is_total p = (Pre p = S p)</p>

          <hr />
          <p><strong>restr_post</strong> :: <em>‘a Program ⇒ ‘a rel</em></p>

          <p>    restr_post p = post p /<sub>r</sub> Pre p</p>

          <hr />
          <p>
            <strong>equal [=]</strong> ::
            <em>‘a Program ⇒ ‘a Program ⇒ bool</em>
          </p>

          <p>
                p<sub>1</sub> = p<sub>2</sub> ≡ (Pre p<sub>1</sub> = Pre p<sub
              >2</sub
            >
            ∧ post p<sub>1</sub> = post p<sub>2</sub> ∧ S p<sub>1</sub> = S
            p<sub>2</sub>)
          </p>

          <hr />
          <p>
            <strong>equiv [≡<sub>p</sub>]</strong> ::
            <em>‘a Program ⇒ ‘a Program ⇒ bool</em>
          </p>

          <p>
                p<sub>1</sub> ≡<sub>p</sub> p<sub>2</sub> ≡ (Pre p<sub>1</sub> =
            Pre p<sub>2</sub> ∧ restr_post p<sub>1</sub> = restr_post
            p<sub>2</sub>)
          </p>

          <hr />
          <p><strong>Range_p</strong> :: <em>‘a Program ⇒ ‘a set</em></p>

          <p>    Range_p p = Range (post p /<sub>r</sub> Pre p)</p>

          <hr />
          <p><strong>inverse</strong> :: <em>‘a Program ⇒ ‘a Program</em></p>

          <p>
                inverse p ≡ 〈State=S p, Pre=Range_p p, post=(restr_post p)⁻¹〉
          </p>

          <hr />
          <p>
            <strong>extends</strong> :: <em>‘a Program ⇒ ‘a Program ⇒ bool</em>
          </p>

          <p>
                extends p<sub>2</sub> p<sub>1</sub> = (S p<sub>1</sub> ⊆ S
            p<sub>2</sub>)
          </p>

          <hr />
          <p>
            <strong>weakens</strong> :: <em>‘a Program ⇒ ‘a Program ⇒ bool</em>
          </p>

          <p>
                weakens p<sub>2</sub> p<sub>1</sub> = (Pre p<sub>1</sub> ⊆ Pre
            p<sub>2</sub>)
          </p>

          <hr />
          <p>
            <strong>strengthens</strong> ::
            <em>‘a Program ⇒ ‘a Program ⇒ bool</em>
          </p>

          <p>
                strengthens p<sub>2</sub> p<sub>1</sub> ≡ ((post p<sub>2</sub>)
            /<sub>r</sub> Pre p<sub>2</sub>) /<sub>r</sub> (Pre p<sub>1</sub>) ⊆
            post p<sub>1</sub>
          </p>

          <hr />
          <p>
            <strong>refines [⊑<sub>p</sub>]</strong> ::
            <em>‘a Program ⇒ ‘a Program ⇒ bool</em>
          </p>

          <p>
                p<sub>1</sub> ⊑<sub>p</sub> p<sub>2</sub> = (extends p<sub
              >1</sub
            >
            p<sub>2</sub> ∧ weakens p<sub>1</sub> p<sub>2</sub> ∧ strengthens
            p<sub>1</sub> p<sub>2</sub>)
          </p>

          <hr />
          <p>
            <strong>refines_c [⊑<sub>c</sub>]</strong> ::
            <em>‘a Contracted_Program ⇒ ‘a Contracted_Program ⇒ bool</em>
          </p>

          <p>
                cp<sub>2</sub> ⊑<sub>c</sub> cp<sub>1</sub> ≡ a_specification
            cp<sub>2</sub> = a_specification cp<sub>1</sub> ∧ a_implementation
            cp<sub>2</sub> ⊑<sub>p</sub> a_implementation cp<sub>1</sub>
          </p>

          <hr />
          <p>
            <strong>specialize [⊆<sub>p</sub>]</strong> ::
            <em>‘a Program ⇒ ‘a Program ⇒ bool</em>
          </p>

          <p>
                p<sub>1</sub> ⊆<sub>p</sub> p<sub>2</sub> ≡ extends p<sub
              >2</sub
            >
            p<sub>1</sub> ∧ weakens p<sub>2</sub> p<sub>1</sub> ∧ strengthens
            p<sub>1</sub> p<sub>2</sub>
          </p>

          <hr />
          <p>
            <strong>independent</strong> ::
            <em>‘a Program ⇒ ‘a Program ⇒ bool</em>
          </p>

          <p>
                independent p<sub>1</sub> p<sub>2</sub> = (Pre p<sub>1</sub> ∩
            Pre p<sub>2</sub> = {})
          </p>

          <hr />
          <p>
            <strong>implements</strong> ::
            <em>‘a Program ⇒ ‘a Program ⇒ bool</em>
          </p>

          <p>
                implements p<sub>2</sub> p<sub>1</sub> = (p<sub>2</sub> ⊑<sub
              >p</sub
            >
            p<sub>1</sub> ∧ is_feasible p<sub>2</sub>)
          </p>

          <hr />
          <p>
            <strong>most_abstract_implementation</strong> ::
            <em>‘a Program ⇒ ‘a Contracted_Program</em>
          </p>

          <p>
                most_abstract_implementation p ≡ 〈a_specification=p,
            a_implementation=p〉
          </p>

          <hr />
          <p>
            <strong>MAI</strong> :: <em>‘a Program ⇒ ‘a Contracted_Program</em>
          </p>

          <p>    MAI ≡ most_abstract_implementation</p>

          <hr />
          <p>
            <strong>is_correct</strong> :: <em>‘a Contracted_Program ⇒ bool</em>
          </p>

          <p>
                is_correct cp = implements (a_implementation cp)
            (a_specification cp)
          </p>

          <hr />
          <p>
            <strong>strongest_postcondition [sp]</strong> ::
            <em>‘a Program ⇒ ‘a set ⇒ ‘a rel</em>
          </p>

          <p>    p sp Pre’ ≡ post (p) /<sub>r</sub> Pre’</p>

          <hr />
          <p>
            <strong>new_behavior</strong> ::
            <em>‘a Program ⇒ ‘a rel ⇒ ‘a rel</em>
          </p>

          <p>    new_behavior p post’ ≡ post p - post’</p>

          <hr />
          <p>
            <strong>weakest_precondition [wp]</strong> ::
            <em>‘a Program ⇒ ‘a rel ⇒ ‘a set</em>
          </p>

          <p>    p wp post’ ≡ Pre p - Domain (new_behavior p post’)</p>

          <hr />
          <p>
            <strong>choice [∪<sub>p</sub>]</strong> ::
            <em>‘a Program ⇒ ‘a Program ⇒ ‘a Program</em>
          </p>

          <p>
                p<sub>1</sub> ∪<sub>p</sub> p<sub>2</sub> = 〈State= S p<sub
              >1</sub
            >
            ∪ S p<sub>2</sub>, Pre = Pre p<sub>1</sub> ∪ Pre p<sub>2</sub>, post
            = restr_post p<sub>1</sub> ∪ restr_post p<sub>2</sub>〉
          </p>

          <hr />
          <p><strong>non_empty</strong> :: <em>‘a CNF ⇒ ‘a CNF</em></p>

          <p>    non_empty xs ≡ [t . t ← xs, t ≠ [ ]]</p>

          <hr />
          <p>
            <strong>non_empty2</strong> :: <em>‘a CNF list ⇒ ‘a CNF list</em>
          </p>

          <p>
                non_empty2 xs ≡ [prog2. prog2 ← [non_empty prog. prog ← xs],
            prog2 ≠ [ ]]
          </p>

          <hr />
          <p>
            <strong>choice_cnf [∪<sub>c</sub>]</strong> ::
            <em>‘a CNF ⇒ ‘a CNF ⇒ ‘a CNF</em>
          </p>

          <p>    choice_cnf a b ≡ a @ b</p>

          <hr />
          <p>
            <strong>composition_cnf [;<sub>c</sub>]</strong> ::
            <em>‘a CNF ⇒ ‘a CNF ⇒ ‘a CNF</em>
          </p>

          <p>    composition_cnf a b ≡ [xs @ ys. xs ← a, ys ← b]</p>

          <hr />
          <p><strong>is_prime</strong> :: <em>‘a Program ⇒ bool</em></p>

          <p>
                is_prime p ≡ card (Pre p) = 1 ∧ card (post p) = 1 ∧ Pre p ∪
            Field (post p) = State p
          </p>

          <hr />
          <p>
            <strong>composition [;]</strong> ::
            <em>‘a Program ⇒ ‘a Program ⇒ ‘a Program</em>
          </p>

          <p>
                p<sub>1</sub> ; p<sub>2</sub> = 〈 State = S p<sub>1</sub> ∪ S
            p<sub>2</sub>, Pre = Pre p<sub>1</sub> ∩ Domain (post p<sub>1</sub>
            ∖<sub>r</sub> Pre p<sub>2</sub>), post = (post p<sub>1</sub>) O
            (restr_post p<sub>2</sub>)〉
          </p>

          <hr />
          <p>
            <strong>commute_programs1</strong> ::
            <em>‘a Program ⇒ ‘a Program ⇒ bool</em>
          </p>

          <p>
                commute_programs1 p<sub>1</sub> p<sub>2</sub> ≡ (p<sub>1</sub> ;
            p<sub>2</sub>) = (p<sub>2</sub> ; p<sub>1</sub>)
          </p>

          <hr />
          <p>
            <strong>commute_programs2</strong> ::
            <em>‘a Program ⇒ ‘a Program ⇒ bool</em>
          </p>

          <p>
                commute_programs2 p<sub>1</sub> p<sub>2</sub> ≡ (p<sub>1</sub> ;
            p<sub>2</sub>) = (p<sub>2</sub> ; p<sub>1</sub>)
          </p>

          <hr />
          <p>
            <strong>commute_programs3</strong> ::
            <em>‘a Program ⇒ ‘a Program ⇒ bool</em>
          </p>

          <p>
                commute_programs3 p<sub>1</sub> p<sub>2</sub> ≡ (p<sub>1</sub> ;
            p<sub>2</sub>) ≡<sub>p</sub> (p<sub>2</sub> ; p<sub>1</sub>)
          </p>

          <hr />
          <p>
            <strong>unsafe_composition [;<sub>p</sub>]</strong> ::
            <em>‘a Program ⇒ ‘a Program ⇒ ‘a Program</em>
          </p>

          <p>
                p<sub>1</sub> ;<sub>p</sub> p<sub>2</sub> = 〈 State = S p<sub
              >1</sub
            >
            ∪ S p<sub>2</sub>, Pre = Pre p<sub>1</sub>, post = (post
            p<sub>1</sub>) O (restr_post p<sub>2</sub>)〉
          </p>

          <hr />
          <p>
            <strong>unsafe_composition2 [;<sup>p</sup>]</strong> ::
            <em>‘a Program ⇒ ‘a Program ⇒ ‘a Program</em>
          </p>

          <p>
                p<sub>1</sub> ;<sup>p</sup> p<sub>2</sub> = 〈 State = S p<sub
              >1</sub
            >
            ∪ S p<sub>2</sub>, Pre = Pre p<sub>1</sub> ∩ Domain (post p<sub
              >1</sub
            >
            ∖<sub>r</sub> Pre p<sub>2</sub>), post = (post p<sub>1</sub>) O
            (post p<sub>2</sub>)〉
          </p>

          <hr />
          <p>
            <strong>unsafe_composition3 [;<sub>P</sub>]</strong> ::
            <em>‘a Program ⇒ ‘a Program ⇒ ‘a Program</em>
          </p>

          <p>
                p<sub>1</sub> ;<sub>P</sub> p<sub>2</sub> = 〈 State = S p<sub
              >1</sub
            >
            ∪ S p<sub>2</sub>, Pre = Pre p<sub>1</sub>, post = (post
            p<sub>1</sub>) O (post p<sub>2</sub>)〉
          </p>

          <hr />
          <p>
            <strong>restrict_p [/<sub>p</sub>]</strong> ::
            <em>‘a Program ⇒ ‘a set ⇒ ‘a Program</em>
          </p>

          <p>
                restrict_p p C = 〈State= S p, Pre=Pre p ∩ C, post=post p /<sub
              >r</sub
            >
            C〉
          </p>

          <hr />
          <p>
            <strong>corestrict_p [∖<sub>p</sub>]</strong> ::
            <em>‘a Program ⇒ ‘a set ⇒ ‘a Program</em>
          </p>

          <p>
                corestrict_p p C = 〈State= S p, Pre=Pre p, <br />
            post=post p ∖<sub>r</sub> C〉
          </p>

          <hr />
          <p><strong>char_rel</strong> :: <em>‘a Program ⇒ ‘a rel</em></p>

          <p>    char_rel p = post p /<sub>r</sub> Pre p</p>

          <hr />
          <p><strong>Fail</strong> :: <em>‘a set ⇒ ‘a Program</em></p>

          <p>    Fail s = 〈 State = s, Pre = {}, post = {}〉</p>

          <hr />
          <p><strong>Havoc</strong> :: <em>‘a set ⇒ ‘a Program</em></p>

          <p>
                Havoc s = 〈 State = s, Pre = s, post = {(x,y). x ∈ s ∧ y ∈ s}〉
          </p>

          <hr />
          <p><strong>Skip</strong> :: <em>‘a set ⇒ ‘a Program</em></p>

          <p>
                Skip s = 〈 State = s, Pre = s, post = {(x,y). x ∈ s ∧ x = y} 〉
          </p>

          <hr />
          <p><strong>Infeas</strong> :: <em>‘a set ⇒ ‘a Program</em></p>

          <p>    Infeas s = 〈 State = s, Pre = s, post = {} 〉</p>

          <hr />
          <p>
            <strong>generalized_non_atomic_conc [∥<sub>G</sub>]</strong> ::
            <em>(‘a Program) list ⇒ ‘a Program ⇒ ‘a Program</em>
          </p>

          <p>    [ ] ∥<sub>G</sub> q = q</p>

          <p>
                (x#xs) ∥<sub>G</sub> q = ((xs ∥<sub>G</sub> q) ; x) ∪<sub
              >p</sub
            >
            (x ; (xs ∥<sub>G</sub> q))
          </p>

          <hr />
          <p>
            <strong>if_then_else</strong> ::
            <em>‘a set ⇒ ‘a Program ⇒ ‘a Program ⇒ ‘a Program</em>
          </p>

          <p>
                if_then_else C p<sub>1</sub> p<sub>2</sub> ≡ (p<sub>1</sub>
            /<sub>p</sub> C) ∪<sub>p</sub> (p<sub>2</sub> /<sub>p</sub> (-C))
          </p>

          <hr />
          <p>
            <strong>ITE</strong> ::
            <em>‘a set ⇒ ‘a Program ⇒ ‘a Program ⇒ ‘a Program</em>
          </p>

          <p>    ITE ≡ if_then_else</p>

          <hr />
          <p>
            <strong>if_then</strong> ::
            <em>‘a set ⇒ ‘a Program ⇒ ‘a Program</em>
          </p>

          <p>    if_then C p ≡ ITE C p (Skip (S p))</p>

          <hr />
          <p><strong>TRUE</strong> :: <em>‘a set ⇒ ‘a set</em></p>

          <p>    TRUE s = s</p>

          <hr />
          <p><strong>FALSE</strong> :: <em>‘a set</em></p>

          <p>    FALSE = {}</p>

          <hr />
          <p><strong>ID</strong> :: <em>‘a set ⇒ ‘a rel</em></p>

          <p>    ID s ≡ {(a,b) . a ∈ s ∧ b ∈ s ∧ a = b}</p>

          <hr />
          <p>
            <strong>fixed_repetition_helper [^<sup>p</sup>]</strong> ::
            <em>‘a Program ⇒ nat ⇒ ‘a Program</em>
          </p>

          <p>    fixed_repetition_helper p 0 = Skip (S p)</p>

          <p>
                fixed_repetition_helper p (i + 1) = fixed_repetition_helper p i
            ; p
          </p>

          <hr />
          <p>
            <strong>fixed_repetition [<sup>^</sup>]</strong> ::
            <em>‘a Program ⇒ nat ⇒ ‘a Program</em>
          </p>

          <p>    p<sup>0</sup> = Skip (S p) /<sub>p</sub> (Pre p)</p>

          <p>    p<sup>i + 1</sup> = p<sup>i</sup>;p</p>

          <hr />
          <p>
            <strong>Choice</strong> :: <em>(‘a Program) list ⇒ ‘a Program</em>
          </p>

          <p>    Choice [ ] = Fail {}</p>

          <p>    Choice [x] = x</p>

          <p>    Choice (x#xs) = foldl (∪<sub>p</sub>) x xs</p>

          <hr />
          <p>
            <strong>Concat</strong> ::
            <em>(‘a Program) list ⇒ ‘a set ⇒ ‘a Program</em>
          </p>

          <p>    Concat [ ] s = (Skip s)</p>

          <p>    Concat [x] s = x</p>

          <p>    Concat (x#xs) s = foldl (;) x xs</p>

          <hr />
          <p>
            <strong>Choice_set</strong> ::
            <em>(‘a Program) set ⇒ ‘a Program</em>
          </p>

          <p>    Choice_set P ≡ Finite_Set.fold (∪<sub>p</sub>) (Fail {}) P</p>

          <hr />
          <p><strong>is_minimal</strong> :: <em>‘a Program ⇒ bool</em></p>

          <p>
                is_minimal p ≡ (∀a b. (a,b) ∈ post p → a ∈ Pre p) ∧ is_valid p ∧
            (∀ s ∈ State p. s ∈ Field (post p))
          </p>

          <hr />
          <p>
            <strong>guarded_conditional</strong> ::
            <em>(‘a set × ‘a Program) list ⇒ ‘a Program</em>
          </p>

          <p>
                guarded_conditional xs = ⋃<sub>p</sub> [snd t /<sub>p</sub> fst
            t. t ← xs]
          </p>

          <hr />
          <p>
            <strong>GC</strong> ::
            <em>(‘a set × ‘a Program) list ⇒ ‘a Program</em>
          </p>

          <p>    GC ≡ guarded_conditional</p>

          <hr />
          <p>
            <strong>insert_all</strong> :: <em>‘a ⇒ ‘a list ⇒ ‘a list list</em>
          </p>

          <p>    insert_all x [ ] = [[x]]</p>

          <p>
                insert_all x (y#ys) = (x#y#ys) # (map (λzs. y#zs) (insert_all x
            ys))
          </p>

          <hr />
          <p>
            <strong>permutations</strong> :: <em>‘a list ⇒ ‘a list list</em>
          </p>

          <p>    permutations [ ] = [[ ]]</p>

          <p>
                permutations (x#xs) = concat (map (insert_all x) (permutations
            xs))
          </p>

          <hr />
          <p>
            <strong>complete_state</strong> :: <em>‘a Program list ⇒ ‘a set</em>
          </p>

          <p>    complete_state xs ≡ fold (λ p s. S p ∪ s) xs {}</p>

          <hr />
          <p>
            <strong>n_comp</strong> :: <em>‘a Program list ⇒ ‘a Program</em>
          </p>

          <p>    n_comp [ ] = Fail {}</p>

          <p>    n_comp (x#xs) = x ; (n_comp xs)</p>

          <hr />
          <p>
            <strong>conc_elems</strong> ::
            <em>‘a Program list ⇒ ‘a Program list</em>
          </p>

          <p>
                conc_elems xs ≡ [Concat t (complete_state t). t ← permutations
            xs]
          </p>

          <hr />
          <p>
            <strong>atomic_conc</strong> ::
            <em>‘a Program list ⇒ ‘a Program</em>
          </p>

          <p>    atomic_conc xs ≡ ⋃<sub>p</sub> (conc_elems xs)</p>

          <hr />
          <p>
            <strong>non_atomic_conc [∥<sub>n</sub>]</strong> ::
            <em>‘a Program list ⇒ ‘a Program ⇒ ‘a Program</em>
          </p>

          <p>
                xs ∥<sub>n</sub> x ≡ ⋃<sub>p</sub> [Concat t (complete_state t).
            t ← insert_all x xs]
          </p>

          <hr />
          <p>
            <strong>arbitrary_repetition_set</strong> ::
            <em>‘a Program ⇒ ‘a Program set</em>
          </p>

          <table>
            <tbody>
              <tr>
                <td>    arbitrary_repetition_set p ≡ {p<sup>i</sup></td>
                <td>i . 0&lt;i}</td>
              </tr>
            </tbody>
          </table>

          <hr />
          <p>
            <strong>arbitrary_repetition</strong> ::
            <em>‘a Program ⇒ nat ⇒ nat ⇒ ‘a Program</em>
          </p>

          <p>
                arbitrary_repetition p s 0 = (if s&gt;0 then Fail (S p) else
            p<sup>0</sup>)
          </p>

          <p>
                arbitrary_repetition p s (f + 1) = (if s&gt;(f + 1) then Fail (S
            p) else p<sup>f + 1</sup> ∪<sub>p</sub> arbitrary_repetition p s f)
          </p>

          <hr />
          <p>
            <strong>loop</strong> ::
            <em>‘a Program ⇒ nat ⇒ nat ⇒ ‘a Program</em>
          </p>

          <p>    loop ≡ arbitrary_repetition</p>

          <hr />
          <p>
            <strong>until_support</strong> ::
            <em>‘a Program ⇒ ‘a set ⇒ ‘a Program ⇒ nat ⇒ nat ⇒ ‘a Program</em>
          </p>

          <p>
                until_support a C b s f = a ; (loop (b/<sub>p</sub>(-C)) s
            f)∖<sub>p</sub> C
          </p>

          <hr />
          <p>
            <strong>until_loop</strong> ::
            <em>‘a Program ⇒ ‘a set ⇒ ‘a Program ⇒ nat ⇒ ‘a Program</em>
          </p>

          <p>
                until_loop a C b n = a ; (loop (b/<sub>p</sub>(-C)) 0 n)∖<sub
              >p</sub
            >
            C
          </p>

          <hr />
          <p>
            <strong>is_invariant</strong> :: <em>‘a set ⇒ ‘a Program ⇒ bool</em>
          </p>

          <p>    is_invariant I p ≡ Range_p (p /<sub>p</sub> I) ⊆ I</p>

          <hr />
          <p>
            <strong>is_loop_invariant</strong> ::
            <em>‘a set ⇒ ‘a Program ⇒ ‘a set ⇒ ‘a Program ⇒ bool</em>
          </p>

          <p>
                is_loop_invariant I a C b ≡ Range_p a ⊆ I ∧ is_invariant I
            (b/<sub>p</sub>(-C))
          </p>

          <hr />
          <p><strong>markovian</strong> :: <em>‘a rel ⇒ bool</em></p>

          <p>
                markovian r ≡ ∀s s<sub>1</sub> s<sub>2</sub>. ((s<sub>1</sub>,
            s) ∈ r) = ((s<sub>2</sub>, s) ∈ r)
          </p>

          <hr />
          <p><strong>is_trivial</strong> :: <em>‘a rel ⇒ ‘a ⇒ bool</em></p>

          <p>    is_trivial r s ≡ ∀s<sub>1</sub>. (s, s<sub>1</sub>) ∈ r</p>

          <hr />
          <p><strong>is_irrelevant</strong> :: <em>‘a rel ⇒ ‘a ⇒ bool</em></p>

          <p>
                is_irrelevant r s ≡ ∀s<sub>1</sub> s<sub>2</sub>. ((s,
            s<sub>1</sub>) ∈ r) = ((s, s<sub>2</sub>) ∈ r)
          </p>

          <hr />
          <p><strong>is_relevant</strong> :: <em>‘a rel ⇒ ‘a ⇒ bool</em></p>

          <p>    is_relevant r s ≡ ¬ is_irrelevant r s</p>

          <hr />
          <p>
            <strong>is_programming_language</strong> ::
            <em>‘a set ⇒ (‘a Program) set ⇒ bool</em>
          </p>

          <p>
                is_programming_language s P ≡ ∀p ∈ P. is_feasible p ∧ S p ⊆ s
          </p>

          <hr />
          <p><strong>occurs</strong> :: <em>‘a ⇒ ‘a list ⇒ nat</em></p>

          <p>    occurs _ [ ] = 0</p>

          <p>    occurs x (y # ys) = (if x = y then 1 else 0) + occurs x ys</p>

          <hr />
          <p>
            <strong>inter [∩<sub>p</sub>]</strong> ::
            <em>‘a Program ⇒ ‘a Program ⇒ ‘a Program</em>
          </p>

          <p>
                p ∩<sub>p</sub> q ≡ 〈State=S p ∩ S q,Pre=Pre p ∩ Pre
            q,post=post p ∩ post q〉
          </p>

          <hr />
          <p><strong>set_to_list</strong> :: <em>‘a set ⇒ ‘a list</em></p>

          <p>
                set_to_list s = (if finite s then SOME l. set l = s ∧ distinct l
            else [ ])
          </p>

          <hr />
          <p><strong>is_atomic</strong> :: <em>‘a Program ⇒ bool</em></p>

          <p>
                is_atomic p ≡ S p = State p ∧ card (post p) = 1 ∧ card (Pre p) =
            1 ∧ State p = (Pre p) ∪ (Field (post p)) ∧ (card (post p) = 1 ∧ card
            (Pre p) = 1 → fst (THE x. x ∈ post p) = (THE x. x ∈ Pre p))
          </p>

          <hr />
          <p>
            <strong>get_atomic</strong> ::
            <em>‘a Program ⇒ (‘a Program) set</em>
          </p>

          <table>
            <tbody>
              <tr>
                <td>
                      get_atomic p = {〈State={a,b}, Pre={a}, post={(a, b)} 〉
                </td>
                <td>a b . (a,b) ∈ post p ∧ a ∈ Pre p}</td>
              </tr>
            </tbody>
          </table>

          <hr />
          <p>
            <strong>evaluate</strong> :: <em>‘a CNF ⇒ ‘a set ⇒ ‘a Program</em>
          </p>

          <p>    evaluate p s ≡ ⋃<sub>p</sub> (map (λxs. Concat xs s) p)</p>

          <hr />
          <p>
            <strong>interleave [⫴]</strong> ::
            <em>‘a list ⇒ ‘a list ⇒ ‘a list list</em>
          </p>

          <p>    [ ] ⫴ ys = [ys]</p>

          <p>    (xs) ⫴ [ ] = [xs]</p>

          <p>
                (x#xs) ⫴ (y#ys) = map ((#) x) (xs ⫴ (y#ys)) @ map ((#) y)
            ((x#xs) ⫴ ys)
          </p>

          <hr />
          <p>
            <strong>cnf_concurrency [∥]</strong> ::
            <em>‘a CNF ⇒ ‘a CNF ⇒ ‘a CNF</em>
          </p>

          <p>
                cnf_concurrency xs ys = concat [path_m ⫴ path_n. path_m ← xs,
            path_n ← ys]
          </p>

          <hr />
          <p><strong>is_rounded</strong> :: <em>‘a Program ⇒ bool</em></p>

          <p>    is_rounded p ≡ Domain (post p) ⊆ Pre p</p>

          <hr />
          <p><strong>is_exact</strong> :: <em>‘a Program ⇒ bool</em></p>

          <p>    is_exact p ≡ is_rounded p ∧ is_feasible p</p>

          <hr />
          <p>
            <strong>feasible_version</strong> ::
            <em>‘a Program ⇒ ‘a Program</em>
          </p>

          <p>
                feasible_version p ≡ 〈State = S p, Pre = Pre p ∩ Domain (post
            p), post = post p〉
          </p>

          <hr />
          <p>
            <strong>rounded_version</strong> :: <em>‘a Program ⇒ ‘a Program</em>
          </p>

          <p>
                rounded_version p ≡ 〈State = S p, Pre = Pre p , post = post p
            /<sub>r</sub> Pre p〉
          </p>

          <hr />
          <p>
            <strong>exact_version</strong> :: <em>‘a Program ⇒ ‘a Program</em>
          </p>

          <p>
                exact_version p ≡ 〈State = S p, Pre = Pre p ∩ Domain (post p) ,
            post = post p /<sub>r</sub> Pre p〉
          </p>

          <hr />
          <p>
            <strong>civilized_n</strong> ::
            <em>‘a Program ⇒ ‘a Program set ⇒ nat ⇒ bool</em>
          </p>

          <p>
                civilized_n x B 0 = (((x ∈ B) ∨ x = Fail {} ∨ x = Skip
            (complete_state (set_to_list B))) ∧ finite B)
          </p>

          <p>
                civilized_n x B (n + 1) = (((∃a b. civilized_n a B n ∧
            civilized_n b B n ∧ (a ; b = x ∨ a ∪<sub>p</sub> b = x)) ∧ finite B)
            ∨ civilized_n x B n)
          </p>

          <hr />
          <p>
            <strong>civilized</strong> ::
            <em>‘a Program ⇒ ‘a Program set ⇒ bool</em>
          </p>

          <p>    civilized x B ≡ (∃n. civilized_n x B n)</p>

          <hr />
          <p><strong>equal_cnf</strong> :: <em>‘a CNF ⇒ ‘a CNF ⇒ bool</em></p>

          <p>
                equal_cnf a b ≡ (set a = set b) ∧ (size a = 1) = (size b = 1)
          </p>

          <hr />
          <p>
            <strong>restrict_path</strong> ::
            <em>‘a Program list ⇒ ‘a set ⇒ ‘a Program list</em>
          </p>

          <p>    restrict_path [ ] C = [ ]</p>

          <p>    restrict_path (x#xs) C = (x /<sub>p</sub> C)#xs</p>

          <hr />
          <p>
            <strong>restriction_cnf [/<sub>c</sub>]</strong> ::
            <em>‘a CNF ⇒ ‘a set ⇒ ‘a CNF</em>
          </p>

          <p>    restriction_cnf p C ≡ [restrict_path path_p C. path_p ← p]</p>

          <hr />
          <p>
            <strong>corestrict_path</strong> ::
            <em>‘a Program list ⇒ ‘a set ⇒ ‘a Program list</em>
          </p>

          <p>    corestrict_path [ ] C = [ ]</p>

          <p>    corestrict_path (xs@[x]) C = xs@[x ∖<sub>p</sub> C]</p>

          <hr />
          <p>
            <strong>corestriction_cnf [∖<sub>c</sub>]</strong> ::
            <em>‘a CNF ⇒ ‘a set ⇒ ‘a CNF</em>
          </p>

          <p>
                corestriction_cnf p C ≡ [corestrict_path path_p C. path_p ← p]
          </p>

          <hr />
          <p><strong>complete_cnf_state</strong> :: <em>‘a CNF ⇒ ‘a set</em></p>

          <table>
            <tbody>
              <tr>
                <td>    complete_cnf_state p ≡ ⋃ {complete_state tr</td>
                <td>tr. tr ∈ set p }</td>
              </tr>
            </tbody>
          </table>

          <hr />
          <p>
            <strong>normal_of</strong> ::
            <em>‘a CNF ⇒ ‘a Program set ⇒ bool</em>
          </p>

          <p>
                normal_of p xs ≡ (basic p ⊆ (xs ∪ {Fail {}, Skip (complete_state
            (set_to_list xs))})) ∧ finite xs
          </p>

          <hr />
          <p><strong>feas_of</strong> :: <em>‘a Program ⇒ ‘a Program</em></p>

          <p>
                feas_of p ≡ 〈State=S p, Pre=Pre p ∩ Domain (post p), post=post
            p〉
          </p>

          <hr />
          <p><strong>set_to_list</strong> :: <em>‘a set ⇒ ‘a list</em></p>

          <p>    set_to_list s = (SOME l. set l = s)</p>

          <hr />
          <p>
            <strong>nmb_interleavings_pre</strong> :: <em>nat ⇒ nat ⇒ nat</em>
          </p>

          <p>
                nmb_interleavings_pre x y ≡ factorial (x + y) div (factorial x *
            factorial y)
          </p>

          <hr />
          <p>
            <strong>nmb_interleavings</strong> ::
            <em>‘a list ⇒ ‘a list ⇒ nat</em>
          </p>

          <p>
                nmb_interleavings xs ys ≡ nmb_interleavings_pre (size xs) (size
            ys)
          </p>

          <hr />
          <p>
            <strong>list_equiv</strong> ::
            <em>‘a Program list ⇒ ‘a Program list ⇒ bool</em>
          </p>

          <p>    list_equiv [ ] [ ] = True</p>

          <p>
                list_equiv (x#xs) (y#ys) = ((x ≡<sub>p</sub> y) ∧ list_equiv xs
            ys)
          </p>

          <p>    list_equiv _ _ = False</p>

          <hr />
          <p><strong>cnf_size</strong> :: <em>‘a CNF ⇒ nat</em></p>

          <p>    cnf_size [ ] = 0</p>

          <p>    cnf_size (x#xs) = length x + cnf_size xs + 1</p>

          <hr />
          <p>
            <strong>equiv_list</strong> ::
            <em>‘a Program list ⇒ ‘a Program list ⇒ bool</em>
          </p>

          <p>    equiv_list [ ] [ ] = True</p>

          <p>    equiv_list (x#xs) [ ] = False</p>

          <p>    equiv_list [ ] (y#ys) = False</p>

          <p>
                equiv_list (x#xs) (y#ys) = (x ≡<sub>p</sub> y ∧ equiv_list xs
            ys)
          </p>

          <hr />
          <p>
            <strong>cnf_concurrency2</strong> ::
            <em>‘a CNF ⇒ ‘a CNF ⇒ ‘a set ⇒ ‘a Program</em>
          </p>

          <p>    cnf_concurrency2 [ ] ys C = Fail {}</p>

          <p>    cnf_concurrency2 xs [ ] C = Fail {}</p>

          <p>
                cnf_concurrency2 (x#xs) (y#ys) C = (case (xs , ys) of ([ ], [ ])
            ⇒ (case (x, y) of ([ ], [ ]) ⇒ Skip C | ([a], [b]) ⇒ a;b ∪<sub
              >p</sub
            >
            b;a | ([ ], bs) ⇒ evaluate [bs] C | (as, [ ]) ⇒ evaluate [as] C |
            (a#as, b#bs) ⇒ a; (cnf_concurrency2 [as] [b#bs] C) ∪<sub>p</sub> b;
            (cnf_concurrency2 [a#as] [bs] C)) | (f#fs, [ ]) ⇒ cnf_concurrency2
            [x] [y] C ∪<sub>p</sub> cnf_concurrency2 (f#fs) [y] C | ([ ], g#gs)
            ⇒ cnf_concurrency2 [x] [y] C ∪<sub>p</sub> cnf_concurrency2 [x]
            (g#gs) C | (f#fs, g#gs) ⇒ cnf_concurrency2 [x] (y#g#gs) C ∪<sub
              >p</sub
            >
            cnf_concurrency2 (f#fs) (y#g#gs) C )
          </p>

          <hr />
          <p><strong>factorial</strong> :: <em>nat ⇒ nat</em></p>

          <p>    factorial 0 = 1</p>

          <p>    factorial (n + 1) = (n + 1) * factorial n</p>

          <hr />
          <p><strong>sum</strong> :: <em>nat list ⇒ nat</em></p>

          <p>    sum [ ] = 0</p>

          <p>    sum (x#xs) = x + sum xs</p>

          <hr />
          <h2 id="relation_operationsthy">Relation_operations.thy</h2>

          <p>
            <strong>restrict_r [/<sub>r</sub>]</strong> ::
            <em>‘a rel ⇒ ‘a set ⇒ ‘a rel</em>
          </p>

          <p>    restrict_r R S = {r ∈ R. fst r ∈ S}</p>

          <hr />
          <p>
            <strong>inv_restrict_r [/<sub>-</sub><sub>r</sub>]</strong> ::
            <em>‘a rel ⇒ ‘a set ⇒ ‘a rel</em>
          </p>

          <p>    inv_restrict_r R S = {r ∈ R. fst r ∉ S}</p>

          <hr />
          <p>
            <strong>corestrict_r [∖<sub>r</sub>]</strong> ::
            <em>‘a rel ⇒ ‘a set ⇒ ‘a rel</em>
          </p>

          <p>    corestrict_r R S = {r ∈ R. snd r ∈ S}</p>

          <hr />
          <p>
            <strong>inv_corestrict_r [∖<sub>-</sub><sub>r</sub>]</strong> ::
            <em>‘a rel ⇒ ‘a set ⇒ ‘a rel</em>
          </p>

          <p>    inv_corestrict_r R S = {r ∈ R. snd r ∉ S}</p>

          <hr />
          <p><strong>is_function</strong> :: <em>‘a rel ⇒ bool</em></p>

          <p>
                is_function R = (∀r<sub>1</sub> ∈ R.∀r<sub>2</sub>∈R. fst r<sub
              >1</sub
            >
            = fst r<sub>2</sub> → snd r<sub>1</sub> = snd r<sub>2</sub>)
          </p>

          <hr />
          <h1 id="theorems-and-lemmas">Theorems and Lemmas</h1>

          <h2 id="mytheorythy">MyTheory.thy</h2>

          <p><strong>this_lemma</strong></p>

          <p>    ((m::nat) + n)<em>(m+n) = m</em>m + 2<em>m</em>n + n*n</p>

          <hr />
          <h2 id="prismthy">PRISM.thy</h2>

          <p><strong>cond_for_commutative_1</strong></p>

          <p>
                Range_p p<sub>1</sub> ∩ Pre p<sub>2</sub> = {} ⟹ Range_p p<sub
              >2</sub
            >
            ∩ Pre p<sub>1</sub> = {} ⟹ commute_programs3 p<sub>1</sub> p<sub
              >2</sub
            >
          </p>

          <hr />
          <p><strong>distinct_state_range_dist_from_pre</strong></p>

          <p>
                used_states p<sub>1</sub> ∩ used_states p<sub>2</sub> = {} ⟹
            Range_p p<sub>1</sub> ∩ Pre p<sub>2</sub> = {} ∧ Range_p p<sub
              >2</sub
            >
            ∩ Pre p<sub>1</sub> = {}
          </p>

          <hr />
          <p>
                used_states p<sub>1</sub> ∩ used_states p<sub>2</sub> = {} ⟹
            commute_programs1 p<sub>1</sub> p<sub>2</sub>
          </p>

          <hr />
          <p>    x; until_loop a C b n ≡<sub>p</sub> until_loop (x;a) C b n</p>

          <hr />
          <p>    p;q ≡<sub>p</sub> p; (q /<sub>p</sub> (Range_p p))</p>

          <hr />
          <h2 id="t_03_basic_programsthy">T_03_Basic_programs.thy</h2>

          <p><strong>special_empty1</strong></p>

          <p>    Skip {} = Fail {}</p>

          <hr />
          <p><strong>special_empty2</strong></p>

          <p>    Havoc {} = Fail {}</p>

          <hr />
          <p><strong>special_empty3</strong></p>

          <p>    Havoc {} = Infeas {}</p>

          <hr />
          <p>    Havoc C = 〈State=C, Pre=TRUE C, post=TRUE<sub>r</sub> C 〉</p>

          <hr />
          <p>    Skip C = 〈State=C, Pre=TRUE C, post=ID C〉</p>

          <hr />
          <p>    Fail C = 〈State=C, Pre=FALSE, post=FALSE〉</p>

          <hr />
          <p>    Infeas C = 〈State=C, Pre=TRUE C, post=FALSE〉</p>

          <hr />
          <p><strong>special_refine1</strong></p>

          <p>    Infeas C ⊑<sub>p</sub> Skip C</p>

          <hr />
          <p><strong>special_refine2</strong></p>

          <p>    Skip C ⊑<sub>p</sub> Havoc C</p>

          <hr />
          <p><strong>special_refine3</strong></p>

          <p>    Havoc C ⊑<sub>p</sub> Fail C</p>

          <hr />
          <p><strong>special_refine4</strong></p>

          <p>    Infeas C ⊑<sub>p</sub> Fail C</p>

          <hr />
          <p><strong>special_specialize1</strong></p>

          <p>    Fail C ⊆<sub>p</sub> Infeas C</p>

          <hr />
          <p><strong>special_specialize2</strong></p>

          <p>    Infeas C ⊆<sub>p</sub> Skip C</p>

          <hr />
          <p><strong>special_specialize3</strong></p>

          <p>    Skip C ⊆<sub>p</sub> Havoc C</p>

          <hr />
          <p>    C ⊆ D ⟹ Fail D ⊑<sub>p</sub> Fail C</p>

          <hr />
          <p>    C ⊆ D ⟹ Fail C ⊆<sub>p</sub> Fail D</p>

          <hr />
          <p>    C ⊆ D ⟹ Infeas D ⊑<sub>p</sub> Infeas C</p>

          <hr />
          <p>    C ⊆ D ⟹ Infeas C ⊆<sub>p</sub> Infeas D</p>

          <hr />
          <p>    C ⊆ D ⟹ Skip D ⊑<sub>p</sub> Skip C</p>

          <hr />
          <p>    C ⊆ D ⟹ Skip C ⊆<sub>p</sub> Skip D</p>

          <hr />
          <p>    C ⊆ D ⟹ Havoc C ⊑<sub>p</sub> Havoc D</p>

          <hr />
          <p>    C ⊆ D ⟹ Havoc D ⊑<sub>p</sub> Havoc C</p>

          <hr />
          <p>    C ⊆ D ⟹ Havoc C ⊆<sub>p</sub> Havoc D</p>

          <hr />
          <h2 id="characteristic_relationthy">Characteristic_relation.thy</h2>

          <p><strong>char_rel_is_unique_in_equality_1</strong></p>

          <p>
                p<sub>1</sub> = p<sub>2</sub> ⟹ char_rel p<sub>1</sub> =
            char_rel p<sub>2</sub>
          </p>

          <hr />
          <p><strong>equal_charrel1</strong></p>

          <p>
                p<sub>1</sub> = p<sub>2</sub> ⟹ char_rel p<sub>1</sub> =
            char_rel p<sub>2</sub>
          </p>

          <hr />
          <p><strong>equiv_charrel1</strong></p>

          <p>
                p<sub>1</sub> ≡<sub>p</sub> p<sub>2</sub> ⟹ char_rel p<sub
              >1</sub
            >
            = char_rel p<sub>2</sub>
          </p>

          <hr />
          <p><strong>char_rel_is_unique_in_equality_2</strong></p>

          <p>
                all_feasible [p<sub>1</sub>, p<sub>2</sub>] ⟹ (char_rel p<sub
              >1</sub
            >
            = char_rel p<sub>2</sub>) ⟹ (p<sub>1</sub> = p<sub>2</sub>)
          </p>

          <hr />
          <p><strong>char_rel_is_unique_in_equal_2</strong></p>

          <p>
                all_feasible [p<sub>1</sub>, p<sub>2</sub>] ⟹ (char_rel p<sub
              >1</sub
            >
            = char_rel p<sub>2</sub>) ⟹ (p<sub>1</sub> = p<sub>2</sub>)
          </p>

          <hr />
          <p><strong>equiv_charrel2</strong></p>

          <p>
                all_feasible [p<sub>1</sub>, p<sub>2</sub>] ⟹ (char_rel p<sub
              >1</sub
            >
            = char_rel p<sub>2</sub>) = (p<sub>1</sub> ≡<sub>p</sub>
            p<sub>2</sub>)
          </p>

          <hr />
          <p><strong>char_rel_choice</strong></p>

          <p>
                char_rel (p<sub>1</sub> ∪<sub>p</sub> p<sub>2</sub>) = char_rel
            p<sub>1</sub> ∪ char_rel p<sub>2</sub>
          </p>

          <hr />
          <p><strong>char_rel_composition</strong></p>

          <p>
                char_rel (p<sub>1</sub> ; p<sub>2</sub>) = char_rel p<sub
              >1</sub
            >
            O char_rel p<sub>2</sub>
          </p>

          <hr />
          <p><strong>char_rel_restriction</strong></p>

          <p>    char_rel (p /<sub>p</sub> C) = char_rel p /<sub>r</sub> C</p>

          <hr />
          <p><strong>char_rel_corestriction</strong></p>

          <p>    char_rel (p ∖<sub>p</sub> C) = char_rel p ∖<sub>r</sub> C</p>

          <hr />
          <p><strong>char_rel_strengthens</strong></p>

          <p>
                strengthens p<sub>1</sub> p<sub>2</sub> ⟹ char_rel p<sub>1</sub>
            /<sub>r</sub> Domain (char_rel p<sub>2</sub>) ⊆ char_rel p<sub
              >2</sub
            >
          </p>

          <hr />
          <p><strong>char_rel_weakens</strong></p>

          <p>
                is_feasible p<sub>1</sub> ⟹ weakens p<sub>1</sub> p<sub>2</sub>
            ⟹ Domain (char_rel p<sub>2</sub>) ⊆ Domain (char_rel p<sub>1</sub>)
          </p>

          <hr />
          <p><strong>char_rel_prop1</strong></p>

          <p>
                p ⊑<sub>p</sub> q ⟹ char_rel p /<sub>r</sub> (Domain (char_rel
            q)) ⊆ char_rel q
          </p>

          <hr />
          <p><strong>charrel_strengthen</strong></p>

          <p>
                all_feasible [p, q] ⟹ char_rel p /<sub>r</sub> (Domain (char_rel
            q)) ⊆ char_rel q = strengthens p q
          </p>

          <hr />
          <p><strong>charrel_weaken</strong></p>

          <p>
                all_feasible [p, q] ⟹ Domain (char_rel q) ⊆ Domain (char_rel p)
            = weakens p q
          </p>

          <hr />
          <p><strong>charrel_specialize</strong></p>

          <p>    q ⊆<sub>p</sub> p ⟹ char_rel q &lt; char_rel p</p>

          <hr />
          <p><strong>charrel_refine</strong></p>

          <p>
                q ⊑<sub>p</sub> p ⟹ char_rel q /<sub>r</sub> (Pre p) &lt;
            char_rel p
          </p>

          <hr />
          <p><strong>char_rel_prop6</strong></p>

          <p>    Field (char_rel a) ⊆ S a</p>

          <hr />
          <h2 id="definitionsthy-1">Definitions.thy</h2>

          <p>
                〈State={}, Pre={1::nat}, post={(1,2)}〉 ⊆<sub>p</sub>
            〈State={}, Pre={1::nat}, post={(1,2)}〉
          </p>

          <hr />
          <p>    Pre p ⊆ I ∧ Range_p p ⊆ I ⟹ Range_p (p /<sub>p</sub> I) ⊆ I</p>

          <hr />
          <p>    a ∪<sub>p</sub> (a ∩<sub>p</sub> b) ≡<sub>p</sub> a</p>

          <hr />
          <p>    a ∩<sub>p</sub> (a ∪<sub>p</sub> b) ≡<sub>p</sub> a</p>

          <hr />
          <p><strong>civ_n_finite</strong></p>

          <p>    civilized_n p B n ⟹ finite B</p>

          <hr />
          <h2 id="equalitiesthy">Equalities.thy</h2>

          <p><strong>equals_equiv_relation_1</strong></p>

          <p>
                p<sub>1</sub> = p<sub>2</sub> ⟹ p<sub>1</sub> = p<sub>2</sub>
          </p>

          <hr />
          <p><strong>equals_equiv_relation_2</strong></p>

          <p>
                p<sub>1</sub> = p<sub>2</sub> ⟹ p<sub>1</sub> ≡<sub>p</sub>
            p<sub>2</sub>
          </p>

          <hr />
          <p><strong>equals_equiv_relation_3</strong></p>

          <p>
                p<sub>1</sub> = p<sub>2</sub> ⟹ p<sub>1</sub> ≡<sub>p</sub>
            p<sub>2</sub>
          </p>

          <hr />
          <p><strong>equal_is_reflexive</strong></p>

          <p>    p<sub>1</sub> = p<sub>1</sub></p>

          <hr />
          <p><strong>equiv_is_reflexive</strong></p>

          <p>    p<sub>1</sub> ≡<sub>p</sub> p<sub>1</sub></p>

          <hr />
          <p><strong>equal_is_symetric</strong></p>

          <p>
                p<sub>1</sub> = p<sub>2</sub> ⟹ p<sub>2</sub> = p<sub>1</sub>
          </p>

          <hr />
          <p><strong>equiv_is_symetric</strong></p>

          <p>
                p<sub>1</sub> ≡<sub>p</sub> p<sub>2</sub> ⟹ p<sub>2</sub> ≡<sub
              >p</sub
            >
            p<sub>1</sub>
          </p>

          <hr />
          <p><strong>equal_is_transitive</strong></p>

          <p>
                p<sub>1</sub> = p<sub>2</sub> ⟹ p<sub>2</sub> = p<sub>3</sub> ⟹
            p<sub>1</sub> = p<sub>3</sub>
          </p>

          <hr />
          <p><strong>equiv_is_transitive</strong></p>

          <p>
                p<sub>1</sub> ≡<sub>p</sub> p<sub>2</sub> ⟹ p<sub>2</sub> ≡<sub
              >p</sub
            >
            p<sub>3</sub> ⟹ p<sub>1</sub> ≡<sub>p</sub> p<sub>3</sub>
          </p>

          <hr />
          <p><strong>inverse_equality_1</strong></p>

          <p>
                ¬ p<sub>1</sub> ≡<sub>p</sub> p<sub>2</sub> ⟹ ¬ p<sub>1</sub> =
            p<sub>2</sub>
          </p>

          <hr />
          <p><strong>inverse_equality_2</strong></p>

          <p>
                ¬ p<sub>1</sub> ≡<sub>p</sub> p<sub>2</sub> ⟹ ¬ p<sub>1</sub> =
            p<sub>2</sub>
          </p>

          <hr />
          <p><strong>inverse_equality_3</strong></p>

          <p>
                ¬ p<sub>1</sub> = p<sub>2</sub> ⟹ ¬ p<sub>1</sub> = p<sub
              >2</sub
            >
          </p>

          <hr />
          <p><strong>empty_state_space_equal</strong></p>

          <p>    S a = {} ⟹ S b = {} ⟹ a = b</p>

          <hr />
          <h2 id="feasibilitythy">Feasibility.thy</h2>

          <p><strong>equal_maintains_feasiblity</strong></p>

          <p>
                is_feasible p<sub>1</sub> ⟹ p<sub>1</sub> = p<sub>2</sub> ⟹
            is_feasible p<sub>2</sub>
          </p>

          <hr />
          <p><strong>equiv_maintains_feasiblity</strong></p>

          <p>
                is_feasible p<sub>1</sub> ⟹ p<sub>1</sub> ≡<sub>p</sub> p<sub
              >2</sub
            >
            ⟹ is_feasible p<sub>2</sub>
          </p>

          <hr />
          <h2 id="helperthy">Helper.thy</h2>

          <p><strong>rel_id_prop</strong></p>

          <p>    Field a ⊆ C ⟹ a O Id_on C = a</p>

          <hr />
          <p><strong>list_comp_prop_1</strong></p>

          <p>
                ∀p. [p i. i ← [0..((int (n + 1)))]] = [p i. i ← [0..(int n)]] @
            [p ((int (n + 1)))]
          </p>

          <hr />
          <p><strong>orig_is_permutation_1</strong></p>

          <p>    List.member (insert_all x xs) (x#xs)</p>

          <hr />
          <p><strong>permutation_reflexive</strong></p>

          <p>    List.member (permutations xs) xs</p>

          <hr />
          <p><strong>l1</strong></p>

          <p>    set (insert_all x (ps)) ≠ {}</p>

          <hr />
          <p><strong>l2</strong></p>

          <p>    x#xs ∈ set (insert_all x xs)</p>

          <hr />
          <p><strong>l3</strong></p>

          <p>    xs@[x] ∈ set (insert_all x xs)</p>

          <hr />
          <p><strong>l4</strong></p>

          <p>    a@x#b ∈ set (insert_all x (a@b))</p>

          <hr />
          <p><strong>l5</strong></p>

          <p>    p ∈ set (insert_all x (a # xs)) ⟹ (hd p = x) ∨ (hd p = a)</p>

          <hr />
          <p><strong>l5_2</strong></p>

          <p>
                p ∈ set (insert_all x (a # xs)) ⟹ (h_hd p = [x]) ∨ (h_hd p =
            [a])
          </p>

          <hr />
          <p><strong>l6</strong></p>

          <p>    h_hd p = [x] ⟹ hd p = x</p>

          <hr />
          <p><strong>l7</strong></p>

          <p>    h_tl p = x ≡ tl p = x</p>

          <hr />
          <p><strong>l8</strong></p>

          <p>    (h_hd p)@(h_tl p) = p</p>

          <hr />
          <p><strong>l9</strong></p>

          <p>
                a#p ∈ set (insert_all x (a # xs)) ⟹ p ∈ set (insert_all x xs)
          </p>

          <hr />
          <p><strong>l10</strong></p>

          <p>    p ∈ set (insert_all x xs) ⟹ ∃a b. a@x#b=p</p>

          <hr />
          <p><strong>l11</strong></p>

          <p>    p ∈ set (insert_all x ps) ⟹ x ∈ set p</p>

          <hr />
          <p><strong>l12</strong></p>

          <p>
                y ∈ set p ⟹ p ∈ set (insert_all x (a # ps)) ⟹ y ≠ a ⟹ p’ ∈ set
            (insert_all x ps) ⟹ y ∈ set p’
          </p>

          <hr />
          <p><strong>l13</strong></p>

          <p>    y ∈ set p ⟹ p ∈ set (insert_all x ps) ⟹ y ∉ set ps ⟹ y = x</p>

          <hr />
          <p><strong>permutation_symmetric_1</strong></p>

          <p>
                List.member (permutations xs) p ⟹ List.member p y ⟹ List.member
            xs y
          </p>

          <hr />
          <p><strong>l14</strong></p>

          <p>
                p ∈ set (insert_all x ps) ⟹ ∃a b. p = a @ x # b ∧ ps = a @ b
          </p>

          <hr />
          <p><strong>count_invariant</strong></p>

          <p>
                List.member (permutations xs) p ⟹ count_list p y = count_list xs
            y
          </p>

          <hr />
          <p><strong>permutation_split</strong></p>

          <p>    List.member (permutations (x#xs)) xs’ ⟹ ∃a b. a@x#b = xs’</p>

          <hr />
          <p><strong>permutation_size</strong></p>

          <p>    List.member (permutations x1) x2 ⟹ size x2 = size x1</p>

          <hr />
          <p><strong>insert_perm_rel</strong></p>

          <p>    x ∈ set (insert_all a xs) ⟹ x ∈ set (permutations (a#xs))</p>

          <hr />
          <p><strong>insert_all_set_equality</strong></p>

          <p>    p1 ∈ set (insert_all x ps) ⟹ set p1 = insert x (set ps)</p>

          <hr />
          <p><strong>permutation_set_equality</strong></p>

          <p>    p1 ∈ set (permutations xs) ⟹ set xs = set p1</p>

          <hr />
          <p><strong>permutation_set_equality_2</strong></p>

          <p>
                p1 ∈ set (permutations xs) ⟹ p2 ∈ set (permutations xs) ⟹ set p1
            = set p2
          </p>

          <hr />
          <p><strong>permutation_split_set</strong></p>

          <p>
                x2 ∈ set (permutations (a # x1)) ⟹ ∃y z. x2 = y @ a # z ∧ y @ z
            ∈ set (permutations x1)
          </p>

          <hr />
          <p><strong>insert_4</strong></p>

          <p>    (xs @ ([x] @ ys)) ∈ set (insert_all x (xs @ ys))</p>

          <hr />
          <p><strong>count_eq_member</strong></p>

          <p>    List.count_list p y &gt; 0 = List.member p y</p>

          <hr />
          <p><strong>member_invariant</strong></p>

          <p>
                p ∈ set (permutations xs) ⟹ List.member p y ⟹ List.member xs y
          </p>

          <hr />
          <p><strong>length_prop_1</strong></p>

          <p>    List.member xs x ⟹ ∃a b. a@[x]@b = xs</p>

          <hr />
          <p><strong>length_prop_2</strong></p>

          <p>    count_list (a @ [x] @ b) x = Suc (count_list (a @ b) x)</p>

          <hr />
          <p><strong>length_prop_3</strong></p>

          <p>
                x<sub>1</sub>≠x<sub>2</sub> ⟹ xs = a@[x<sub>2</sub>]@b ⟹
            count_list (xs) x<sub>1</sub> = count_list (a@b) x<sub>1</sub>
          </p>

          <hr />
          <p><strong>length_prop_4</strong></p>

          <p>
                x<sub>1</sub>=x<sub>2</sub> ⟹ xs = a@[x<sub>2</sub>]@b ⟹
            count_list (xs) x<sub>1</sub> = Suc (count_list (a@b) x<sub>1</sub>)
          </p>

          <hr />
          <p><strong>length_prop_5</strong></p>

          <p>
                ∀x<sub>1</sub>. count_list (a # xs) x<sub>1</sub> = count_list
            (a # xs’) x<sub>1</sub> ⟹ ∀x<sub>1</sub>. count_list (xs) x<sub
              >1</sub
            >
            = count_list (xs’) x<sub>1</sub>
          </p>

          <hr />
          <p><strong>length_prop_6</strong></p>

          <p>
                ∀x<sub>1</sub>. count_list xs x<sub>1</sub> = count_list xs’
            x<sub>1</sub> ⟹ length xs = length xs’
          </p>

          <hr />
          <p><strong>length_inv</strong></p>

          <p>    x ∈ set (permutations xs) ⟹ length x = length xs</p>

          <hr />
          <p><strong>perm_inv_2</strong></p>

          <p>
                xb@xe ∈ set (permutations x1) ⟹ xb@a#xe ∈ set (permutations (a #
            x1))
          </p>

          <hr />
          <p><strong>singleton_permutation</strong></p>

          <p>    [x] ∈ set (permutations xs) ⟹ xs = [x]</p>

          <hr />
          <p><strong>count_invariant_2</strong></p>

          <p>
                ∀y. count_list p y = count_list xs y ⟹ List.member (permutations
            xs) p
          </p>

          <hr />
          <p><strong>count_invariant_3</strong></p>

          <p>
                x1 ∉ set (permutations x2) ⟹ ∃t. count_list x1 t ≠ count_list x2
            t
          </p>

          <hr />
          <p><strong>permutations_set_equality</strong></p>

          <p>
                x1 ∈ set (permutations x2) ⟹ set (permutations x1) = set
            (permutations x2)
          </p>

          <hr />
          <p><strong>perm_lemma_1</strong></p>

          <p>
                x1 ∉ set (permutations x2) ⟹ a # x1 ∉ set (permutations (a #
            x2))
          </p>

          <hr />
          <p><strong>perm_split</strong></p>

          <p>
                a # x1 ∈ set (permutations (y @ a # z)) ⟹ x1 ∈ set (permutations
            (y @ z))
          </p>

          <hr />
          <p><strong>perm_inv_3</strong></p>

          <p>    x1 ∈ set (permutations x2) ⟹ x2 ∈ set (permutations x1)</p>

          <hr />
          <p><strong>orig_is_permutation_3</strong></p>

          <p>
                List.member (permutations x1) x2 ⟹ List.member (permutations x2)
            x1
          </p>

          <hr />
          <p><strong>complete_state_prop_1</strong></p>

          <p>    fold (λ p s. S p ∪ s) xs C = foldl (λ s p. S p ∪ s) C xs</p>

          <hr />
          <p><strong>complete_state_prop_2</strong></p>

          <p>    complete_state xs = fold (∪) (map (λp. S p) xs) {}</p>

          <hr />
          <p><strong>complete_state_prop_3</strong></p>

          <p>    fold (λ p s. S p ∪ s) xs C = fold (∪) (map (λp. S p) xs) C</p>

          <hr />
          <p><strong>complete_state_prop_4</strong></p>

          <p>    fold (∪) xs C = fold (∪) xs {} ∪ C</p>

          <hr />
          <p><strong>complete_state_prop_5</strong></p>

          <p>
                fold (∪) (map (λp. S p) xs) C = fold (∪) (map (λp. S p) xs) {} ∪
            C
          </p>

          <hr />
          <p><strong>complete_state_prop</strong></p>

          <p>    complete_state (x # xs) = complete_state xs ∪ S x</p>

          <hr />
          <p><strong>permutation_complete_state_equality</strong></p>

          <p>
                x1 ∈ set (permutations x2) ⟹ complete_state x2 = complete_state
            x1
          </p>

          <hr />
          <p><strong>permutation_S_equiv</strong></p>

          <p>
                x1 ∈ set (permutations x2) ⟹ fold (∪) (map (λp. S p) x1) {} ≡
            fold (∪) (map (λp. S p) x2) {}
          </p>

          <hr />
          <p><strong>complete_state_union_1</strong></p>

          <p>
                complete_state (a # xs) = complete_state (xs) ∪ complete_state
            ([a])
          </p>

          <hr />
          <p><strong>complete_state_union_2</strong></p>

          <p>
                complete_state (xs) = complete_state (xs) ∪ complete_state ([ ])
          </p>

          <hr />
          <p><strong>complete_state_union_3</strong></p>

          <p>
                complete_state (a @ b) = complete_state a ∪ complete_state b
          </p>

          <hr />
          <p><strong>perm_1</strong></p>

          <p>    x ∈ set (permutations xs) ⟹ a#x ∈ set (permutations (a#xs))</p>

          <hr />
          <p><strong>perm_2</strong></p>

          <p>    set (permutations (a#xs)) = set (permutations (xs@[a]))</p>

          <hr />
          <p><strong>perm_3</strong></p>

          <p>
                set (permutations ([a]@st@ed)) = set (permutations (st@[a]@ed))
          </p>

          <hr />
          <p>
                x ∈ set (permutations xs) ⟹ y ∈ set (permutations ys) ⟹ x@y ∈
            set (permutations (xs@ys))
          </p>

          <hr />
          <p><strong>elements_atomic</strong></p>

          <p>    x ∈ get_atomic p ⟹ is_atomic x</p>

          <hr />
          <p><strong>empty_prop1</strong></p>

          <p>    finite s ⟹ set_to_list s = [ ] ≡ s = {}</p>

          <hr />
          <p><strong>empty_prop2</strong></p>

          <p>    is_feasible p ⟹ get_atomic p = {} ⟹ Pre p = {}</p>

          <hr />
          <p><strong>finite_prop1</strong></p>

          <table>
            <tbody>
              <tr>
                <td>    finite xs ⟹ finite ys ⟹ finite {f a b</td>
                <td>a b . a ∈ xs ∧ b ∈ ys}</td>
              </tr>
            </tbody>
          </table>

          <hr />
          <p><strong>finite_prop2</strong></p>

          <table>
            <tbody>
              <tr>
                <td>    finite xs ⟹ finite ys ⟹ finite {f a b</td>
                <td>a b . (a, b) ∈ xs ∧ a ∉ ys}</td>
              </tr>
            </tbody>
          </table>

          <hr />
          <p><strong>finite_relation</strong></p>

          <p>    finite r ≡ finite (Field r)</p>

          <hr />
          <p><strong>decomp_program</strong></p>

          <table>
            <tbody>
              <tr>
                <td>
                      finite (S p) ⟹ x ∉ F ⟹ S p = insert x F ⟹ q = 〈State={s
                </td>
                <td>s. s ∈ State p ∧ s ∈ F}, Pre={s</td>
                <td>s. s ∈ Pre p ∧ s ∈ F}, post={(a,b)</td>
                <td>a b. a ∈ F ∧ b ∈ F ∧ (a,b) ∈ post p}〉 ⟹ r = 〈State={s</td>
                <td>s. s ∈ State p}, Pre={s</td>
                <td>s. s ∈ Pre p}, post={(a,b)</td>
                <td>
                  a b. (a = x ∨ b = x) ∧ (a,b) ∈ post p}〉 ⟹ p ≡<sub>p</sub> q
                  ∪<sub>p</sub> r
                </td>
              </tr>
            </tbody>
          </table>

          <hr />
          <p><strong>decomp_program2</strong></p>

          <table>
            <tbody>
              <tr>
                <td>
                      finite (S p) ⟹ x ∉ F ⟹ S p = insert x F ⟹ finite (S
                  〈State={s
                </td>
                <td>s. s ∈ State p ∧ s ∈ F}, Pre={s</td>
                <td>s. s ∈ Pre p ∧ s ∈ F}, post={(a,b)</td>
                <td>a b. a ∈ F ∧ b ∈ F ∧ (a,b) ∈ post p}〉)</td>
              </tr>
            </tbody>
          </table>

          <hr />
          <p><strong>decomp_program3</strong></p>

          <table>
            <tbody>
              <tr>
                <td>
                      finite (S p) ⟹ x ∉ F ⟹ S p = insert x F ⟹ finite (S
                  〈State={s
                </td>
                <td>s. s ∈ State p}, Pre={s</td>
                <td>s. s ∈ Pre p}, post={(a,b)</td>
                <td>a b. (a = x ∨ b = x) ∧ (a,b) ∈ post p}〉)</td>
              </tr>
            </tbody>
          </table>

          <hr />
          <p><strong>card_prop</strong></p>

          <p>
                finite a ⟹ b ∩ c = {} ⟹ a = b ∪ c ⟹ card a = card b + card c
          </p>

          <hr />
          <p><strong>card_prop2</strong></p>

          <p>
                finite b ⟹ finite c ⟹ b ∩ c = {} ⟹ a = b ∪ c ⟹ card a = card b +
            card c
          </p>

          <hr />
          <p><strong>finite_prop3</strong></p>

          <table>
            <tbody>
              <tr>
                <td>    finite x ⟹ finite {f a</td>
                <td>a . a ∈ x}</td>
              </tr>
            </tbody>
          </table>

          <hr />
          <p><strong>finite_prop4</strong></p>

          <table>
            <tbody>
              <tr>
                <td>    finite x ⟹ finite {f a b</td>
                <td>a b. (a, b) ∈ x}</td>
              </tr>
            </tbody>
          </table>

          <hr />
          <p><strong>finite_prop5</strong></p>

          <p>    finite (S p) ⟹ finite (get_atomic p)</p>

          <hr />
          <p><strong>atomic_idem</strong></p>

          <p>
                is_atomic p ⟹ (get_atomic p) ∪ {p} = get_atomic (p ∪<sub>p</sub>
            p)
          </p>

          <hr />
          <p><strong>atomic_state</strong></p>

          <p>    is_atomic x ⟹ S x = State x</p>

          <hr />
          <p><strong>atomic_prop1</strong></p>

          <p>
                is_atomic x ⟹ ∃a b. 〈State={a,b}, Pre={a}, post={(a,b)}〉 = x
          </p>

          <hr />
          <p><strong>atomic_prop2</strong></p>

          <p>
                ∃a b. 〈State={a,b}, Pre={a}, post={(a,b)}〉 = x ⟹ is_atomic x
          </p>

          <hr />
          <p><strong>atomic_prop3</strong></p>

          <p>
                ∃a b. 〈State={a,b}, Pre={a}, post={(a,b)}〉 = x ≡ is_atomic x
          </p>

          <hr />
          <p><strong>atomic_post</strong></p>

          <p>    is_atomic x ⟹ restr_post x = post x</p>

          <hr />
          <p><strong>atomic_monotone</strong></p>

          <p>    get_atomic p ⊆ get_atomic (p ∪<sub>p</sub> q)</p>

          <hr />
          <p><strong>atomic_split</strong></p>

          <p>
                finite (get_atomic p) ⟹ finite (get_atomic q) ⟹ (get_atomic p) ∪
            (get_atomic q) = get_atomic (p ∪<sub>p</sub> q)
          </p>

          <hr />
          <p>
                is_atomic x ⟹ (get_atomic p) ∪ {x} = get_atomic (p ∪<sub>p</sub>
            x)
          </p>

          <hr />
          <p><strong>fail_atomic</strong></p>

          <p>    get_atomic (Fail {}) = {}</p>

          <hr />
          <p><strong>set_list_set</strong></p>

          <p>    finite xs ⟹ set (set_to_list xs) = xs</p>

          <hr />
          <p><strong>set_list_prop</strong></p>

          <p>    finite F ⟹ xs = set_to_list (insert x F) ⟹ ∃a b. a@x#b = xs</p>

          <hr />
          <p><strong>set_to_list_distinct</strong></p>

          <p>    xs = set_to_list F ⟹ distinct xs</p>

          <hr />
          <p><strong>set_to_list_size</strong></p>

          <p>    size (set_to_list F) = card F</p>

          <hr />
          <p><strong>set_to_list_one</strong></p>

          <p>    set_to_list {x} = [x]</p>

          <hr />
          <p><strong>atomic_prop_1</strong></p>

          <p>    is_atomic x ⟹ get_atomic x = {x}</p>

          <hr />
          <p><strong>Consistent_feasible</strong></p>

          <p>    is_feasible (feasible_version p)</p>

          <hr />
          <p><strong>Consistent_round</strong></p>

          <p>    is_rounded (rounded_version p)</p>

          <hr />
          <p><strong>Consistent_exact</strong></p>

          <p>    is_exact (exact_version p)</p>

          <hr />
          <p><strong>Feasible_round</strong></p>

          <p>    is_feasible p ⟹ is_feasible (rounded_version p)</p>

          <hr />
          <p><strong>Round_feasible</strong></p>

          <p>    is_rounded p ⟹ is_rounded (feasible_version p)</p>

          <hr />
          <p><strong>Equiv_prog</strong></p>

          <p>
                a ≡<sub>p</sub> b ≡ (Pre (rounded_version a) = Pre
            (rounded_version b) ∧ post (rounded_version a) = post
            (rounded_version b))
          </p>

          <hr />
          <p><strong>Charrel_restriction</strong></p>

          <p>
                rounded_version (p /<sub>p</sub> C) = rounded_version p /<sub
              >p</sub
            >
            C
          </p>

          <hr />
          <p><strong>Charrel_choice</strong></p>

          <p>
                rounded_version (p ∪<sub>p</sub> q) = rounded_version p ∪<sub
              >p</sub
            >
            rounded_version q
          </p>

          <hr />
          <p><strong>Charrel_composition</strong></p>

          <p>
                rounded_version (p ; q) = rounded_version p ; rounded_version q
          </p>

          <hr />
          <p><strong>Charrel_corestriction</strong></p>

          <p>
                rounded_version (p ∖<sub>p</sub> C) = rounded_version p ∖<sub
              >p</sub
            >
            C
          </p>

          <hr />
          <p><strong>Restrict_rounded</strong></p>

          <p>    is_rounded p ⟹ is_rounded (p /<sub>p</sub> C)</p>

          <hr />
          <p><strong>Choice_rounded</strong></p>

          <p>    is_rounded (p ∪<sub>p</sub> q)</p>

          <hr />
          <p>    is_rounded q ⟹ is_rounded p ⟹ is_rounded (p;q)</p>

          <hr />
          <p><strong>Corestrict_feasible</strong></p>

          <p>
                is_feasible p ⟹ is_feasible ((p /<sub>p</sub> (Pre p ∩ Domain
            (post p ∖<sub>r</sub> C))) ∖<sub>p</sub> C)
          </p>

          <hr />
          <h2 id="implementationthy">Implementation.thy</h2>

          <p><strong>implementation_1</strong></p>

          <p>    x ∈ X ⟹ x ∈ Domain (R) ⟹ x ∈ Domain (R /<sub>r</sub> X)</p>

          <hr />
          <p><strong>implementation_theorem</strong></p>

          <p>
                implements p<sub>2</sub> p<sub>1</sub> ⟹ is_feasible p<sub
              >1</sub
            >
          </p>

          <hr />
          <p><strong>implementation_is_reflexive</strong></p>

          <p>
                is_feasible p<sub>1</sub> ⟹ implements p<sub>1</sub> p<sub
              >1</sub
            >
          </p>

          <hr />
          <p><strong>implementation_is_transitive</strong></p>

          <p>
                implements p<sub>1</sub> p<sub>2</sub> ⟹ implements p<sub
              >2</sub
            >
            p<sub>3</sub> ⟹ implements p<sub>1</sub> p<sub>3</sub>
          </p>

          <hr />
          <p><strong>implementation_is_antisymetric</strong></p>

          <p>
                implements p<sub>1</sub> p<sub>2</sub> ⟹ implements p<sub
              >2</sub
            >
            p<sub>1</sub> ⟹ p<sub>1</sub> ≡<sub>p</sub> p<sub>2</sub>
          </p>

          <hr />
          <h2 id="independencethy">Independence.thy</h2>

          <p><strong>independent_symetric</strong></p>

          <p>    independent pâ‡©1 pâ‡©2 = independent pâ‡©2 pâ‡©1</p>

          <hr />
          <p><strong>independent_weakens</strong></p>

          <p>
                independent pâ‡©1 pâ‡©2 âŸ¹ Pre pâ‡©2 â‰  {} âŸ¹ Â¬weakens pâ‡©1
            pâ‡©2
          </p>

          <hr />
          <p><strong>independent_strengthens</strong></p>

          <p>    independent pâ‡©1 pâ‡©2 âŸ¹ strengthens pâ‡©1 pâ‡©2</p>

          <hr />
          <h2 id="range_pthy">Range_p.thy</h2>

          <p><strong>same_range_p_3</strong></p>

          <p>
                p<sub>1</sub> ≡<sub>p</sub> p<sub>2</sub> ⟹ Range_p p<sub
              >1</sub
            >
            = Range_p p<sub>2</sub>
          </p>

          <hr />
          <p><strong>same_range_p_2</strong></p>

          <p>    a = b ⟹ Range_p a = Range_p b</p>

          <hr />
          <p><strong>range_p_explicit_1</strong></p>

          <p>    y ∈ Range_p a ⟹ ∃x. (x,y) ∈ post a ∧ x ∈ Pre a</p>

          <hr />
          <p><strong>range_p_explicit_2</strong></p>

          <p>    (x,y) ∈ post a ∧ x ∈ Pre a ⟹ y ∈ Range_p a</p>

          <hr />
          <p><strong>no_range_fail</strong></p>

          <p>    is_feasible p ⟹ Range_p p = {} ⟹ p ≡<sub>p</sub> Fail {}</p>

          <hr />
          <h2 id="refinementthy">Refinement.thy</h2>

          <p><strong>refines_is_reflexive</strong></p>

          <p>    p<sub>1</sub> ⊑<sub>p</sub> p<sub>1</sub></p>

          <hr />
          <p><strong>refines_is_transitive_e</strong></p>

          <p>
                p<sub>1</sub> ⊑<sub>p</sub> p<sub>2</sub> ⟹ p<sub>2</sub> ⊑<sub
              >p</sub
            >
            p<sub>3</sub> ⟹ extends p<sub>1</sub> p<sub>3</sub>
          </p>

          <hr />
          <p><strong>refines_is_transitive_w</strong></p>

          <p>
                p<sub>1</sub> ⊑<sub>p</sub> p<sub>2</sub> ⟹ p<sub>2</sub> ⊑<sub
              >p</sub
            >
            p<sub>3</sub> ⟹ weakens p<sub>1</sub> p<sub>3</sub>
          </p>

          <hr />
          <p><strong>refines_is_transitive_s</strong></p>

          <p>
                p<sub>1</sub> ⊑<sub>p</sub> p<sub>2</sub> ⟹ p<sub>2</sub> ⊑<sub
              >p</sub
            >
            p<sub>3</sub> ⟹ strengthens p<sub>1</sub> p<sub>3</sub>
          </p>

          <hr />
          <p><strong>refines_is_transitive</strong></p>

          <p>
                p<sub>1</sub> ⊑<sub>p</sub> p<sub>2</sub> ⟹ p<sub>2</sub> ⊑<sub
              >p</sub
            >
            p<sub>3</sub> ⟹ p<sub>1</sub> ⊑<sub>p</sub> p<sub>3</sub>
          </p>

          <hr />
          <p><strong>refines_is_antisymetric</strong></p>

          <p>
                p<sub>1</sub> ⊑<sub>p</sub> p<sub>2</sub> ⟹ p<sub>2</sub> ⊑<sub
              >p</sub
            >
            p<sub>1</sub> ⟹ p<sub>1</sub> ≡<sub>p</sub> p<sub>2</sub>
          </p>

          <hr />
          <p><strong>refines_is_preorder</strong></p>

          <p>
                p<sub>1</sub> ⊑<sub>p</sub> p<sub>1</sub> ∧ (p<sub>2</sub> ⊑<sub
              >p</sub
            >
            p<sub>3</sub> ∧ p<sub>3</sub> ⊑<sub>p</sub> p<sub>4</sub> → p<sub
              >2</sub
            >
            ⊑<sub>p</sub> p<sub>4</sub>)
          </p>

          <hr />
          <p><strong>refines_is_order</strong></p>

          <p>
                (p<sub>1</sub> ⊑<sub>p</sub> p<sub>1</sub>) ∧ (p<sub>2</sub>
            ⊑<sub>p</sub> p<sub>3</sub> ∧ p<sub>3</sub> ⊑<sub>p</sub> p<sub
              >4</sub
            >
            → p<sub>2</sub> ⊑<sub>p</sub> p<sub>4</sub>) ∧ (p<sub>5</sub> ⊑<sub
              >p</sub
            >
            p<sub>6</sub> ∧ p<sub>6</sub> ⊑<sub>p</sub> p<sub>5</sub> → p<sub
              >5</sub
            >
            ≡<sub>p</sub> p<sub>6</sub>)
          </p>

          <hr />
          <p><strong>extends_is_reflexive</strong></p>

          <p>    extends p p</p>

          <hr />
          <p><strong>extends_is_transitive</strong></p>

          <p>    extends p q ⟹ extends q r ⟹ extends p r</p>

          <hr />
          <p><strong>weakens_is_reflexive</strong></p>

          <p>    weakens p p</p>

          <hr />
          <p><strong>weakens_is_transitive</strong></p>

          <p>    weakens p q ⟹ weakens q r ⟹ weakens p r</p>

          <hr />
          <p><strong>strengthens_is_reflexive</strong></p>

          <p>    strengthens p p</p>

          <hr />
          <p><strong>strengthens_is_transitive_1</strong></p>

          <p>
                weakens p q ⟹ weakens q r ⟹ strengthens p q ⟹ strengthens q r ⟹
            strengthens p r
          </p>

          <hr />
          <p><strong>strengthens_is_transitive_2</strong></p>

          <p>
                weakens q p ⟹ weakens r q ⟹ strengthens p q ⟹ strengthens q r ⟹
            strengthens p r
          </p>

          <hr />
          <h2 id="relation_operationsthy-1">Relation_operations.thy</h2>

          <p><strong>corestriction_restriction_on_relcomp</strong></p>

          <p>
                r<sub>1</sub> ∖<sub>r</sub> s<sub>1</sub> O r<sub>2</sub> =
            r<sub>1</sub> O r<sub>2</sub> /<sub>r</sub> s<sub>1</sub>
          </p>

          <hr />
          <h2 id="subprogramthy">Subprogram.thy</h2>

          <p><strong>specialize_is_reflexive</strong></p>

          <p>    p<sub>1</sub> ⊆<sub>p</sub> p<sub>1</sub></p>

          <hr />
          <p><strong>specialize_is_transitive</strong></p>

          <p>
                p<sub>1</sub> ⊆<sub>p</sub> p<sub>2</sub> ⟹ p<sub>2</sub> ⊆<sub
              >p</sub
            >
            p<sub>3</sub> ⟹ p<sub>1</sub> ⊆<sub>p</sub> p<sub>3</sub>
          </p>

          <hr />
          <p><strong>specialize_is_antisymetric</strong></p>

          <p>
                p<sub>1</sub> ⊆<sub>p</sub> p<sub>2</sub> ⟹ p<sub>2</sub> ⊆<sub
              >p</sub
            >
            p<sub>1</sub> ⟹ p<sub>1</sub> ≡<sub>p</sub> p<sub>2</sub>
          </p>

          <hr />
          <p><strong>specialize_is_preorder</strong></p>

          <p>
                p<sub>1</sub> ⊆<sub>p</sub> p<sub>1</sub> ∧ (p<sub>2</sub> ⊆<sub
              >p</sub
            >
            p<sub>3</sub> ∧ p<sub>3</sub> ⊆<sub>p</sub> p<sub>4</sub> → p<sub
              >2</sub
            >
            ⊆<sub>p</sub> p<sub>4</sub>)
          </p>

          <hr />
          <p><strong>specialize_is_order</strong></p>

          <p>
                (p<sub>1</sub> ⊆<sub>p</sub> p<sub>1</sub>) ∧ (p<sub>2</sub>
            ⊆<sub>p</sub> p<sub>3</sub> ∧ p<sub>3</sub> ⊆<sub>p</sub> p<sub
              >4</sub
            >
            → p<sub>2</sub> ⊆<sub>p</sub> p<sub>4</sub>) ∧ (p<sub>5</sub> ⊆<sub
              >p</sub
            >
            p<sub>6</sub> ∧ p<sub>6</sub> ⊆<sub>p</sub> p<sub>5</sub> → p<sub
              >5</sub
            >
            ≡<sub>p</sub> p<sub>6</sub>)
          </p>

          <hr />
          <p><strong>choice_decomp_1</strong></p>

          <p>
                a ⊆<sub>p</sub> c ∧ b ⊆<sub>p</sub> c ⟹ a ∪<sub>p</sub> b ⊆<sub
              >p</sub
            >
            c
          </p>

          <hr />
          <p><strong>choice_decomp_2</strong></p>

          <p>
                a ∪<sub>p</sub> b ⊆<sub>p</sub> c ⟹ a ⊆<sub>p</sub> c ∧ b ⊆<sub
              >p</sub
            >
            c
          </p>

          <hr />
          <p><strong>choice_decomp</strong></p>

          <p>
                a ⊆<sub>p</sub> c ∧ b ⊆<sub>p</sub> c ≡ a ∪<sub>p</sub> b ⊆<sub
              >p</sub
            >
            c
          </p>

          <hr />
          <p><strong>specialize_equiv</strong></p>

          <p>
                a ⊆<sub>p</sub> b ⟹ a ≡<sub>p</sub> c ⟹ b ≡<sub>p</sub> d ⟹ c
            ⊆<sub>p</sub> d
          </p>

          <hr />
          <p><strong>equiv_specialize_transitivity</strong></p>

          <p>
                S a ⊆ S b ⟹ S c ⊆ S d ⟹ a ≡<sub>p</sub> b ⟹ b ⊆<sub>p</sub> c ⟹
            c ≡<sub>p</sub> d ⟹ a ⊆<sub>p</sub> d
          </p>

          <hr />
          <h2 id="validitythy">Validity.thy</h2>

          <p><strong>valid_generalization</strong></p>

          <p>    is_valid p ⟹ prop (S p) = prop (State p)</p>

          <hr />
          <p><strong>pre_in_s</strong></p>

          <p>    is_valid p ⟹ Pre p ⊆ State p</p>

          <hr />
          <p><strong>post_in_s</strong></p>

          <p>    is_valid p ⟹ (Field (post p) ⊆ State p)</p>

          <hr />
          <p><strong>validity_inverse</strong></p>

          <p>    is_valid p ⟹ is_valid (p<sup>-</sup><sup>1</sup>)</p>

          <hr />
          <p><strong>validity_composition</strong></p>

          <p>
                all_valid [p<sub>1</sub>, p<sub>2</sub>] ⟹ is_valid (p<sub
              >1</sub
            >
            ; p<sub>2</sub>)
          </p>

          <hr />
          <p><strong>validity_choice</strong></p>

          <p>
                all_valid [p<sub>1</sub>, p<sub>2</sub>] ⟹ is_valid (p<sub
              >1</sub
            >
            ∪<sub>p</sub> p<sub>2</sub>)
          </p>

          <hr />
          <p><strong>validity_restriction</strong></p>

          <p>    is_valid p ⟹ is_valid (p /<sub>p</sub> C)</p>

          <hr />
          <p><strong>validity_corestriction</strong></p>

          <p>    is_valid p ⟹ is_valid (p ∖<sub>p</sub> C)</p>

          <hr />
          <p><strong>validity_equality</strong></p>

          <p>    is_valid p ⟹ is_valid q ⟹ p = q ⟹ p = q</p>

          <hr />
          <h2 id="choicethy">Choice.thy</h2>

          <p><strong>choice_idem_4</strong></p>

          <p>
                Fail {} ∪<sub>p</sub> (p ∪<sub>p</sub> p) = Fail {} ∪<sub
              >p</sub
            >
            p
          </p>

          <hr />
          <p><strong>choice_idem_5</strong></p>

          <p>    q ∪<sub>p</sub> (p ∪<sub>p</sub> p) = q ∪<sub>p</sub> p</p>

          <hr />
          <p><strong>choice_idem_6</strong></p>

          <p>    (p ∪<sub>p</sub> p) ∪<sub>p</sub> q = p ∪<sub>p</sub> q</p>

          <hr />
          <p><strong>choice_equiv</strong></p>

          <p>
                f<sub>1</sub> ≡<sub>p</sub> p<sub>1</sub> ⟹ f<sub>2</sub> ≡<sub
              >p</sub
            >
            p<sub>2</sub> ⟹ f<sub>1</sub> ∪<sub>p</sub> f<sub>2</sub> ≡<sub
              >p</sub
            >
            p<sub>1</sub> ∪<sub>p</sub> p<sub>2</sub>
          </p>

          <hr />
          <p><strong>equality_is_maintained_by_choice</strong></p>

          <p>
                f<sub>1</sub> = p<sub>1</sub> ⟹ f<sub>2</sub> = p<sub>2</sub> ⟹
            f<sub>1</sub> ∪<sub>p</sub> f<sub>2</sub> = p<sub>1</sub> ∪<sub
              >p</sub
            >
            p<sub>2</sub>
          </p>

          <hr />
          <p><strong>choice_feasible</strong></p>

          <p>
                all_feasible [p<sub>1</sub>, p<sub>2</sub>] ⟹ is_feasible (p<sub
              >1</sub
            >
            ∪<sub>p</sub> p<sub>2</sub>)
          </p>

          <hr />
          <p><strong>condition_for_choice_simplification</strong></p>

          <p>
                Range_p a ∩ Pre y = {} ⟹ Range_p x ∩ Pre b = {} ⟹ a;b ∪<sub
              >p</sub
            >
            x;y ≡<sub>p</sub> (a ∪<sub>p</sub> x) ; (b ∪<sub>p</sub> y)
          </p>

          <hr />
          <p><strong>choice_range</strong></p>

          <p>
                Range_p (p<sub>1</sub> ∪<sub>p</sub> p<sub>2</sub>) = Range_p
            p<sub>1</sub> ∪ Range_p p<sub>2</sub>
          </p>

          <hr />
          <p><strong>refinement_safety_choice_e</strong></p>

          <p>
                q<sub>1</sub> ⊑<sub>p</sub> p<sub>1</sub> ⟹ q<sub>2</sub> ⊑<sub
              >p</sub
            >
            p<sub>2</sub> ⟹ extends (q<sub>1</sub> ∪<sub>p</sub> q<sub>2</sub>)
            (p<sub>1</sub> ∪<sub>p</sub> p<sub>2</sub>)
          </p>

          <hr />
          <p><strong>refinement_safety_choice_w</strong></p>

          <p>
                q<sub>1</sub> ⊑<sub>p</sub> p<sub>1</sub> ⟹ q<sub>2</sub> ⊑<sub
              >p</sub
            >
            p<sub>2</sub> ⟹ weakens (q<sub>1</sub> ∪<sub>p</sub> q<sub>2</sub>)
            (p<sub>1</sub> ∪<sub>p</sub> p<sub>2</sub>)
          </p>

          <hr />
          <p><strong>refinement_safety_choice_s_1</strong></p>

          <p>
                q<sub>1</sub> ⊑<sub>p</sub> p<sub>1</sub> ⟹ q<sub>2</sub> ⊑<sub
              >p</sub
            >
            p<sub>2</sub> ⟹ strengthens (q<sub>1</sub> ∪<sub>p</sub>
            q<sub>2</sub>) (p<sub>1</sub> ∪<sub>p</sub> p<sub>2</sub>)
          </p>

          <hr />
          <p><strong>refinement_safety_choice_s_2</strong></p>

          <p>
                strengthens q<sub>1</sub> p<sub>2</sub> ⟹ strengthens q<sub
              >2</sub
            >
            p<sub>1</sub> ⟹ q<sub>1</sub> ⊑<sub>p</sub> p<sub>1</sub> ⟹ q<sub
              >2</sub
            >
            ⊑<sub>p</sub> p<sub>2</sub> ⟹ strengthens (q<sub>1</sub> ∪<sub
              >p</sub
            >
            q<sub>2</sub>) (p<sub>1</sub> ∪<sub>p</sub> p<sub>2</sub>)
          </p>

          <hr />
          <p><strong>refinement_safety_choice</strong></p>

          <p>
                q<sub>1</sub> ⊑<sub>p</sub> p<sub>1</sub> ⟹ q<sub>2</sub> ⊑<sub
              >p</sub
            >
            p<sub>2</sub> ⟹ (q<sub>1</sub> ∪<sub>p</sub> q<sub>2</sub>) ⊑<sub
              >p</sub
            >
            (p<sub>1</sub> ∪<sub>p</sub> p<sub>2</sub>)
          </p>

          <hr />
          <p><strong>refinement_safety_choice</strong></p>

          <p>
                strengthens a c ⟹ a ⊑<sub>p</sub> b ⟹ (a ∪<sub>p</sub> c) ⊑<sub
              >p</sub
            >
            (b ∪<sub>p</sub> c)
          </p>

          <hr />
          <p><strong>refinement_safety_choice_1</strong></p>

          <p>
                strengthens q<sub>1</sub> p<sub>2</sub> ⟹ strengthens q<sub
              >2</sub
            >
            p<sub>1</sub> ⟹ q<sub>1</sub> ⊑<sub>p</sub> p<sub>1</sub> ⟹ q<sub
              >2</sub
            >
            ⊑<sub>p</sub> p<sub>2</sub> ⟹ (q<sub>1</sub> ∪<sub>p</sub>
            q<sub>2</sub>) ⊑<sub>p</sub> (p<sub>1</sub> ∪<sub>p</sub>
            p<sub>2</sub>)
          </p>

          <hr />
          <p><strong>refinement_safety_choice_2</strong></p>

          <p>
                independent q<sub>1</sub> p<sub>2</sub> ⟹ independent q<sub
              >2</sub
            >
            p<sub>1</sub> ⟹ q<sub>1</sub> ⊑<sub>p</sub> p<sub>1</sub> ⟹ q<sub
              >2</sub
            >
            ⊑<sub>p</sub> p<sub>2</sub> ⟹ (q<sub>1</sub> ∪<sub>p</sub>
            q<sub>2</sub>) ⊑<sub>p</sub> (p<sub>1</sub> ∪<sub>p</sub>
            p<sub>2</sub>)
          </p>

          <hr />
          <p><strong>choice_safety1</strong></p>

          <p>
                a ⊆<sub>p</sub> b ⟹ a ∪<sub>p</sub> c ⊆<sub>p</sub> b ∪<sub
              >p</sub
            >
            c
          </p>

          <hr />
          <p><strong>implements_safety_choice</strong></p>

          <p>
                is_feasible c ⟹ implements a b ⟹ implements (a ∪<sub>p</sub> c)
            (b ∪<sub>p</sub> c)
          </p>

          <hr />
          <p><strong>implements_safety_choice</strong></p>

          <p>
                strengthens a c ⟹ is_feasible c ⟹ implements a b ⟹ implements (a
            ∪<sub>p</sub> c) (b ∪<sub>p</sub> c)
          </p>

          <hr />
          <p><strong>program_is_specialize_of_choice</strong></p>

          <p>
                p<sub>1</sub> ⊆<sub>p</sub> (p<sub>1</sub> ∪<sub>p</sub>
            p<sub>2</sub>)
          </p>

          <hr />
          <p><strong>choice_choice_range</strong></p>

          <p>    Range_p p ⊆ Range_p (p ∪<sub>p</sub> q)</p>

          <hr />
          <p><strong>choice_range_p_prop_2</strong></p>

          <p>
                x ∈ Range_p (p ∪<sub>p</sub> q) ⟹ x ∉ Range_p p ⟹ x ∈ Range_p q
          </p>

          <hr />
          <p><strong>choice_range_p_prop_3</strong></p>

          <p>    x ∉ Range_p (p ∪<sub>p</sub> q) ⟹ x ∉ Range_p p</p>

          <hr />
          <p><strong>empty_is_neutral</strong></p>

          <p>
                S a = {} ⟹ a ∪<sub>p</sub> (b ∪<sub>p</sub> c) = b ∪<sub>p</sub>
            c
          </p>

          <hr />
          <p><strong>choice_idem_2</strong></p>

          <p>    a ∪<sub>p</sub> (a ∪<sub>p</sub> b) = a ∪<sub>p</sub> b</p>

          <hr />
          <p><strong>choice_suprogram_prop</strong></p>

          <p>
                a ⊆<sub>p</sub> c ⟹ b ⊆<sub>p</sub> c ⟹ a ∪<sub>p</sub> b ⊆<sub
              >p</sub
            >
            c
          </p>

          <hr />
          <h2 id="compositionthy">Composition.thy</h2>

          <p><strong>composition_simplification_1</strong></p>

          <p>
                p<sub>1</sub> ; p<sub>2</sub> = p<sub>1</sub> ∖<sub>p</sub> Pre
            p<sub>2</sub> ; p<sub>2</sub>
          </p>

          <hr />
          <p><strong>composition_simplification_2</strong></p>

          <p>
                p<sub>1</sub> ; p<sub>2</sub> = p<sub>1</sub> ; p<sub>2</sub>
            /<sub>p</sub> Pre p<sub>2</sub>
          </p>

          <hr />
          <p><strong>composition_equiv</strong></p>

          <p>
                f<sub>1</sub> ≡<sub>p</sub> p<sub>1</sub> ⟹ f<sub>2</sub> ≡<sub
              >p</sub
            >
            p<sub>2</sub> ⟹ f<sub>1</sub> ; f<sub>2</sub> ≡<sub>p</sub> p<sub
              >1</sub
            >
            ; p<sub>2</sub>
          </p>

          <hr />
          <p><strong>equality_is_maintained_by_composition</strong></p>

          <p>
                f<sub>1</sub> = p<sub>1</sub> ⟹ f<sub>2</sub> = p<sub>2</sub> ⟹
            f<sub>1</sub> ; f<sub>2</sub> = p<sub>1</sub> ; p<sub>2</sub>
          </p>

          <hr />
          <p><strong>compose_feasible_lemma</strong></p>

          <p>
                all_feasible [p<sub>1</sub>, p<sub>2</sub>] ⟹ Domain ((post
            p<sub>1</sub>) ∖<sub>r</sub> (Pre p<sub>2</sub>)) = Domain ((post
            p<sub>1</sub>) ∖<sub>r</sub> (Pre p<sub>2</sub>) O post
            p<sub>2</sub>)
          </p>

          <hr />
          <p><strong>compose_feasible2</strong></p>

          <p>
                all_feasible [p<sub>1</sub>, p<sub>2</sub>] ⟹ is_feasible (p<sub
              >1</sub
            >
            ; p<sub>2</sub>)
          </p>

          <hr />
          <p><strong>composition_removes_dead_code_1</strong></p>

          <p>    p /<sub>p</sub> (Pre p) ; q ≡<sub>p</sub> p ; q</p>

          <hr />
          <p><strong>composition_removes_dead_code_2</strong></p>

          <p>    p ; q /<sub>p</sub> (Pre q) ≡<sub>p</sub> p ; q</p>

          <hr />
          <p><strong>compose_feasible</strong></p>

          <p>
                is_feasible p<sub>2</sub> ⟹ is_feasible (p<sub>1</sub> ;
            p<sub>2</sub>)
          </p>

          <hr />
          <p>
                p<sub>1</sub> ; p<sub>2</sub> ≡<sub>p</sub> 〈State ={}, Pre=Pre
            p<sub>1</sub> ∩ Domain (post p<sub>1</sub> ∖<sub>r</sub> Pre
            p<sub>2</sub>), post=post p<sub>1</sub>〉 ; p<sub>2</sub>
          </p>

          <hr />
          <p><strong>range_decreases_composition</strong></p>

          <p>    Range_p (y;x) ⊆ Range_p x</p>

          <hr />
          <p>    p ⊑<sub>p</sub> q ⟹ p;a ⊑<sub>p</sub> q;a</p>

          <hr />
          <p><strong>composition_subsafety</strong></p>

          <p>    a ⊆<sub>p</sub> b ⟹ a;c ⊆<sub>p</sub> b;c</p>

          <hr />
          <p><strong>composition_subsafety2</strong></p>

          <p>    a ⊆<sub>p</sub> b ⟹ c;a ⊆<sub>p</sub> c;b</p>

          <hr />
          <p><strong>comp_range_p_prop</strong></p>

          <p>    Range_p (q) ⊆ C ⟹ Range_p (p;q) ⊆ C</p>

          <hr />
          <p><strong>comp_range_p_prop_2</strong></p>

          <p>    x ∉ Range_p q ⟹ x ∉ Range_p (p;q)</p>

          <hr />
          <p><strong>connecting_element</strong></p>

          <p>
                (x,y) ∈ post (a;b) ⟹ ∃z. (x,z) ∈ post a ∧ (z,y) ∈ post b ∧ z ∈
            Pre b
          </p>

          <hr />
          <p><strong>knowing_pre_composition</strong></p>

          <p>    x ∈ Pre (a) ⟹ (x, y) ∈ post (a; b) ⟹ x ∈ Pre (a ; b)</p>

          <hr />
          <h2 id="corestrictionthy">Corestriction.thy</h2>

          <p><strong>corestrict_idem</strong></p>

          <p>    (p ∖<sub>p</sub> C) ∖<sub>p</sub> C = p ∖<sub>p</sub> C</p>

          <hr />
          <p><strong>corestrict_prop_1</strong></p>

          <p>    Range_p (p ∖<sub>p</sub> D) ⊆ D</p>

          <hr />
          <p><strong>corestrict_prop_2</strong></p>

          <p>    Range_p (p ∖<sub>p</sub> D) ⊆ Range_p p</p>

          <hr />
          <p><strong>corestrict_prop_</strong></p>

          <p>    Range_p (p ∖<sub>p</sub> D) ⊆ Range_p p ∩ D</p>

          <hr />
          <p><strong>NOT_corestricted_p_refines_p</strong></p>

          <p>    p ∖<sub>p</sub> C ⊑<sub>p</sub> p</p>

          <hr />
          <p><strong>NOT_p_refines_corestricted_p</strong></p>

          <p>    p ⊑<sub>p</sub> p ∖<sub>p</sub> C</p>

          <hr />
          <p><strong>corestricted_refines_unrestricted_1</strong></p>

          <p>    p ∖<sub>p</sub> C ⊑<sub>p</sub> p</p>

          <hr />
          <p><strong>unrestricted_refines_corestricted_1</strong></p>

          <p>    p ⊑<sub>p</sub> p ∖<sub>p</sub> C</p>

          <hr />
          <p><strong>corestricted_refines_unrestricted_2</strong></p>

          <p>    is_feasible p ⟹ p ∖<sub>p</sub> C ⊑<sub>p</sub> p</p>

          <hr />
          <p><strong>unrestricted_refines_corestricted_2</strong></p>

          <p>    is_feasible p ⟹ p ⊑<sub>p</sub> p ∖<sub>p</sub> C</p>

          <hr />
          <p><strong>corestrict_subprog</strong></p>

          <p>    p ∖<sub>p</sub> C ⊆<sub>p</sub> p</p>

          <hr />
          <p><strong>unrestricted_weakens_corestricted</strong></p>

          <p>    weakens p (p ∖<sub>p</sub> C)</p>

          <hr />
          <p><strong>corestricted_strengthens_unrestricted</strong></p>

          <p>    strengthens (p ∖<sub>p</sub> C) p</p>

          <hr />
          <p><strong>corestriction_prop</strong></p>

          <p>    D ⊆ C ⟹ p ∖<sub>p</sub> D ⊑<sub>p</sub> p ∖<sub>p</sub> C</p>

          <hr />
          <p><strong>corestriction_prop</strong></p>

          <p>    D ⊆ C ⟹ p ∖<sub>p</sub> C ⊑<sub>p</sub> p ∖<sub>p</sub> D</p>

          <hr />
          <p><strong>corestriction_weakens_prop</strong></p>

          <p>    D ⊆ C ⟹ weakens (p ∖<sub>p</sub> C) (p ∖<sub>p</sub> D)</p>

          <hr />
          <p><strong>corestriction_strengthens_prop</strong></p>

          <p>    D ⊆ C ⟹ strengthens (p ∖<sub>p</sub> D) (p ∖<sub>p</sub> C)</p>

          <hr />
          <p><strong>corestrict_subprogorder1</strong></p>

          <p>
                D ⊆ C ⟹ (p ∖<sub>p</sub> D) ⊆<sub>p</sub> (p ∖<sub>p</sub> C)
          </p>

          <hr />
          <p><strong>equivalence_is_maintained_by_corestriction</strong></p>

          <p>
                f<sub>1</sub> ≡<sub>p</sub> p<sub>1</sub> ⟹ (f<sub>1</sub> ∖<sub
              >p</sub
            >
            C) ≡<sub>p</sub> p<sub>1</sub> ∖<sub>p</sub> C
          </p>

          <hr />
          <p><strong>equality_is_maintained_by_corestriction</strong></p>

          <p>
                f<sub>1</sub> = p<sub>1</sub> ⟹ (f<sub>1</sub> ∖<sub>p</sub> C)
            = p<sub>1</sub> ∖<sub>p</sub> C
          </p>

          <hr />
          <p><strong>corestrict_feasible</strong></p>

          <p>    is_feasible p ⟹ is_feasible (p ∖<sub>p</sub> C)</p>

          <hr />
          <p><strong>corestriction_subsafety</strong></p>

          <p>
                q ⊆<sub>p</sub> p ⟹ q ∖<sub>p</sub> C ⊆<sub>p</sub> p ∖<sub
              >p</sub
            >
            C
          </p>

          <hr />
          <p><strong>refinement_safety_corestriction</strong></p>

          <p>
                q ⊑<sub>p</sub> p ⟹ q ∖<sub>p</sub> C ⊑<sub>p</sub> p ∖<sub
              >p</sub
            >
            C
          </p>

          <hr />
          <p><strong>implements_safety_corestriction</strong></p>

          <p>
                implements a b ⟹ implements (a ∖<sub>p</sub> C) (b ∖<sub>p</sub>
            C)
          </p>

          <hr />
          <p><strong>weakens_corestriction_1</strong></p>

          <p>
                all_feasible [p, q] ⟹ q ⊑<sub>p</sub> p ⟹ weakens (q ∖<sub
              >p</sub
            >
            C) (p ∖<sub>p</sub> C)
          </p>

          <hr />
          <p><strong>weakens_corestriction_2</strong></p>

          <p>
                q ⊑<sub>p</sub> p ⟹ weakens (p ∖<sub>p</sub> C) (q ∖<sub>p</sub>
            C)
          </p>

          <hr />
          <p><strong>strengthens_corestriction_1</strong></p>

          <p>
                q ⊑<sub>p</sub> p ⟹ strengthens (p ∖<sub>p</sub> C) (q ∖<sub
              >p</sub
            >
            C)
          </p>

          <hr />
          <p><strong>strengthens_corestriction_2</strong></p>

          <p>
                q ⊑<sub>p</sub> p ⟹ strengthens (q ∖<sub>p</sub> C) (p ∖<sub
              >p</sub
            >
            C)
          </p>

          <hr />
          <p><strong>corestrict_range_prop</strong></p>

          <p>    x ∈ C ⟹ x ∉ Range_p (p ∖<sub>p</sub> C) ⟹ x ∉ Range_p (p)</p>

          <hr />
          <p><strong>corestrict_range_prop_2</strong></p>

          <p>
                is_feasible a ⟹ Range_p a ⊆ C ⟹ a ∖<sub>p</sub> C ≡<sub>p</sub>
            a
          </p>

          <hr />
          <p><strong>corestrict_range_prop_3</strong></p>

          <p>    Range_p(a) ∩ C = {} ⟹ a∖<sub>p</sub>C ≡<sub>p</sub> Fail {}</p>

          <hr />
          <p><strong>corestrict_range_porp_4</strong></p>

          <p>    is_feasible p ⟹ p ∖<sub>p</sub> Range_p p ≡<sub>p</sub> p</p>

          <hr />
          <p><strong>corestrict_inter</strong></p>

          <p>
                (p ∖<sub>p</sub> C) ∖<sub>p</sub> D = p∖<sub>p</sub> (C ∩ D)
          </p>

          <hr />
          <p><strong>corestrict_commute</strong></p>

          <p>
                (p ∖<sub>p</sub> C) ∖<sub>p</sub> D = (p ∖<sub>p</sub> D) ∖<sub
              >p</sub
            >
            C
          </p>

          <hr />
          <h2 id="inversethy">Inverse.thy</h2>

          <p><strong>inverse_feasible</strong></p>

          <p>    is_feasible p ⟹ is_feasible (p<sup>-</sup><sup>1</sup>)</p>

          <hr />
          <p><strong>inverse_of_inverse_is_self</strong></p>

          <p>
                is_feasible p ⟹ p<sup>-</sup><sup>1</sup><sup>-</sup
            ><sup>1</sup> ≡<sub>p</sub> p
          </p>

          <hr />
          <p><strong>pre_of_inverse</strong></p>

          <p>
                is_deterministic (p<sup>-</sup><sup>1</sup>) ⟹ Pre p = Pre (p ;
            (p<sup>-</sup><sup>1</sup>))
          </p>

          <hr />
          <p><strong>pre_is_unchanged</strong></p>

          <p>
                is_feasible p ⟹ Pre (p ; (p<sup>-</sup><sup>1</sup>)) = Pre p
          </p>

          <hr />
          <p><strong>post_is_identity</strong></p>

          <p>
                is_deterministic (p<sup>-</sup><sup>1</sup>) ⟹ (x,y)∈ restr_post
            (p ; (p<sup>-</sup><sup>1</sup>)) ⟹ x = y
          </p>

          <hr />
          <p><strong>post_is_identity_2</strong></p>

          <p>
                is_deterministic (p<sup>-</sup><sup>1</sup>) ⟹ (x,y)∈ restr_post
            (p ;<sub>p</sub> (p<sup>-</sup><sup>1</sup>)) ⟹ x = y
          </p>

          <hr />
          <p><strong>post_of_inverse</strong></p>

          <p>
                is_feasible p ⟹ is_deterministic (p<sup>-</sup><sup>1</sup>) ⟹
            restr_post (Skip (Pre p)) = restr_post (p ; (p<sup>-</sup
            ><sup>1</sup>))
          </p>

          <hr />
          <p><strong>inverse_reverses_composition_1</strong></p>

          <p>
                is_feasible p ⟹ is_deterministic (p<sup>-</sup><sup>1</sup>) ⟹
            Skip (Pre p) ≡<sub>p</sub> (p ; (p<sup>-</sup><sup>1</sup>))
          </p>

          <hr />
          <p><strong>inverse_reverses_composition_2</strong></p>

          <p>    Skip (S p) ⊑<sub>p</sub> (p ; (p<sup>-</sup><sup>1</sup>))</p>

          <hr />
          <p><strong>equivalence_is_maintained_by_inverse</strong></p>

          <p>
                f ≡<sub>p</sub> p ⟹ f<sup>-</sup><sup>1</sup> ≡<sub>p</sub>
            p<sup>-</sup><sup>1</sup>
          </p>

          <hr />
          <p><strong>equality_is_maintained_by_inverse</strong></p>

          <p>
                f = p ⟹ f<sup>-</sup><sup>1</sup> = p<sup>-</sup><sup>1</sup>
          </p>

          <hr />
          <p><strong>refinement_safety_inverse</strong></p>

          <p>
                S f = S g ⟹ all_feasible [f, g] ⟹ f ⊑<sub>p</sub> g ⟹ (g<sup
              >-</sup
            ><sup>1</sup>) ⊑<sub>p</sub> (f<sup>-</sup><sup>1</sup>)
          </p>

          <hr />
          <p><strong>inverse_makes_feasible</strong></p>

          <p>    is_feasible (p<sup>-</sup><sup>1</sup>)</p>

          <hr />
          <h2 id="operation_interactionsthy">Operation_interactions.thy</h2>

          <p><strong>unsafe_compose_absorb</strong></p>

          <p>
                (p<sub>1</sub>;<sub>p</sub>p<sub>2</sub>)/<sub>p</sub>C =
            p<sub>1</sub>/<sub>p</sub>C;<sub>p</sub>p<sub>2</sub>
          </p>

          <hr />
          <p><strong>unsafe_compose_absorb_2</strong></p>

          <p>
                (p<sub>1</sub>;<sub>p</sub>p<sub>2</sub>)/<sub>p</sub>C =
            p<sub>1</sub>/<sub>p</sub>C;<sub>p</sub>p<sub>2</sub>
          </p>

          <hr />
          <p><strong>unsafe_compose_absorb_3</strong></p>

          <p>
                (p<sub>1</sub>;<sub>p</sub>p<sub>2</sub>)/<sub>p</sub>C ≡<sub
              >p</sub
            >
            p<sub>1</sub>/<sub>p</sub>C;<sub>p</sub>p<sub>2</sub>
          </p>

          <hr />
          <p><strong>range_p_unsafe_composition</strong></p>

          <p>
                Range_p(a) ∩ C = {} ⟹ a;<sub>p</sub>b/<sub>p</sub>(-C) ≡<sub
              >p</sub
            >
            a;<sub>p</sub>b
          </p>

          <hr />
          <p><strong>compose_absorb_1</strong></p>

          <p>
                (p<sub>1</sub>;p<sub>2</sub>)/<sub>p</sub>C =
            p<sub>1</sub>/<sub>p</sub>C;p<sub>2</sub>
          </p>

          <hr />
          <p><strong>compose_absorb_2</strong></p>

          <p>
                (p<sub>1</sub>;p<sub>2</sub>)/<sub>p</sub>C =
            p<sub>1</sub>/<sub>p</sub>C;p<sub>2</sub>
          </p>

          <hr />
          <p><strong>compose_absorb_3</strong></p>

          <p>
                (p<sub>1</sub>;p<sub>2</sub>)/<sub>p</sub>C ≡<sub>p</sub>
            p<sub>1</sub>/<sub>p</sub>C;p<sub>2</sub>
          </p>

          <hr />
          <p><strong>range_p_composition</strong></p>

          <p>
                Range_p(a) ∩ C = {} ⟹ a;b/<sub>p</sub>(-C) ≡<sub>p</sub> a;b
          </p>

          <hr />
          <p><strong>restrict_distrib_1</strong></p>

          <p>
                (p<sub>1</sub> ∪<sub>p</sub> p<sub>2</sub>)/<sub>p</sub>C =
            (p<sub>1</sub>/<sub>p</sub>C ∪<sub>p</sub>
            p<sub>2</sub>/<sub>p</sub>C)
          </p>

          <hr />
          <p><strong>restrict_distrib_2</strong></p>

          <p>
                (p<sub>1</sub> ∪<sub>p</sub> p<sub>2</sub>)/<sub>p</sub>C =
            (p<sub>1</sub>/<sub>p</sub>C ∪<sub>p</sub>
            p<sub>2</sub>/<sub>p</sub>C)
          </p>

          <hr />
          <p><strong>restrict_distrib_3</strong></p>

          <p>
                (p<sub>1</sub> ∪<sub>p</sub> p<sub>2</sub>)/<sub>p</sub>C ≡<sub
              >p</sub
            >
            (p<sub>1</sub>/<sub>p</sub>C ∪<sub>p</sub>
            p<sub>2</sub>/<sub>p</sub>C)
          </p>

          <hr />
          <p><strong>restrict_distrib_4</strong></p>

          <p>
                a ∪<sub>p</sub> (p<sub>1</sub> ∪<sub>p</sub>
            p<sub>2</sub>)/<sub>p</sub>C = a ∪<sub>p</sub>
            (p<sub>1</sub>/<sub>p</sub>C ∪<sub>p</sub>
            p<sub>2</sub>/<sub>p</sub>C)
          </p>

          <hr />
          <p><strong>restriction_absorbed_by_inverse_1</strong></p>

          <p>
                (p<sup>-</sup><sup>1</sup>)/<sub>p</sub>C =
            ((p∖<sub>p</sub>C)<sup>-</sup><sup>1</sup>)
          </p>

          <hr />
          <p><strong>restriction_absorbed_by_inverse_2</strong></p>

          <p>
                (p<sup>-</sup><sup>1</sup>)/<sub>p</sub>C =
            (p∖<sub>p</sub>C)<sup>-</sup><sup>1</sup>
          </p>

          <hr />
          <p><strong>restriction_absorbed_by_inverse_3</strong></p>

          <p>
                (p<sup>-</sup><sup>1</sup>)/<sub>p</sub>C ≡<sub>p</sub>
            (p∖<sub>p</sub>C)<sup>-</sup><sup>1</sup>
          </p>

          <hr />
          <p><strong>compose_distrib1_1</strong></p>

          <p>
                q;(p<sub>1</sub>∪<sub>p</sub>p<sub>2</sub>) = (q;p<sub>1</sub>)
            ∪<sub>p</sub> (q;p<sub>2</sub>)
          </p>

          <hr />
          <p><strong>compose_distrib1_2</strong></p>

          <p>
                q;(p<sub>1</sub>∪<sub>p</sub>p<sub>2</sub>) = (q;p<sub>1</sub>)
            ∪<sub>p</sub> (q;p<sub>2</sub>)
          </p>

          <hr />
          <p><strong>compose_distrib1_3</strong></p>

          <p>
                q;(p<sub>1</sub>∪<sub>p</sub>p<sub>2</sub>) ≡<sub>p</sub>
            (q;p<sub>1</sub>) ∪<sub>p</sub> (q;p<sub>2</sub>)
          </p>

          <hr />
          <p><strong>compose_distrib2_1</strong></p>

          <p>
                (p<sub>1</sub>∪<sub>p</sub>p<sub>2</sub>);q = (p<sub>1</sub>;q)
            ∪<sub>p</sub> (p<sub>2</sub>;q)
          </p>

          <hr />
          <p><strong>compose_distrib2_2</strong></p>

          <p>
                (p<sub>1</sub>∪<sub>p</sub>p<sub>2</sub>);q = (p<sub>1</sub>;q)
            ∪<sub>p</sub> (p<sub>2</sub>;q)
          </p>

          <hr />
          <p><strong>compose_distrib2_3</strong></p>

          <p>
                (p<sub>1</sub>∪<sub>p</sub>p<sub>2</sub>);q ≡<sub>p</sub>
            (p<sub>1</sub>;q) ∪<sub>p</sub> (p<sub>2</sub>;q)
          </p>

          <hr />
          <p><strong>choice_distributes_over_composition</strong></p>

          <p>
                q∪<sub>p</sub>(p<sub>1</sub>;p<sub>2</sub>) ≡<sub>p</sub>
            (q∪<sub>p</sub>p<sub>1</sub>) ; (q∪<sub>p</sub>p<sub>2</sub>)
          </p>

          <hr />
          <p><strong>corestriction_on_composition</strong></p>

          <p>
                p<sub>1</sub> ∖<sub>p</sub> s<sub>1</sub> ; p<sub>2</sub> =
            p<sub>1</sub> ; p<sub>2</sub> /<sub>p</sub> s<sub>1</sub>
          </p>

          <hr />
          <p><strong>corestrict_compose</strong></p>

          <p>
                (p<sub>1</sub> ; p<sub>2</sub>) ∖<sub>p</sub> C = p<sub>1</sub>
            ; (p<sub>2</sub> ∖<sub>p</sub> C)
          </p>

          <hr />
          <p><strong>unsafe_gets_safe_1</strong></p>

          <p>
                (p<sub>1</sub>;<sub>p</sub>p<sub>2</sub>);p<sub>3</sub> =
            (p<sub>1</sub>;p<sub>2</sub>);p<sub>3</sub>
          </p>

          <hr />
          <p><strong>unsafe_gets_safe_2</strong></p>

          <p>
                (p<sub>1</sub>;<sub>p</sub>p<sub>2</sub>);p<sub>3</sub> =
            (p<sub>1</sub>;p<sub>2</sub>);p<sub>3</sub>
          </p>

          <hr />
          <p><strong>unsafe_gets_safe_3</strong></p>

          <p>
                (p<sub>1</sub>;<sub>p</sub>p<sub>2</sub>);p<sub>3</sub> ≡<sub
              >p</sub
            >
            (p<sub>1</sub>;p<sub>2</sub>);p<sub>3</sub>
          </p>

          <hr />
          <p><strong>unsafe_gets_safe_extended</strong></p>

          <p>
                ((p<sub>1</sub>;<sub>p</sub>p<sub>2</sub>);<sub>p</sub>p<sub>3</sub>);p<sub
              >4</sub
            >
            ≡<sub>p</sub> ((p<sub>1</sub>;p<sub>2</sub>);p<sub>3</sub>);p<sub
              >4</sub
            >
          </p>

          <hr />
          <p><strong>equivalency_of_compositions_1</strong></p>

          <p>
                (p<sub>1</sub>∖<sub>p</sub>Pre p<sub>2</sub>);<sub>p</sub>p<sub
              >2</sub
            >
            = p<sub>1</sub>;p<sub>2</sub>
          </p>

          <hr />
          <p><strong>equivalency_of_compositions_2</strong></p>

          <p>
                (p<sub>1</sub>∖<sub>p</sub>Pre p<sub>2</sub>);<sub>p</sub>p<sub
              >2</sub
            >
            = p<sub>1</sub>;p<sub>2</sub>
          </p>

          <hr />
          <p><strong>equivalency_of_compositions_3</strong></p>

          <p>
                (p<sub>1</sub>∖<sub>p</sub>Pre p<sub>2</sub>);<sub>p</sub>p<sub
              >2</sub
            >
            ≡<sub>p</sub> p<sub>1</sub>;p<sub>2</sub>
          </p>

          <hr />
          <p><strong>composition_inverse_1</strong></p>

          <p>
                (p;q)<sup>-</sup><sup>1</sup> = (q<sup>-</sup
            ><sup>1</sup>);(p<sup>-</sup><sup>1</sup>)
          </p>

          <hr />
          <p><strong>composition_inverse_2</strong></p>

          <p>
                (p;q)<sup>-</sup><sup>1</sup> = (q<sup>-</sup
            ><sup>1</sup>);(p<sup>-</sup><sup>1</sup>)
          </p>

          <hr />
          <p><strong>composition_inverse_3</strong></p>

          <p>
                (p;q)<sup>-</sup><sup>1</sup> ≡<sub>p</sub> (q<sup>-</sup
            ><sup>1</sup>);(p<sup>-</sup><sup>1</sup>)
          </p>

          <hr />
          <p><strong>choice_inverse_1</strong></p>

          <p>
                (p ∪<sub>p</sub> q)<sup>-</sup><sup>1</sup> = (p<sup>-</sup
            ><sup>1</sup>) ∪<sub>p</sub> (q<sup>-</sup><sup>1</sup>)
          </p>

          <hr />
          <p><strong>choice_inverse_2</strong></p>

          <p>
                (p ∪<sub>p</sub> q)<sup>-</sup><sup>1</sup> = (p<sup>-</sup
            ><sup>1</sup>) ∪<sub>p</sub> (q<sup>-</sup><sup>1</sup>)
          </p>

          <hr />
          <p><strong>choice_inverse_3</strong></p>

          <p>
                (p ∪<sub>p</sub> q)<sup>-</sup><sup>1</sup> ≡<sub>p</sub> (p<sup
              >-</sup
            ><sup>1</sup>) ∪<sub>p</sub> (q<sup>-</sup><sup>1</sup>)
          </p>

          <hr />
          <p>
            <strong>corestriction_restriction_on_unsafe_composition_1</strong>
          </p>

          <p>
                p<sub>1</sub> ∖<sub>p</sub> s<sub>1</sub> ;<sub>p</sub> p<sub
              >2</sub
            >
            ≡<sub>p</sub> p<sub>1</sub> ;<sub>p</sub> p<sub>2</sub> /<sub
              >p</sub
            >
            s<sub>1</sub>
          </p>

          <hr />
          <p>
            <strong>corestrict_gets_absorbed_by_unsafe_composition_1</strong>
          </p>

          <p>
                (p<sub>1</sub> ;<sub>p</sub> p<sub>2</sub>) ∖<sub>p</sub> C
            ≡<sub>p</sub> (p<sub>1</sub> ∖<sub>p</sub> C) ;<sub>p</sub> p<sub
              >2</sub
            >
          </p>

          <hr />
          <p>
            <strong>corestrict_gets_absorbed_by_unsafe_composition_2</strong>
          </p>

          <p>
                (p<sub>1</sub> ;<sub>p</sub> p<sub>2</sub>) ∖<sub>p</sub> C
            ≡<sub>p</sub> p<sub>1</sub> ;<sub>p</sub> (p<sub>2</sub> ∖<sub
              >p</sub
            >
            C)
          </p>

          <hr />
          <p><strong>corestriction_on_unsafe_composition</strong></p>

          <p>
                p<sub>1</sub> ∖<sub>p</sub> s ;<sub>p</sub> p<sub>2</sub> =
            p<sub>1</sub> ;<sub>p</sub> p<sub>2</sub> /<sub>p</sub> s
          </p>

          <hr />
          <p><strong>corestrict_unsafe_compose</strong></p>

          <p>
                is_feasible p<sub>1</sub> ⟹ (p<sub>1</sub> ;<sub>p</sub>
            p<sub>2</sub>) ∖<sub>p</sub> C ≡<sub>p</sub> p<sub>1</sub> ;<sub
              >p</sub
            >
            (p<sub>2</sub> ∖<sub>p</sub> C)
          </p>

          <hr />
          <p><strong>corestriction_absorbed_by_inverse_1</strong></p>

          <p>
                (p<sup>-</sup><sup>1</sup>)∖<sub>p</sub>C =
            ((p/<sub>p</sub>C)<sup>-</sup><sup>1</sup>)
          </p>

          <hr />
          <p><strong>corestriction_absorbed_by_inverse_2</strong></p>

          <p>
                (p<sup>-</sup><sup>1</sup>)∖<sub>p</sub>C =
            ((p/<sub>p</sub>C)<sup>-</sup><sup>1</sup>)
          </p>

          <hr />
          <p><strong>corestriction_absorbed_by_inverse_3</strong></p>

          <p>
                (p<sup>-</sup><sup>1</sup>)∖<sub>p</sub>C ≡<sub>p</sub>
            (p/<sub>p</sub>C)<sup>-</sup><sup>1</sup>
          </p>

          <hr />
          <p><strong>unsafe_composition_inverse_1</strong></p>

          <p>
                (p;<sub>p</sub>q)<sup>-</sup><sup>1</sup> ≡<sub>p</sub> (q<sup
              >-</sup
            ><sup>1</sup>);<sub>p</sub>(p<sup>-</sup><sup>1</sup>)
          </p>

          <hr />
          <p><strong>corestrict_choice_1</strong></p>

          <p>
                (p<sub>1</sub> ∪<sub>p</sub> p<sub>2</sub>) ∖<sub>p</sub> C =
            (p<sub>1</sub> ∖<sub>p</sub> C) ∪<sub>p</sub> (p<sub>2</sub> ∖<sub
              >p</sub
            >
            C)
          </p>

          <hr />
          <p><strong>corestrict_choice_2</strong></p>

          <p>
                (p<sub>1</sub> ∪<sub>p</sub> p<sub>2</sub>) ∖<sub>p</sub> C =
            (p<sub>1</sub> ∖<sub>p</sub> C) ∪<sub>p</sub> (p<sub>2</sub> ∖<sub
              >p</sub
            >
            C)
          </p>

          <hr />
          <p><strong>corestrict_choice_3</strong></p>

          <p>
                (p<sub>1</sub> ∪<sub>p</sub> p<sub>2</sub>) ∖<sub>p</sub> C
            ≡<sub>p</sub> (p<sub>1</sub> ∖<sub>p</sub> C) ∪<sub>p</sub> (p<sub
              >2</sub
            >
            ∖<sub>p</sub> C)
          </p>

          <hr />
          <p><strong>unsafe_compose_distrib1_3_1</strong></p>

          <p>
                q;<sub>p</sub>(p<sub>1</sub>∪<sub>p</sub>p<sub>2</sub>) =
            (q;<sub>p</sub>p<sub>1</sub>) ∪<sub>p</sub>
            (q;<sub>p</sub>p<sub>2</sub>)
          </p>

          <hr />
          <p><strong>unsafe_compose_distrib1_3_2</strong></p>

          <p>
                q;<sub>p</sub>(p<sub>1</sub>∪<sub>p</sub>p<sub>2</sub>) =
            (q;<sub>p</sub>p<sub>1</sub>) ∪<sub>p</sub>
            (q;<sub>p</sub>p<sub>2</sub>)
          </p>

          <hr />
          <p><strong>unsafe_compose_distrib1_3_3</strong></p>

          <p>
                q;<sub>p</sub>(p<sub>1</sub>∪<sub>p</sub>p<sub>2</sub>) ≡<sub
              >p</sub
            >
            (q;<sub>p</sub>p<sub>1</sub>) ∪<sub>p</sub>
            (q;<sub>p</sub>p<sub>2</sub>)
          </p>

          <hr />
          <p><strong>unsafe_compose_distrib2_1</strong></p>

          <p>
                (p<sub>1</sub>∪<sub>p</sub>p<sub>2</sub>);<sub>p</sub>q =
            (p<sub>1</sub>;<sub>p</sub>q) ∪<sub>p</sub>
            (p<sub>2</sub>;<sub>p</sub>q)
          </p>

          <hr />
          <p><strong>unsafe_compose_distrib2_2</strong></p>

          <p>
                (p<sub>1</sub>∪<sub>p</sub>p<sub>2</sub>);<sub>p</sub>q =
            (p<sub>1</sub>;<sub>p</sub>q) ∪<sub>p</sub>
            (p<sub>2</sub>;<sub>p</sub>q)
          </p>

          <hr />
          <p><strong>unsafe_compose_distrib2_3</strong></p>

          <p>
                (p<sub>1</sub>∪<sub>p</sub>p<sub>2</sub>);<sub>p</sub>q ≡<sub
              >p</sub
            >
            (p<sub>1</sub>;<sub>p</sub>q) ∪<sub>p</sub>
            (p<sub>2</sub>;<sub>p</sub>q)
          </p>

          <hr />
          <p><strong>choice_distributes_over_composition_4</strong></p>

          <p>
                q∪<sub>p</sub>(p<sub>1</sub>;<sub>p</sub>p<sub>2</sub>) ≡<sub
              >p</sub
            >
            (q∪<sub>p</sub>p<sub>1</sub>) ;<sub>p</sub>
            (q∪<sub>p</sub>p<sub>2</sub>)
          </p>

          <hr />
          <p><strong>until_simplification_1</strong></p>

          <p>
                a;n∖<sub>p</sub>C ∪<sub>p</sub> a;m∖<sub>p</sub>C ≡<sub>p</sub>
            a;(n ∪<sub>p</sub> m)∖<sub>p</sub>C
          </p>

          <hr />
          <p><strong>until_simplification_2</strong></p>

          <p>
                a;<sub>p</sub>n∖<sub>p</sub>C ∪<sub>p</sub>
            a;<sub>p</sub>m∖<sub>p</sub>C ≡<sub>p</sub> a;<sub>p</sub>(n ∪<sub
              >p</sub
            >
            m)∖<sub>p</sub>C
          </p>

          <hr />
          <h2 id="primethy">Prime.thy</h2>

          <p><strong>finite_Field_implies_finite_relation</strong></p>

          <p>    finite (Field r) ⟹ finite r</p>

          <hr />
          <p>    finite (S p) ⟹ finite (Pre p)</p>

          <hr />
          <p><strong>finite_S_implies_finite_post</strong></p>

          <p>    finite (S p) ⟹ finite (post p)</p>

          <hr />
          <p><strong>post_cardinality_equals_P_cardinality</strong></p>

          <table>
            <tbody>
              <tr>
                <td>    P = {〈State={a,b}, Pre={a}, post={(a,b)}〉</td>
                <td>a b. (a,b) ∈ (post p)} ⟹ card (post p) = card P</td>
              </tr>
            </tbody>
          </table>

          <hr />
          <p><strong>same_card_and_finite_impl_finite</strong></p>

          <p>    card a = card b ⟹ finite a ⟹ card a &gt; 0 ⟹ finite b</p>

          <hr />
          <p><strong>fst_in_state</strong></p>

          <table>
            <tbody>
              <tr>
                <td>
                      is_feasible p ⟹ is_minimal p ⟹ P = {〈State={a,b},
                  Pre={a}, post={(a,b)}〉
                </td>
                <td>a b. (a,b) ∈ post p} ⟹ r ∈ post p ⟹ fst r ∈ State p</td>
              </tr>
            </tbody>
          </table>

          <hr />
          <p><strong>snd_is_state</strong></p>

          <table>
            <tbody>
              <tr>
                <td>
                      is_feasible p ⟹ is_minimal p ⟹ P = {〈State={a,b},
                  Pre={a}, post={(a,b)}〉
                </td>
                <td>a b. (a,b) ∈ post p} ⟹ r ∈ post p ⟹ snd r ∈ State p</td>
              </tr>
            </tbody>
          </table>

          <hr />
          <p>
                is_feasible p ⟹ is_minimal p ⟹ P = {〈State={a,b}, Pre={a},
            post={(a,b)}〉 | a b. (a,b) ∈ post p} ⟹ s ∈ State p ⟹ ∃r ∈ post p.
            fst r = s ∨ snd r = s
          </p>

          <hr />
          <p><strong>choice_set_decomp_1</strong></p>

          <p>
                finite F ⟹ ⋃<sub>P</sub> (insert x F) = ⋃<sub>P</sub> F ∪<sub
              >p</sub
            >
            x
          </p>

          <hr />
          <p><strong>choice_set_decomp_1</strong></p>

          <p>
                ⋃<sub>P</sub> (insert x F) = ⋃<sub>P</sub> F ∪<sub>p</sub> x
          </p>

          <hr />
          <p><strong>choice_set_equality</strong></p>

          <table>
            <tbody>
              <tr>
                <td>
                      finite (S p) ⟹ is_feasible p ⟹ is_minimal p ⟹ P =
                  {〈State={a,b}, Pre={a}, post={(a,b)}〉
                </td>
                <td>
                  a b. (a,b) ∈ post p} ⟹ p<sub>i</sub> ∈ P ⟹ ⋃<sub>P</sub> P = p
                </td>
              </tr>
            </tbody>
          </table>

          <hr />
          <p>
                finite (S p) ⟹ is_feasible p ⟹ is_minimal p ⟹ P =
            {〈State={a,b},Pre={a},post={(a,b)}〉 |a b . (a,b) ∈ (post p)} ⟹
            p<sub>i</sub> ∈ P ⟹ is_prime p<sub>i</sub> ∧ p<sub>i</sub> ⊆<sub
              >p</sub
            >
            p ∧ ⋃<sub>P</sub> P = p
          </p>

          <hr />
          <p>
                finite (S p) ⟹ is_feasible p ⟹ is_minimal p ⟹ ∃ P. p<sub>i</sub>
            ∈ P → is_prime p<sub>i</sub> ∧ p<sub>i</sub> ⊆<sub>p</sub> p ∧ ⋃<sub
              >P</sub
            >
            P = p
          </p>

          <hr />
          <h2 id="restrictionthy">Restriction.thy</h2>

          <p><strong>restrict_prop_1</strong></p>

          <p>    Pre (p /<sub>p</sub> D) ⊆ D</p>

          <hr />
          <p><strong>restrict_prop_2</strong></p>

          <p>    Pre (p /<sub>p</sub> D) ⊆ Pre p</p>

          <hr />
          <p><strong>restrict_prop</strong></p>

          <p>    Pre (p /<sub>p</sub> D) ⊆ Pre p ∩ D</p>

          <hr />
          <p><strong>restrict_idem</strong></p>

          <p>    (p /<sub>p</sub> C) /<sub>p</sub> C = p /<sub>p</sub> C</p>

          <hr />
          <p><strong>restrict_inter</strong></p>

          <p>
                (p/<sub>p</sub>C<sub>1</sub>)/<sub>p</sub>C<sub>2</sub> =
            p/<sub>p</sub>(C<sub>1</sub> ∩ C<sub>2</sub>)
          </p>

          <hr />
          <p><strong>restriction_equiv</strong></p>

          <p>
                f<sub>1</sub> ≡<sub>p</sub> p<sub>1</sub> ⟹ (f<sub>1</sub> /<sub
              >p</sub
            >
            C) ≡<sub>p</sub> p<sub>1</sub> /<sub>p</sub> C
          </p>

          <hr />
          <p><strong>equality_is_maintained_by_restriction</strong></p>

          <p>
                f<sub>1</sub> = p<sub>1</sub> ⟹ (f<sub>1</sub> /<sub>p</sub> C)
            = p<sub>1</sub> /<sub>p</sub> C
          </p>

          <hr />
          <p><strong>restrict_feasible</strong></p>

          <p>    is_feasible p ⟹ is_feasible (p /<sub>p</sub> C)</p>

          <hr />
          <p><strong>restrict_might_make_feasible</strong></p>

          <p>    C ⊆ Domain (post p) ⟹ is_feasible (p /<sub>p</sub> C)</p>

          <hr />
          <p><strong>restrict_refine_1</strong></p>

          <p>    strengthens p (p /<sub>p</sub> C)</p>

          <hr />
          <p><strong>restrict_refine_2</strong></p>

          <p>    strengthens (p /<sub>p</sub> C) p</p>

          <hr />
          <p><strong>restrict_refine_3</strong></p>

          <p>
                strengthens p q ⟹ strengthens (p /<sub>p</sub> C) (q /<sub
              >p</sub
            >
            C)
          </p>

          <hr />
          <p><strong>restrict_refine_4</strong></p>

          <p>    weakens p (p /<sub>p</sub> C)</p>

          <hr />
          <p><strong>restrict_refine_5</strong></p>

          <p>
                weakens p q ⟹ weakens (p /<sub>p</sub> C) (q /<sub>p</sub> C)
          </p>

          <hr />
          <p><strong>restrict_refine</strong></p>

          <p>    p ⊑<sub>p</sub> p /<sub>p</sub> C</p>

          <hr />
          <p><strong>restrict_refineorder1</strong></p>

          <p>    D ⊆ C ⟹ p /<sub>p</sub> C ⊑<sub>p</sub> p /<sub>p</sub> D</p>

          <hr />
          <p><strong>restriction_refsafety</strong></p>

          <p>
                q ⊑<sub>p</sub> p ⟹ q /<sub>p</sub> C ⊑<sub>p</sub> p /<sub
              >p</sub
            >
            C
          </p>

          <hr />
          <p><strong>restriction_subsafety</strong></p>

          <p>
                q ⊆<sub>p</sub> p ⟹ q /<sub>p</sub> C ⊆<sub>p</sub> p /<sub
              >p</sub
            >
            C
          </p>

          <hr />
          <p><strong>restriction_refsafety2</strong></p>

          <p>
                q ⊑<sub>p</sub> p ⟹ D ⊆ C ⟹ q /<sub>p</sub> C ⊑<sub>p</sub> p
            /<sub>p</sub> D
          </p>

          <hr />
          <p><strong>implements_safety_restriction</strong></p>

          <p>
                implements a b ⟹ implements (a /<sub>p</sub> C) (b /<sub>p</sub>
            C)
          </p>

          <hr />
          <p><strong>restrict_subprogorder1</strong></p>

          <p>    D ⊆ C ⟹ p /<sub>p</sub> D ⊆<sub>p</sub> p /<sub>p</sub> C</p>

          <hr />
          <p><strong>restrict_subprog</strong></p>

          <p>    p /<sub>p</sub> C ⊆<sub>p</sub> p</p>

          <hr />
          <h2 id="unsafe_compositionthy">Unsafe_composition.thy</h2>

          <p>
            <strong>equivalence_is_maintained_by_unsafe_composition</strong>
          </p>

          <p>
                f<sub>1</sub> ≡<sub>p</sub> p<sub>1</sub> ⟹ f<sub>2</sub> ≡<sub
              >p</sub
            >
            p<sub>2</sub> ⟹ f<sub>1</sub> ;<sub>p</sub> f<sub>2</sub> ≡<sub
              >p</sub
            >
            p<sub>1</sub> ;<sub>p</sub> p<sub>2</sub>
          </p>

          <hr />
          <p><strong>equality_is_maintained_by_unsafe_composition</strong></p>

          <p>
                f<sub>1</sub> = p<sub>1</sub> ⟹ f<sub>2</sub> = p<sub>2</sub> ⟹
            f<sub>1</sub> ;<sub>p</sub> f<sub>2</sub> = p<sub>1</sub> ;<sub
              >p</sub
            >
            p<sub>2</sub>
          </p>

          <hr />
          <p><strong>unsafe_compose_feasible_1</strong></p>

          <p>
                is_feasible (p<sub>1</sub> ;<sub>p</sub> p<sub>2</sub>) ⟹
            is_feasible p<sub>1</sub>
          </p>

          <hr />
          <p><strong>unsafe_compose_feasible_2</strong></p>

          <p>
                all_feasible [p<sub>1</sub>, p<sub>2</sub>] ⟹ Range_p p<sub
              >1</sub
            >
            ⊆ Pre p<sub>2</sub> ⟹ is_feasible (p<sub>1</sub> ;<sub>p</sub>
            p<sub>2</sub>)
          </p>

          <hr />
          <h2 id="unsafe_composition2thy">Unsafe_composition2.thy</h2>

          <p>
                Pre (p<sub>1</sub> ;<sup>p</sup> (p<sub>2</sub> ;<sup>p</sup>
            p<sub>3</sub>)) ⊆ Pre ((p<sub>1</sub> ;<sup>p</sup> p<sub>2</sub>)
            ;<sup>p</sup> p<sub>3</sub>)
          </p>

          <hr />
          <p>
                Pre ((p ;<sup>p</sup> q) ;<sup>p</sup> r) = Pre (p ;<sup>p</sup>
            (q ;<sup>p</sup> r))
          </p>

          <hr />
          <p>
            <strong>equivalence_is_maintained_by_unsafe_composition</strong>
          </p>

          <p>
                f<sub>1</sub> ≡<sub>p</sub> p<sub>1</sub> ⟹ f<sub>2</sub> ≡<sub
              >p</sub
            >
            p<sub>2</sub> ⟹ f<sub>1</sub> ;<sup>p</sup> f<sub>2</sub> ≡<sub
              >p</sub
            >
            p<sub>1</sub> ;<sup>p</sup> p<sub>2</sub>
          </p>

          <hr />
          <p><strong>unsafe_compose_feasible_1</strong></p>

          <p>
                is_feasible (p<sub>1</sub> ;<sup>p</sup> p<sub>2</sub>) ⟹
            is_feasible p<sub>1</sub>
          </p>

          <hr />
          <p><strong>unsafe_compose_feasible_2</strong></p>

          <p>
                all_feasible [p<sub>1</sub>, p<sub>2</sub>] ⟹ Range_p p<sub
              >1</sub
            >
            ⊆ Pre p<sub>2</sub> ⟹ is_feasible (p<sub>1</sub> ;<sup>p</sup>
            p<sub>2</sub>)
          </p>

          <hr />
          <h2 id="unsafe_composition3thy">Unsafe_composition3.thy</h2>

          <p>
            <strong>equivalence_is_maintained_by_unsafe_composition</strong>
          </p>

          <p>
                f<sub>1</sub> ≡<sub>p</sub> p<sub>1</sub> ⟹ f<sub>2</sub> ≡<sub
              >p</sub
            >
            p<sub>2</sub> ⟹ f<sub>1</sub> ;<sub>P</sub> f<sub>2</sub> ≡<sub
              >p</sub
            >
            p<sub>1</sub> ;<sub>P</sub> p<sub>2</sub>
          </p>

          <hr />
          <p><strong>equality_is_maintained_by_unsafe_composition</strong></p>

          <p>
                f<sub>1</sub> = p<sub>1</sub> ⟹ f<sub>2</sub> = p<sub>2</sub> ⟹
            f<sub>1</sub> ;<sub>P</sub> f<sub>2</sub> = p<sub>1</sub> ;<sub
              >P</sub
            >
            p<sub>2</sub>
          </p>

          <hr />
          <p><strong>unsafe_compose_feasible_1</strong></p>

          <p>
                is_feasible (p<sub>1</sub> ;<sub>P</sub> p<sub>2</sub>) ⟹
            is_feasible p<sub>1</sub>
          </p>

          <hr />
          <p><strong>unsafe_compose_feasible_2</strong></p>

          <p>
                all_feasible [p<sub>1</sub>, p<sub>2</sub>] ⟹ Range_p p<sub
              >1</sub
            >
            ⊆ Pre p<sub>2</sub> ⟹ is_feasible (p<sub>1</sub> ;<sub>P</sub>
            p<sub>2</sub>)
          </p>

          <hr />
          <h2 id="booleanthy">Boolean.thy</h2>

          <p><strong>restrict_true</strong></p>

          <p>    p /<sub>p</sub> (TRUE (S p)) = p</p>

          <hr />
          <p><strong>restrict_false</strong></p>

          <p>    p /<sub>p</sub> (FALSE) ≡<sub>p</sub> Fail (S p)</p>

          <hr />
          <p><strong>cond_false_1</strong></p>

          <p>    p /<sub>p</sub> FALSE ≡<sub>p</sub> Fail (S p)</p>

          <hr />
          <p><strong>corestrict_true</strong></p>

          <p>
                is_feasible p ⟹ p ∖<sub>p</sub> (TRUE (S p)) ≡<sub>p</sub> p
          </p>

          <hr />
          <p><strong>corestrict_false</strong></p>

          <p>    p ∖<sub>p</sub> FALSE = Fail (S p)</p>

          <hr />
          <p><strong>corestrict_false</strong></p>

          <p>    p ∖<sub>p</sub> FALSE ≡<sub>p</sub> Infeas (Pre p)</p>

          <hr />
          <p><strong>if_true</strong></p>

          <p>
                ITE (TRUE (S p<sub>1</sub> ∪ S p<sub>2</sub>)) p<sub>1</sub>
            p<sub>2</sub> ≡<sub>p</sub> p<sub>1</sub>
          </p>

          <hr />
          <p><strong>if_false1</strong></p>

          <p>
                ITE (FALSE) p<sub>1</sub> p<sub>2</sub> ≡<sub>p</sub> p<sub
              >2</sub
            >
          </p>

          <hr />
          <p><strong>true_selects_first_program_2</strong></p>

          <p>
                GC [(TRUE (S p<sub>1</sub> ∪ S p<sub>2</sub>), p<sub>1</sub>),
            (FALSE, p<sub>2</sub>)] ≡<sub>p</sub> p<sub>1</sub>
          </p>

          <hr />
          <p><strong>false_selects_second_program_2</strong></p>

          <p>
                GC [(FALSE, p<sub>1</sub>), ((TRUE (S p<sub>1</sub> ∪ S
            p<sub>2</sub>)), p<sub>2</sub>)] ≡<sub>p</sub> p<sub>2</sub>
          </p>

          <hr />
          <p><strong>restrict_false2</strong></p>

          <p>
                S p ⊆ S q ⟹ p /<sub>p</sub> FALSE ∪<sub>p</sub> q = Fail {}
            ∪<sub>p</sub> q
          </p>

          <hr />
          <p><strong>implies_prop</strong></p>

          <p>    (C →<sub>s</sub> D) = UNIV ≡ (C ⊆ D)</p>

          <hr />
          <p><strong>and_prop</strong></p>

          <p>    A ⊆ X ⟹ B ⊆ X ⟹ A ∧<sub>s</sub> B = TRUE X ≡ A = X ∧ B = X</p>

          <hr />
          <p><strong>or_prop</strong></p>

          <p>    TRUE X ⊆ (A ∨<sub>s</sub> B) ≡ ∀x∈X. x ∈ A ∨ x ∈ B</p>

          <hr />
          <h2 id="failthy">Fail.thy</h2>

          <p><strong>fail_is_valid</strong></p>

          <p>    is_valid (Fail s)</p>

          <hr />
          <p><strong>fail_is_feasible</strong></p>

          <p>    is_feasible (Fail s)</p>

          <hr />
          <p><strong>fail_is_total</strong></p>

          <p>    is_total (Fail s)</p>

          <hr />
          <p><strong>fail_is_idempondent_composition</strong></p>

          <p>    Fail C ; Fail C = Fail C</p>

          <hr />
          <p><strong>fail_is_idempondent_unsafe_composition</strong></p>

          <p>    Fail C ;<sub>p</sub> Fail C = Fail C</p>

          <hr />
          <p><strong>fail_equiv</strong></p>

          <p>    Fail C ≡<sub>p</sub> Fail D</p>

          <hr />
          <p><strong>no_pre_is_fail</strong></p>

          <p>    Pre p = {} ⟹ Fail s ≡<sub>p</sub> p</p>

          <hr />
          <p><strong>NOT_fail_choice_r</strong></p>

          <p>    p ∪<sub>p</sub> Fail (S p) = p</p>

          <hr />
          <p><strong>fail_choice_r</strong></p>

          <p>    p ∪<sub>p</sub> Fail C ≡<sub>p</sub> p</p>

          <hr />
          <p><strong>NOT_fail_choice_l</strong></p>

          <p>    Fail (S p) ∪<sub>p</sub> p = p</p>

          <hr />
          <p><strong>fail_choice_l</strong></p>

          <p>    Fail C ∪<sub>p</sub> p ≡<sub>p</sub> p</p>

          <hr />
          <p><strong>fail_compose_l_2</strong></p>

          <p>    Fail (S p) ; p = Fail (S p)</p>

          <hr />
          <p><strong>fail_compose_l</strong></p>

          <p>    Fail C ; p = Fail (C ∪ S p)</p>

          <hr />
          <p><strong>fail_compose_r_2</strong></p>

          <p>    p ; Fail C = Fail (C ∪ S p)</p>

          <hr />
          <p><strong>fail_compose_r</strong></p>

          <p>    p ; Fail C ≡<sub>p</sub> Fail C</p>

          <hr />
          <p><strong>only_fail_refines_fail</strong></p>

          <p>    (p ⊑<sub>p</sub> Fail (S p)) = (p ≡<sub>p</sub> Fail (S p))</p>

          <hr />
          <p><strong>refine_fail</strong></p>

          <p>    p ⊑<sub>p</sub> Fail (S p)</p>

          <hr />
          <p><strong>fail_refine_self</strong></p>

          <p>    (Fail (S p) ⊑<sub>p</sub> p) = (p ≡<sub>p</sub> Fail (S p))</p>

          <hr />
          <p><strong>fail_specialize_self</strong></p>

          <p>    (p ⊆<sub>p</sub> Fail (S p)) = (p ≡<sub>p</sub> Fail (S p))</p>

          <hr />
          <p><strong>range_of_fail</strong></p>

          <p>    Range_p (Fail C) = {}</p>

          <hr />
          <p><strong>choice_fail_implication</strong></p>

          <p>
                (a ∪<sub>p</sub> b ≡<sub>p</sub> Fail {}) = (a ≡<sub>p</sub>
            Fail {} ∧ b ≡<sub>p</sub> Fail {})
          </p>

          <hr />
          <p><strong>fail_refine</strong></p>

          <p>    C ⊆ S p ⟹ p ⊑<sub>p</sub> Fail C</p>

          <hr />
          <p>    C ⊆ S p ⟹ Fail C ⊆<sub>p</sub> p</p>

          <hr />
          <p><strong>fail_specialize2</strong></p>

          <p>    p ⊆<sub>p</sub> Fail (S p) ≡ p ≡<sub>p</sub> Fail {}</p>

          <hr />
          <p><strong>fail_refine2</strong></p>

          <p>    Fail (S p) ⊑<sub>p</sub> p ≡ p ≡<sub>p</sub> Fail {}</p>

          <hr />
          <p><strong>compose_empty_1</strong></p>

          <p>    S a = {} ⟹ b ; a = Fail (S b)</p>

          <hr />
          <p><strong>compose_empty_2</strong></p>

          <p>    S a = {} ⟹ a; b = Fail (S b)</p>

          <hr />
          <p><strong>fail_union_1</strong></p>

          <p>
                C ⊆ S p ⟹ Fail C ∪<sub>p</sub> (p ∪<sub>p</sub> q) = (p ∪<sub
              >p</sub
            >
            q)
          </p>

          <hr />
          <p><strong>fail_compose</strong></p>

          <p>    Fail (S p);p = Fail (S p)</p>

          <hr />
          <p><strong>fail_union_2</strong></p>

          <p>    C ⊆ S a ⟹ a ∪<sub>p</sub> Fail C = a ∪<sub>p</sub> Fail {}</p>

          <hr />
          <p><strong>fail_choice_decomp</strong></p>

          <p>
                p ∪<sub>p</sub> q ≡<sub>p</sub> Fail {} ≡ p ≡<sub>p</sub> Fail
            {} ∧ q ≡<sub>p</sub> Fail {}
          </p>

          <hr />
          <p><strong>fail_specialize</strong></p>

          <p>    C ⊆ S p ⟹ Fail C ⊆<sub>p</sub> p</p>

          <hr />
          <p><strong>fail_specialize3</strong></p>

          <p>    Fail {} ⊆<sub>p</sub> p</p>

          <hr />
          <h2 id="havocthy">Havoc.thy</h2>

          <p><strong>havoc_is_valid</strong></p>

          <p>    is_valid (Havoc s)</p>

          <hr />
          <p><strong>havoc_is_feasible</strong></p>

          <p>    is_feasible (Havoc s)</p>

          <hr />
          <p><strong>havoc_is_total</strong></p>

          <p>    is_total (Havoc s)</p>

          <hr />
          <p><strong>havoc_is_idempondent_composition</strong></p>

          <p>    Havoc C ; Havoc C = Havoc C</p>

          <hr />
          <p><strong>havoc_is_idempondent_unsafe_composition</strong></p>

          <p>    Havoc C ;<sub>p</sub> Havoc C = Havoc C</p>

          <hr />
          <p><strong>havoc_choice_l</strong></p>

          <p>    S p ⊆ C ⟹ Havoc C ∪<sub>p</sub> p = Havoc C</p>

          <hr />
          <p><strong>havoc_choice_r</strong></p>

          <p>    S p ⊆ C ⟹ p ∪<sub>p</sub> Havoc C = Havoc C</p>

          <hr />
          <p><strong>havoc_pre_State</strong></p>

          <p>
                State (p ; Havoc (S p)) = State (Havoc (S p) /<sub>p</sub> Pre
            p)
          </p>

          <hr />
          <p><strong>havoc_pre_S</strong></p>

          <p>    S p ⊆ C ⟹ S (p ; Havoc C) = S (Havoc C /<sub>p</sub> Pre p)</p>

          <hr />
          <p><strong>NOT_havoc_pre_Pre</strong></p>

          <p>
                Pre (p ; Havoc (S p)) = Pre (Havoc (S p) /<sub>p</sub> Pre p)
          </p>

          <hr />
          <p><strong>havoc_pre_Pre</strong></p>

          <p>
                S p ⊆ C ⟹is_feasible p ⟹ Pre (p ; Havoc C) = Pre (Havoc C /<sub
              >p</sub
            >
            Pre p)
          </p>

          <hr />
          <p><strong>NOT_havoc_pre_post_1</strong></p>

          <p>
                post (p ; Havoc (S p)) = post (Havoc (S p) /<sub>p</sub> Pre p)
          </p>

          <hr />
          <p><strong>NOT_havoc_pre_post_1</strong></p>

          <p>
                is_feasible p ⟹ post (p ; Havoc (S p)) = post (Havoc (S p) /<sub
              >p</sub
            >
            Pre p)
          </p>

          <hr />
          <p><strong>havoc_pre_post</strong></p>

          <p>
                S p ⊆ C ⟹is_feasible p ⟹ restr_post (p ; Havoc C)/<sub>r</sub>
            Pre p = restr_post (Havoc C /<sub>p</sub> Pre p)
          </p>

          <hr />
          <p><strong>NOT_havoc_pre</strong></p>

          <p>
                p ; Havoc (S p) ≡<sub>p</sub> Havoc (S p) /<sub>p</sub> Pre p
          </p>

          <hr />
          <p><strong>havoc_pre</strong></p>

          <p>
                S p ⊆ C ⟹is_feasible p ⟹ (p ; Havoc C) ≡<sub>p</sub> Havoc C
            /<sub>p</sub> Pre p
          </p>

          <hr />
          <p><strong>havoc_pre_unsafe</strong></p>

          <p>
                S p ⊆ C ⟹ (p ;<sub>p</sub> Havoc C) ≡<sub>p</sub> Havoc C /<sub
              >p</sub
            >
            Pre p
          </p>

          <hr />
          <p><strong>havoc_co_restricted</strong></p>

          <p>
                (Havoc C /<sub>p</sub> D) ∖<sub>p</sub> D ≡<sub>p</sub> Havoc (C
            ∩ D)
          </p>

          <hr />
          <p><strong>havoc_from_left_S</strong></p>

          <p>
                S p ⊆ C ⟹ is_feasible p ⟹ S (Havoc C ; p) = S(Havoc C ∖<sub
              >p</sub
            >
            Range_p (p))
          </p>

          <hr />
          <p><strong>havoc_from_left_Pre</strong></p>

          <p>
                S p ⊆ C ⟹ is_feasible p ⟹ ¬p ≡<sub>p</sub> Fail C ⟹ Pre (Havoc C
            ; p) = C
          </p>

          <hr />
          <p><strong>havoc_from_left_post</strong></p>

          <p>
                S p ⊆ C ⟹ is_feasible p ⟹ post (Havoc C ; p) = post (Havoc C
            ∖<sub>p</sub> Range_p (p))
          </p>

          <hr />
          <p><strong>havoc_from_left</strong></p>

          <p>
                S p ⊆ C ⟹ is_feasible p ⟹ ¬p ≡<sub>p</sub> Fail C ⟹ Havoc C ; p
            ≡<sub>p</sub> Havoc C ∖<sub>p</sub> Range_p p
          </p>

          <hr />
          <p><strong>refine_havoc</strong></p>

          <p>    p ⊑<sub>p</sub> Havoc (S p) /<sub>p</sub> Pre p</p>

          <hr />
          <p><strong>specialize_havoc</strong></p>

          <p>    p ⊆<sub>p</sub> Havoc (S p) /<sub>p</sub> Pre p</p>

          <hr />
          <p><strong>refine_havoc2</strong></p>

          <p>    is_total p ⟹ p ⊑<sub>p</sub> Havoc (S p)</p>

          <hr />
          <p><strong>specialize_havoc2</strong></p>

          <p>    S p ⊆ C ⟹ p ⊆<sub>p</sub> Havoc (C)</p>

          <hr />
          <h2 id="infeasthy">Infeas.thy</h2>

          <p><strong>infeas_is_valid</strong></p>

          <p>    is_valid (Infeas s)</p>

          <hr />
          <p><strong>infeas_is_feasible</strong></p>

          <p>    is_feasible (Infeas s)</p>

          <hr />
          <p><strong>infeas_is_total</strong></p>

          <p>    is_total (Infeas s)</p>

          <hr />
          <p><strong>infeas_is_idempondent_composition</strong></p>

          <p>    Infeas C ; Infeas C = Infeas C</p>

          <hr />
          <p><strong>infeas_is_idempondent_unsafe_composition</strong></p>

          <p>    Infeas C ;<sub>p</sub> Infeas C = Infeas C</p>

          <hr />
          <p><strong>fail_equiv</strong></p>

          <p>    Infeas C ≡<sub>p</sub> Infeas D</p>

          <hr />
          <p><strong>not_total_infeas_makes_infeasible</strong></p>

          <p>    ¬is_total p ⟹ ¬is_feasible (p ∪<sub>p</sub> Infeas (S p))</p>

          <hr />
          <p><strong>infeas_makes_total</strong></p>

          <p>    is_total (p ∪<sub>p</sub> Infeas (S p))</p>

          <hr />
          <p><strong>infeas_to_smaller_self</strong></p>

          <p>
                p ; Infeas (S p) ≡<sub>p</sub> Infeas (Pre p ∩ Domain (post p))
          </p>

          <hr />
          <p><strong>infeas_composition</strong></p>

          <p>    Infeas (S p) ; p = Fail (S p)</p>

          <hr />
          <p><strong>infeas_unsafe_composition_1</strong></p>

          <p>    Infeas (S p) ;<sub>p</sub> p = Infeas (S p)</p>

          <hr />
          <p><strong>infeas_unsafe_composition_2</strong></p>

          <p>    p ;<sub>p</sub> Infeas (S p) ≡<sub>p</sub> Infeas (Pre p)</p>

          <hr />
          <p><strong>infeas_restriction</strong></p>

          <p>    Infeas (C) /<sub>p</sub> D ≡<sub>p</sub> Infeas (C ∩ D)</p>

          <hr />
          <p><strong>infeas_corestriction</strong></p>

          <p>    Infeas (C) ∖<sub>p</sub> D = Fail (C)</p>

          <hr />
          <p><strong>infeas_corestriction2</strong></p>

          <p>    Infeas (C) ∖<sub>p</sub> D = Infeas (C)</p>

          <hr />
          <h2 id="skipthy">Skip.thy</h2>

          <p><strong>skip_is_valid</strong></p>

          <p>    is_valid (Skip s)</p>

          <hr />
          <p><strong>skip_is_feasible</strong></p>

          <p>    is_feasible (Skip s)</p>

          <hr />
          <p><strong>skip_is_total</strong></p>

          <p>    is_total (Skip s)</p>

          <hr />
          <p><strong>skip_is_idempondent_composition</strong></p>

          <p>    Skip C ; Skip C = Skip C</p>

          <hr />
          <p><strong>skip_is_idempondent_unsafe_composition</strong></p>

          <p>    Skip C ;<sub>p</sub> Skip C = Skip C</p>

          <hr />
          <p><strong>skip_unsafe_compose_r_1</strong></p>

          <p>    p ;<sub>p</sub> Skip (S p) = p</p>

          <hr />
          <p><strong>skip_compose_r_post</strong></p>

          <p>    post (p ; Skip (S p)) = post p</p>

          <hr />
          <p><strong>skip_compose_r_Pre_1</strong></p>

          <p>    Pre (p ; Skip (S p)) = (Pre p ∩ Domain (post p))</p>

          <hr />
          <p><strong>skip_compose_r_S</strong></p>

          <p>    S (p ; Skip (S p)) = S p</p>

          <hr />
          <p><strong>Skip_compleft</strong></p>

          <p>    is_feasible p ⟹ p ; Skip (S p) = p</p>

          <hr />
          <p>    is_feasible p ⟹ Skip (S p) ; p = p</p>

          <hr />
          <p><strong>skip_compose2</strong></p>

          <p>    is_feasible p ⟹ p ; Skip (S p) ≡<sub>p</sub> p</p>

          <hr />
          <p><strong>skip_compose_r_range2</strong></p>

          <p>    is_feasible p ⟹ p ; Skip (Range (post p)) = p</p>

          <hr />
          <p><strong>skip_compose_r_range</strong></p>

          <p>    is_feasible p ⟹ p ; Skip (Range_p p) ≡<sub>p</sub> p</p>

          <hr />
          <p><strong>skip_compose4</strong></p>

          <p>    is_feasible p ⟹ Skip (Pre p) ; p ≡<sub>p</sub> p</p>

          <hr />
          <p><strong>skip_compose_r_3</strong></p>

          <p>
                p ; Skip (S p) ≡<sub>p</sub> p /<sub>p</sub> Domain (post p)
          </p>

          <hr />
          <p><strong>skip_makes_feasible</strong></p>

          <p>    is_feasible (p ; Skip (S p))</p>

          <hr />
          <p><strong>skip_compose_l_S</strong></p>

          <p>    S (Skip (S p) ; p) = S p</p>

          <hr />
          <p><strong>skip_compose_l_Pre</strong></p>

          <p>    Pre (Skip (S p) ; p) = Pre p</p>

          <hr />
          <p><strong>skip_compose_l_post</strong></p>

          <p>    post (Skip (S p) ; p) = post p /<sub>r</sub> Pre p</p>

          <hr />
          <p><strong>skip_compose_l_1</strong></p>

          <p>
                Skip (S p) ; p = 〈 State = S p, Pre = Pre p, post = post p
            /<sub>r</sub> Pre p〉
          </p>

          <hr />
          <p><strong>skip_compose3</strong></p>

          <p>    Skip (S p) ; p ≡<sub>p</sub> p</p>

          <hr />
          <p><strong>skip_unsafe_compose_r_2</strong></p>

          <p>
                Skip (S p) ;<sub>p</sub> p = 〈State=S p, Pre=S p, post =
            restr_post p 〉
          </p>

          <hr />
          <p><strong>corestriction_prop</strong></p>

          <p>
                p ∖<sub>p</sub> C ≡<sub>p</sub> p ; (Skip (S p) /<sub>p</sub> C)
          </p>

          <hr />
          <p><strong>skip_prop</strong></p>

          <p>    Skip C ∪<sub>p</sub> Skip D ≡<sub>p</sub> Skip (C ∪ D)</p>

          <hr />
          <p><strong>skip_prop_2</strong></p>

          <p>
                Skip (S p) /<sub>p</sub> C ; p ≡<sub>p</sub> p /<sub>p</sub> C
          </p>

          <hr />
          <p>    Skip (C) ; p = p /<sub>p</sub> C</p>

          <hr />
          <p><strong>Skip_comprestrict</strong></p>

          <p>    Skip (C) ; p ≡<sub>p</sub> p /<sub>p</sub> C</p>

          <hr />
          <p><strong>skip_prop_4</strong></p>

          <p>    Skip D /<sub>p</sub> C ≡<sub>p</sub> Skip (D ∩ C)</p>

          <hr />
          <p><strong>skip_prop_5</strong></p>

          <p>    C ⊆ D ⟹ Skip D /<sub>p</sub> C ≡<sub>p</sub> Skip C</p>

          <hr />
          <p><strong>skip_prop_6</strong></p>

          <p>    S p ⊆ C ⟹ Skip C ; p ≡<sub>p</sub> p</p>

          <hr />
          <p><strong>corestrict_skip</strong></p>

          <p>    p ; Skip (C) ≡<sub>p</sub> p ∖<sub>p</sub> C</p>

          <hr />
          <p><strong>skip_prop_8</strong></p>

          <p>    Skip D ∖<sub>p</sub> C ≡<sub>p</sub> Skip (D ∩ C)</p>

          <hr />
          <p><strong>skip_prop_9</strong></p>

          <p>    S (Skip (C)) = C</p>

          <hr />
          <p><strong>skip_prop_10</strong></p>

          <p>    Skip x ∪<sub>p</sub> Skip y = Skip (x ∪ y)</p>

          <hr />
          <p><strong>skip_prop_11</strong></p>

          <p>    Skip {} ∪<sub>p</sub> p ≡<sub>p</sub> p</p>

          <hr />
          <p><strong>skip_prop_12</strong></p>

          <p>
                Skip {} ∪<sub>p</sub> (p ∪<sub>p</sub> q) = p ∪<sub>p</sub> q
          </p>

          <hr />
          <p><strong>skip_prop_13</strong></p>

          <p>    (a ; Skip (S a ∪ S b) ); b = a ; b</p>

          <hr />
          <p><strong>skip_prop_14</strong></p>

          <p>    (a ; Skip (S a) ); b = a ; b</p>

          <hr />
          <p><strong>skip_prop_15</strong></p>

          <p>    (a ; Skip (S b) ); b = a ; b</p>

          <hr />
          <p><strong>skip_prop_16</strong></p>

          <p>    S a ⊆ C ⟹ post ((a ; Skip C); b) = post (a ; b)</p>

          <hr />
          <p><strong>skip_prop_17</strong></p>

          <p>    S b ⊆ C ⟹ post ((a ; Skip C); b) = post (a ; b)</p>

          <hr />
          <p><strong>skip_prop_18</strong></p>

          <p>    S a ⊆ C ⟹ Skip C ; (a ; Skip C) = (Skip (S a); a) ; Skip C</p>

          <hr />
          <h2 id="arbitrary_repetitionthy">Arbitrary_repetition.thy</h2>

          <p><strong>loop_l1</strong></p>

          <p>    s=0 ⟹ f=0 ⟹ loop p s f = Skip (S p) /<sub>p</sub> (Pre p)</p>

          <hr />
          <p><strong>loop_l2</strong></p>

          <p>
                s=0 ⟹ f=1 ⟹ loop p s f = Skip (S p) /<sub>p</sub> (Pre p) ∪<sub
              >p</sub
            >
            (Skip (S p) /<sub>p</sub> (Pre p);p)
          </p>

          <hr />
          <p><strong>loop_l2_01</strong></p>

          <p>    loop p (f + 1) f = Fail (S p)</p>

          <hr />
          <p><strong>loop_l2_02</strong></p>

          <p>    loop p 0 f ; p = loop p (0 + 1) (f + 1)</p>

          <hr />
          <p><strong>loop_l2_03</strong></p>

          <p>    loop p s s ; p = loop p (s + 1) (s + 1)</p>

          <hr />
          <p><strong>loop_l2_04</strong></p>

          <p>    s&lt;f ⟹ loop p s f ; p = loop p (s + 1) (f + 1)</p>

          <hr />
          <p><strong>loop_l2_05</strong></p>

          <p>    0&lt;s ⟹ loop p s s = p<sup>s</sup> ∪<sub>p</sub> Fail {}</p>

          <hr />
          <p><strong>loop_l2_1</strong></p>

          <p>    s=f ⟹ loop p s f ≡<sub>p</sub> p<sup>s</sup></p>

          <hr />
          <p><strong>loop_l2_2</strong></p>

          <p>
                loop p s (s + 1) = p<sup>s</sup> ∪<sub>p</sub> p<sup>s + 1</sup>
          </p>

          <hr />
          <p><strong>loop_l3</strong></p>

          <p>
                s&lt;f ⟹ loop p s (f + 1) ≡<sub>p</sub> (p<sup>f + 1</sup>)
            ∪<sub>p</sub> (loop p s f)
          </p>

          <hr />
          <p><strong>loop_l4</strong></p>

          <p>
                s&lt;f ⟹ loop p s f ≡<sub>p</sub> (p<sup>s</sup>) ∪<sub>p</sub>
            (loop p (s + 1) f)
          </p>

          <hr />
          <p><strong>loop_l6</strong></p>

          <p>
                s=0 ⟹ s&lt;f ⟹ loop p s f ≡<sub>p</sub> (Skip (S p) /<sub
              >p</sub
            >
            (Pre p)) ∪<sub>p</sub> (loop p 1 f)
          </p>

          <hr />
          <p>
                0&lt;s ⟹ s&lt;f ⟹ loop p s f ≡<sub>p</sub> p<sup>s</sup> ∪<sub
              >p</sub
            >
            loop p (s + 1) f
          </p>

          <hr />
          <p><strong>loop_l5</strong></p>

          <p>
                s&lt;f ⟹ s &lt; k ⟹ k &lt; f ⟹ loop p s f ≡<sub>p</sub> (loop p
            s k) ∪<sub>p</sub> (loop p (k + 1) f)
          </p>

          <hr />
          <p><strong>loop_simplification</strong></p>

          <p>
                all_feasible [x,y] ⟹ Range_p x ∩ Pre y = {} ⟹ Range_p y ∩ Pre x
            = {} ⟹ (loop x s f) ∪<sub>p</sub> (loop y s f) ≡<sub>p</sub> loop (x
            ∪<sub>p</sub> y) s f
          </p>

          <hr />
          <p><strong>equiv_is_maintained_by_arbitrary_repetition_1</strong></p>

          <p>
                all_feasible [p<sub>1</sub>, p<sub>2</sub>] ⟹ p<sub>1</sub>
            ≡<sub>p</sub> p<sub>2</sub> ⟹ S p<sub>1</sub> = S p<sub>2</sub> ⟹
            loop p<sub>1</sub> s f ≡<sub>p</sub> loop p<sub>2</sub> s f
          </p>

          <hr />
          <p><strong>equiv_is_maintained_by_arbitrary_repetition_2</strong></p>

          <p>
                all_feasible [p<sub>1</sub>, p<sub>2</sub>] ⟹ p<sub>1</sub>
            ≡<sub>p</sub> p<sub>2</sub> ⟹ 0&lt;s ⟹ loop p<sub>1</sub> s f ≡<sub
              >p</sub
            >
            loop p<sub>2</sub> s f
          </p>

          <hr />
          <p><strong>arbitrary_rep_feasibility_l1</strong></p>

          <p>    s &gt; f ⟹ is_feasible p ⟹ is_feasible (loop p s f)</p>

          <hr />
          <p><strong>arbitrary_rep_feasibility_l2</strong></p>

          <p>    s &lt; f ⟹ is_feasible p ⟹ is_feasible (loop p s f)</p>

          <hr />
          <p><strong>arbitrary_rep_feasibility</strong></p>

          <p>    is_feasible p ⟹ is_feasible (loop p s f)</p>

          <hr />
          <p><strong>skip_compose_l_of_loop_1</strong></p>

          <p>
                s &lt; f ⟹ s=0 ⟹ loop p s f ≡<sub>p</sub> Skip (S p) /<sub
              >p</sub
            >
            (Pre p) ∪<sub>p</sub> loop p s f
          </p>

          <hr />
          <p><strong>skip_compose_r_of_loop_2</strong></p>

          <p>
                is_feasible p ⟹ loop p s f ≡<sub>p</sub> loop p s f ; Skip (S p)
          </p>

          <hr />
          <p><strong>skip_compose_l_of_loop_3</strong></p>

          <p>
                is_feasible p ⟹ loop p s f ≡<sub>p</sub> Skip (S p) ; loop p s f
          </p>

          <hr />
          <p><strong>range_fixed_rep</strong></p>

          <p>
                s&lt;m ⟹ m&lt;f ⟹ x ∉ Range_p (loop p s f) ⟹ x ∉ Range_p
            (p<sup>m</sup>)
          </p>

          <hr />
          <p><strong>pre_is_known_arbitrary_rep_1</strong></p>

          <p>
                ∀x y. x ∈ Pre a ∧ (x, y) ∈ post (a ; (b /<sub>p</sub> (-
            C))<sup>n</sup>) → x ∈ Pre (a ; (b /<sub>p</sub> (- C))<sup>n</sup>)
          </p>

          <hr />
          <p><strong>pre_is_known_arbitrary_rep_2</strong></p>

          <p>
                x ∈ Pre a ⟹ (x, y) ∈ post (a ; (b /<sub>p</sub> (-
            C))<sup>n</sup>) ⟹ x ∈ Pre (a ; (b /<sub>p</sub> (- C))<sup>n</sup>)
          </p>

          <hr />
          <p><strong>bad_index_is_fail_arbitrary</strong></p>

          <p>    f&lt;s ⟹ loop a s f ≡<sub>p</sub> Fail {}</p>

          <hr />
          <p><strong>fail_stays_fail_arbitrary</strong></p>

          <p>
                s&lt;f ⟹ loop p s f ≡<sub>p</sub> Fail {} ⟹ loop p s (f + 1)
            ≡<sub>p</sub> Fail {}
          </p>

          <hr />
          <p><strong>fail_stays_fail_arbitrary_2</strong></p>

          <p>
                s&lt;f ⟹ loop p s (f + 1) ≡<sub>p</sub> Fail {} ⟹ loop p s f
            ≡<sub>p</sub> Fail {}
          </p>

          <hr />
          <p><strong>fail_stays_fail_arbitrary_3</strong></p>

          <p>
                s&lt;f ⟹ loop p s (f + 1) ≡<sub>p</sub> Fail {} ≡ loop p s f
            ≡<sub>p</sub> Fail {}
          </p>

          <hr />
          <p><strong>fail_stays_fail_arbitrary_4</strong></p>

          <p>
                s&lt;f ⟹ loop p s s ≡<sub>p</sub> Fail {} ≡ loop p s f ≡<sub
              >p</sub
            >
            Fail {}
          </p>

          <hr />
          <p><strong>fail_arbitrary_implies_fixed</strong></p>

          <p>
                k &lt; n ⟹ loop (b /<sub>p</sub> (- C)) 0 n ≡<sub>p</sub> Fail
            {} ⟹ (b /<sub>p</sub> (- C)) <sup> </sup>k ≡<sub>p</sub> Fail {}
          </p>

          <hr />
          <p><strong>extract_fixed_from_arbitrary</strong></p>

          <p>
                k&lt;n ⟹ a ; loop (b /<sub>p</sub> (- C)) 0 n ∖<sub>p</sub> C
            ≡<sub>p</sub> a ; loop (b /<sub>p</sub> (- C)) 0 n ∖<sub>p</sub> C
            ∪<sub>p</sub> a ; ((b /<sub>p</sub> (- C)) <sup> </sup>k) ∖<sub
              >p</sub
            >
            C
          </p>

          <hr />
          <p><strong>fail_arbitrary_implies_fixed_2</strong></p>

          <p>
                k &lt; n ⟹ a ; loop (b /<sub>p</sub> (- C)) 0 n ∖<sub>p</sub> C
            ≡<sub>p</sub> Fail {} ⟹ a ; ((b /<sub>p</sub> (- C)) <sup> </sup>k)
            ∖<sub>p</sub> C ≡<sub>p</sub> Fail {}
          </p>

          <hr />
          <p>    Fail (S x) ∪<sub>p</sub> x <sup> </sup>0 = x <sup> </sup>0</p>

          <hr />
          <p><strong>fixed_prop</strong></p>

          <p>
                0&lt;f ⟹ Fail (S x) ∪<sub>p</sub> x <sup> </sup>f = x
            <sup> </sup>f
          </p>

          <hr />
          <p><strong>loop_choice3</strong></p>

          <p>
                0&lt;s ⟹ 0&lt;f ⟹ all_feasible [x,y] ⟹ Range_p x ∩ Pre y = {} ⟹
            Range_p y ∩ Pre x = {} ⟹ (loop x s f) ∪<sub>p</sub> (loop y s f) =
            loop (x ∪<sub>p</sub> y) s f
          </p>

          <hr />
          <p><strong>Loop_fail</strong></p>

          <p>
                loop p 0 n ≡<sub>p</sub> Fail {} ⟹ loop p 0 m ≡<sub>p</sub>
            Fail{}
          </p>

          <hr />
          <h2 id="atomic_concurrencythy">Atomic_concurrency.thy</h2>

          <p>
                foldl (f::’a Program ⇒ ‘a Program ⇒ ‘a Program) (f a x) xs = f a
            (foldl f x xs)
          </p>

          <hr />
          <p><strong>complete_state_subset_fold_composition</strong></p>

          <p>
                x ∈ complete_state xs ⟹ x ∈ S (foldl (;) (Skip (complete_state
            xs)) xs)
          </p>

          <hr />
          <p><strong>fold_choice_inv_1</strong></p>

          <p>
                foldl (∪<sub>p</sub>) (Fail {}) (a # xs) = a ∪<sub>p</sub> foldl
            (∪<sub>p</sub>) (Fail {}) (xs)
          </p>

          <hr />
          <p><strong>fold_choice_inv_2</strong></p>

          <p>
                S (foldl (∪<sub>p</sub>) (Fail {}) xs ) = ⋃ (set (map (S) xs))
          </p>

          <hr />
          <p><strong>conc_elems_state</strong></p>

          <p>    x ∈ set (conc_elems xs) ⟹ S x = complete_state xs</p>

          <hr />
          <p><strong>atomic_conc_complete_state</strong></p>

          <p>    S (atomic_conc xs) = complete_state xs</p>

          <hr />
          <p><strong>atomic_conc_equivalence</strong></p>

          <p>    xs ≠ [ ] ⟹ S (Concat xs C) = S (atomic_conc xs)</p>

          <hr />
          <p><strong>pre_zero</strong></p>

          <p>    Pre (atomic_conc [ ]) = {}</p>

          <hr />
          <p><strong>pre_one</strong></p>

          <p>    is_feasible x ⟹ Pre (atomic_conc [x]) = Pre x</p>

          <hr />
          <p><strong>lemma_pre_1</strong></p>

          <p>    Pre (atomic_conc (a#[b])) ⊆ Pre a ∪ Pre b</p>

          <hr />
          <p><strong>list_equiv_reflexive</strong></p>

          <p>    list_equiv xs xs</p>

          <hr />
          <p><strong>list_equiv_comp_equiv</strong></p>

          <p>
                list_equiv xs ys ⟹ b ≡<sub>p</sub> b’ ⟹ fold (;) xs b ≡<sub
              >p</sub
            >
            fold (;) ys b’
          </p>

          <hr />
          <p><strong>skip_prop_1</strong></p>

          <p>    is_feasible a ⟹ S a ⊆ C ⟹ a ; Skip C ≡<sub>p</sub> a</p>

          <hr />
          <p><strong>skip_prop_2</strong></p>

          <p>
                is_feasible a ⟹a ; Skip (complete_state (a # xs)) ≡<sub>p</sub>
            a
          </p>

          <hr />
          <p><strong>skip_restrict</strong></p>

          <p>
                is_feasible a ⟹ fold (;) xs (a ; Skip (complete_state (a # xs)))
            ≡<sub>p</sub> fold (;) xs a
          </p>

          <hr />
          <p><strong>feas_of_prop</strong></p>

          <p>    is_feasible (feas_of p)</p>

          <hr />
          <p><strong>feas_of_prop2</strong></p>

          <p>    is_feasible p ⟹ feas_of p = p</p>

          <hr />
          <p><strong>skip_prop_4</strong></p>

          <p>    a ; Skip (S a) ≡<sub>p</sub> feas_of a</p>

          <hr />
          <p><strong>skip_prop_5</strong></p>

          <p>
                fold (;) xs (Skip (complete_state (a # xs)) ; a) ≡<sub>p</sub>
            fold (;) xs a
          </p>

          <hr />
          <p><strong>get_trace</strong></p>

          <p>
                xs ≠ [ ] ⟹ x ∈ set (conc_elems xs) ⟹ ∃tr. tr ∈ set (permutations
            xs) ∧ x = Concat tr C
          </p>

          <hr />
          <p><strong>skip_prop_6</strong></p>

          <p>    Skip (S p ∪ x) ; p ≡<sub>p</sub> Skip (S p) ; p</p>

          <hr />
          <p><strong>no_right_neutral</strong></p>

          <p>    ∃t. p;t ≡<sub>p</sub> p</p>

          <hr />
          <p><strong>corestrict_skip</strong></p>

          <p>    (a; Skip (S a ∪ S b)) ; b ≡<sub>p</sub> a ; b</p>

          <hr />
          <p><strong>skip_prop_8</strong></p>

          <p>    (a; Skip (S a)) ; b ≡<sub>p</sub> a ; b</p>

          <hr />
          <p><strong>skip_prop_9</strong></p>

          <p>    (a; Skip (S b)) ; b ≡<sub>p</sub> a ; b</p>

          <hr />
          <p><strong>fold_decomp</strong></p>

          <p>
                xs ≠ [ ] ⟹ (foldl (;) (a) (xs)) ≡<sub>p</sub> a; (foldl (;)
            (Skip (complete_state xs)) (xs))
          </p>

          <hr />
          <p><strong>fold_decomp2</strong></p>

          <p>
                xs ≠ [ ] ⟹ (foldl (;) (a) (xs)) ≡<sub>p</sub> a; (foldl (;)
            (Skip (S a)) (xs))
          </p>

          <hr />
          <p><strong>fold_equiv_maintained</strong></p>

          <p>
                a ≡<sub>p</sub> b ⟹ foldl (;) a xs ≡<sub>p</sub> foldl (;) b xs
          </p>

          <hr />
          <p><strong>fold_compress_1</strong></p>

          <p>
                ys ≠ [ ] ⟹ ∃e’. (a);e’ ≡<sub>p</sub> (foldl (;) (Skip
            (complete_state ([a]@ys))) ([a]@ys))
          </p>

          <hr />
          <p><strong>fold_compress_2</strong></p>

          <p>
                ∃e’. e’;a ≡<sub>p</sub> (foldl (;) (Skip (complete_state
            (ys@[a]))) (ys@[a]))
          </p>

          <hr />
          <p><strong>fold_compress_3</strong></p>

          <p>
                ∃s’ e’. (s’;a);e’ ≡<sub>p</sub> (foldl (;) (Skip (complete_state
            (xs@[a]@ys))) (xs@[a]@ys)) ∨ s’;a=(foldl (;) (Skip (complete_state
            (xs@[a]@ys))) (xs@[a]@ys))
          </p>

          <hr />
          <p><strong>conc_elems_dec</strong></p>

          <p>
                x ∈ set (conc_elems (a # xs)) ⟹ ∃s’ e’. (s’;a);e’ = x ∨ s’;a=x ∨
            a = x∨ a;e’ = x
          </p>

          <hr />
          <p><strong>concat_prop_1</strong></p>

          <p>
                xs ≠ [ ] ⟹ tr ∈ set (permutations xs) ⟹ Concat tr
            (complete_state xs) ∈ set (conc_elems xs)
          </p>

          <hr />
          <p><strong>fold_choice_inv</strong></p>

          <p>
                t ∈ set (xs) ⟹ foldl (∪<sub>p</sub>) (x) (xs) = t ∪<sub>p</sub>
            (foldl (∪<sub>p</sub>) (x) (xs))
          </p>

          <hr />
          <p><strong>atomic_conc_inv</strong></p>

          <p>
                tr ∈ set (conc_elems xs) ⟹ tr ∪<sub>p</sub> atomic_conc xs ≡<sub
              >p</sub
            >
            atomic_conc xs
          </p>

          <hr />
          <p><strong>atomic_conc_inv2</strong></p>

          <p>    x ∈ set (conc_elems xs) ⟹ x ⊆<sub>p</sub> atomic_conc xs</p>

          <hr />
          <p><strong>atomic_conc_inv3</strong></p>

          <p>
                xs ≠ [ ] ⟹ Concat xs (complete_state xs) ⊆<sub>p</sub>
            atomic_conc xs
          </p>

          <hr />
          <p><strong>perm_prop</strong></p>

          <p>    set (permutations (a@b)) = set (permutations (b@a))</p>

          <hr />
          <p><strong>perm_prop2</strong></p>

          <p>
                x ∈ set (permutations y) ⟹ set (conc_elems (y)) = set
            (conc_elems (x))
          </p>

          <hr />
          <p><strong>perm_prop3</strong></p>

          <p>    set (conc_elems (a@b)) = set (conc_elems (b@a))</p>

          <hr />
          <p><strong>perm_prop4</strong></p>

          <p>    size (insert_all x xs) = size xs + 1</p>

          <hr />
          <p><strong>perm_prop5</strong></p>

          <p>    size (concat [ ]) = 0</p>

          <hr />
          <p><strong>perm_prop6</strong></p>

          <p>    size (concat (x#xs)) = size x + size (concat (xs))</p>

          <hr />
          <p><strong>perm_prop7</strong></p>

          <p>    size (concat xs) = foldl (λa b. a + (size b)) 0 xs</p>

          <hr />
          <p><strong>perm_prop8</strong></p>

          <p>
                a ∈ set (map (insert_all x) (permutations xs)) ⟹ b ∈ set a ⟹
            size b = size xs + 1
          </p>

          <hr />
          <p><strong>perm_prop9</strong></p>

          <p>
                a ∈ set (map (insert_all x) (permutations xs)) ⟹ size a = size
            xs + 1
          </p>

          <hr />
          <p><strong>size_concat</strong></p>

          <p>    size (concat xss) = sum_list (map size xss)</p>

          <hr />
          <p><strong>insert_all_prop</strong></p>

          <p>
                size (concat (map (insert_all x) xss)) = sum_list (map (λy. Suc
            (size y)) xss)
          </p>

          <hr />
          <p>
                x ∈ set (permutations xs) ⟹ y ∈ set (permutations xs) ⟹ size x =
            size y
          </p>

          <hr />
          <p><strong>sum_list_simp</strong></p>

          <p>
                (∀x ∈ set xss. ∀ y ∈ set xss. size x = size y) ⟹ sum_list (map
            size xss) = size xss * size (hd xss)
          </p>

          <hr />
          <p><strong>size_lemma</strong></p>

          <p>    ∀x ∈ set xs. size x = n ⟹ size (concat xs) = size xs * n</p>

          <hr />
          <p><strong>length_concat_insert_all</strong></p>

          <p>
                length (concat (map (insert_all x) (permutations xs))) = (length
            xs + 1) * length (permutations xs)
          </p>

          <hr />
          <p><strong>size_permutations_fact</strong></p>

          <p>    length (permutations xs) = fact (length xs)</p>

          <hr />
          <p><strong>perm_size_eq</strong></p>

          <p>
                size xs = size ys ⟹ size (permutations xs) = size (permutations
            ys)
          </p>

          <hr />
          <p><strong>perm_prop10</strong></p>

          <p>
                size (permutations (x#xs)) = size (permutations (xs)) * size
            (x#xs)
          </p>

          <hr />
          <p><strong>fold_choice_prop1</strong></p>

          <p>
                permutations a = permutations b ⟹ set (conc_elems a) = set
            (conc_elems b)
          </p>

          <hr />
          <p>    size xs &gt; 0⟹ size (conc_elems xs) &gt; 0</p>

          <hr />
          <p><strong>fold_choice_prop2</strong></p>

          <p>
                a ∈ set xs ⟹ foldl (∪<sub>p</sub>) a xs = foldl (∪<sub>p</sub>)
            (Skip {}) xs
          </p>

          <hr />
          <p><strong>fold_choice_prop3</strong></p>

          <p>
                a ∈ set (conc_elems (xs)) ⟹ foldl (∪<sub>p</sub>) (a)
            (conc_elems (xs)) = foldl (∪<sub>p</sub>) (Skip {}) (conc_elems
            (xs))
          </p>

          <hr />
          <p><strong>fold_choice_prop5</strong></p>

          <p>
                foldl (∪<sub>p</sub>) x (x’#xs) = foldl (∪<sub>p</sub>) (Fail
            {}) (x#x’#xs)
          </p>

          <hr />
          <p><strong>atomic_prop2</strong></p>

          <p>
                xs ≠ [ ] ⟹ ys ∈ set (permutations xs) ⟹ Concat ys
            (complete_state xs) ⊆<sub>p</sub> atomic_conc xs
          </p>

          <hr />
          <p><strong>atomic_prop3</strong></p>

          <p>    atomic_conc [a,b] ≡<sub>p</sub> a ; b ∪<sub>p</sub> b ; a</p>

          <hr />
          <p><strong>equiv_to_equal</strong></p>

          <p>    S a = S b ⟹ post a = post b ⟹ a ≡<sub>p</sub> b ⟹ a = b</p>

          <hr />
          <p><strong>atomic_prop4</strong></p>

          <p>
                atomic_conc [a, b ∪<sub>p</sub> c] ≡<sub>p</sub> atomic_conc
            [a,b] ∪<sub>p</sub> atomic_conc [a,c]
          </p>

          <hr />
          <p><strong>atomic_prop5</strong></p>

          <p>
                atomic_conc [a ∪<sub>p</sub> b] = atomic_conc [a] ∪<sub>p</sub>
            atomic_conc [b]
          </p>

          <hr />
          <p><strong>set_to_list_set</strong></p>

          <p>    finite xs ⟹ set (set_to_list xs) = xs</p>

          <hr />
          <p><strong>specialize_prop</strong></p>

          <p>    a = b ⟹ b ⊆<sub>p</sub> a ∧ a ⊆<sub>p</sub> b</p>

          <hr />
          <p><strong>atomic_prop6</strong></p>

          <p>
                atomic_conc [a ∪<sub>p</sub> b, c] ≡<sub>p</sub> atomic_conc
            [a,c] ∪<sub>p</sub> atomic_conc [b,c]
          </p>

          <hr />
          <p><strong>commute_compose</strong></p>

          <p>
                commute_programs3 a b ⟹ atomic_conc [a,b] ≡<sub>p</sub> a ; b
          </p>

          <hr />
          <h2 id="big_choicethy">Big_choice.thy</h2>

          <p><strong>fold_compose</strong></p>

          <p>    foldl (;) (a ; b) xs = a ; (foldl (;) b xs)</p>

          <hr />
          <p><strong>fold_choice</strong></p>

          <p>
                foldl (∪<sub>p</sub>) (a ∪<sub>p</sub> b) xs = a ∪<sub>p</sub>
            (foldl (∪<sub>p</sub>) b xs)
          </p>

          <hr />
          <p><strong>Choice_prop_1_2</strong></p>

          <p>
                xs ≠ [ ] ⟹ ⋃<sub>p</sub> (x#xs) = x ∪<sub>p</sub> ⋃<sub>p</sub>
            xs
          </p>

          <hr />
          <p><strong>Choice_prop_1_3</strong></p>

          <p>
                a@b ≠ [ ] ⟹ ⋃<sub>p</sub> (a@x#b) = x ∪<sub>p</sub> ⋃<sub
              >p</sub
            >
            (a@b)
          </p>

          <hr />
          <p><strong>Choice_prop_1_1</strong></p>

          <p>
                ys ∈ set (permutations xs) ⟹ ⋃<sub>p</sub> xs = ⋃<sub>p</sub> ys
          </p>

          <hr />
          <p><strong>Choice_prop_1</strong></p>

          <p>
                xs ≠ [ ] ⟹ ⋃<sub>p</sub> (xs@[x]) = x ∪<sub>p</sub> ⋃<sub
              >p</sub
            >
            xs
          </p>

          <hr />
          <p><strong>Choice_prop_1_4</strong></p>

          <p>
                xs ≠ [ ] ⟹ foldl (∪<sub>p</sub>) x xs = x ∪<sub>p</sub> Choice
            xs
          </p>

          <hr />
          <p><strong>Choice_prop_2</strong></p>

          <p>
                ⋃<sub>p</sub> [a;t. t ← xs] ≡<sub>p</sub> a;⋃<sub>p</sub> [t. t
            ← xs]
          </p>

          <hr />
          <p><strong>Choice_prop_3</strong></p>

          <p>
                xs ≠ [ ] ⟹ ⋃<sub>p</sub> (xs@[x]) = ⋃<sub>p</sub> (xs) ∪<sub
              >p</sub
            >
            x
          </p>

          <hr />
          <p><strong>Choice_prop_4</strong></p>

          <p>
                ⋃<sub>p</sub> [t;a. t ← xs] ≡<sub>p</sub> ⋃<sub>p</sub> [t. t ←
            xs];a
          </p>

          <hr />
          <p><strong>Choice_state</strong></p>

          <table>
            <tbody>
              <tr>
                <td>    S (⋃<sub>p</sub> (xs)) = ⋃ {S x</td>
                <td>x . x ∈ set xs}</td>
              </tr>
            </tbody>
          </table>

          <hr />
          <p><strong>Union_prop_1</strong></p>

          <table>
            <tbody>
              <tr>
                <td>    xs ≠ {} ⟹ ⋃ {t</td>
                <td>x . x ∈ xs} = t</td>
              </tr>
            </tbody>
          </table>

          <hr />
          <p><strong>Choice_prop_5</strong></p>

          <p>    size xs = 1 ⟹ set (xs) = {x} ⟹ (⋃<sub>p</sub> xs = x)</p>

          <hr />
          <p><strong>Choice_prop_6</strong></p>

          <p>
                size xs &gt; 1 ⟹ set (xs) = {x} ⟹ (⋃<sub>p</sub> xs = x ∪<sub
              >p</sub
            >
            x)
          </p>

          <hr />
          <p><strong>Choice_prop_7</strong></p>

          <p>
                a ≠ [ ] ⟹ b ≠ [ ] ⟹ ⋃<sub>p</sub> a ∪<sub>p</sub> ⋃<sub>p</sub>
            b = ⋃<sub>p</sub> (a@b)
          </p>

          <hr />
          <p><strong>Choice_prop_8</strong></p>

          <p>
                ∃x ∈ set xs. p x ⟹ ∃x ∈ set xs. ¬p x ⟹ ⋃<sub>p</sub> (filter
            (λx. p x) xs) ∪<sub>p</sub> ⋃<sub>p</sub> (filter (λx. ¬p x) xs) =
            ⋃<sub>p</sub> xs
          </p>

          <hr />
          <p><strong>Choice_prop_9</strong></p>

          <p>
                size xs&gt;1 ⟹ size ys&gt;1 ⟹ set xs = set ys ⟹ ⋃<sub>p</sub>
            (xs) = ⋃<sub>p</sub> (ys)
          </p>

          <hr />
          <p><strong>Choice_prop_10</strong></p>

          <p>
                size xs=1 ⟹ size ys=1 ⟹ set xs = set ys ⟹ ⋃<sub>p</sub> (xs) =
            ⋃<sub>p</sub> (ys)
          </p>

          <hr />
          <p><strong>Choice_prop11</strong></p>

          <p>
                size xs &gt; 1 ⟹ ⋃<sub>p</sub> (filter (λt. P t) xs) ∪<sub
              >p</sub
            >
            ⋃<sub>p</sub> (filter (λt. ¬P t) xs) = ⋃<sub>p</sub> xs
          </p>

          <hr />
          <p><strong>Choice_prop12</strong></p>

          <p>
                x ∈ set xs ⟹ ⋃<sub>p</sub> (filter ((=) x) (x#xs)) = x ∪<sub
              >p</sub
            >
            x
          </p>

          <hr />
          <p><strong>Choice_state_1</strong></p>

          <p>    complete_state xs = S (Choice xs)</p>

          <hr />
          <p><strong>Concat_prop_1</strong></p>

          <p>    xs ≠ [ ] ⟹ foldl (;) x xs = x ; Concat xs s</p>

          <hr />
          <p><strong>Concat_state</strong></p>

          <p>    xs ≠ [ ] ⟹ complete_state xs = S (Concat xs s)</p>

          <hr />
          <p><strong>Choice_prop_13</strong></p>

          <p>
                size xs &gt; 0 ⟹ ⋃<sub>p</sub> [a;(Concat t s). t ← xs] ≡<sub
              >p</sub
            >
            a;⋃<sub>p</sub> [(Concat t s). t ← xs]
          </p>

          <hr />
          <p><strong>Choice_prop_14</strong></p>

          <p>
                ⋃<sub>p</sub> [t /<sub>p</sub> C . t ← xs] ≡<sub>p</sub> ⋃<sub
              >p</sub
            >
            [t . t ← xs]/<sub>p</sub> C
          </p>

          <hr />
          <p>
                ⋃<sub>p</sub> [t /<sub>p</sub> C . t ← xs] = ⋃<sub>p</sub> [t .
            t ← xs]/<sub>p</sub> C
          </p>

          <hr />
          <p><strong>Choice_prop_15</strong></p>

          <p>
                ⋃<sub>p</sub> [t ∖<sub>p</sub> C . t ← xs] = ⋃<sub>p</sub> [t .
            t ← xs]∖<sub>p</sub> C
          </p>

          <hr />
          <p><strong>Concat_prop_2</strong></p>

          <p>    xs ≠ [ ] ⟹ Concat (xs@[x]) s = Concat xs s ; x</p>

          <hr />
          <p><strong>Concat_prop_3</strong></p>

          <p>
                xs ≠ [ ] ⟹ Concat xs s /<sub>p</sub> C ≡<sub>p</sub> Concat (hd
            xs /<sub>p</sub> C # tl xs) s
          </p>

          <hr />
          <p><strong>Concat_prop_4</strong></p>

          <p>
                xs ≠ [ ] ⟹ Concat xs s ∖<sub>p</sub> C ≡<sub>p</sub> Concat
            (butlast xs @ [(last xs)∖<sub>p</sub> C]) s
          </p>

          <hr />
          <p><strong>Choice_prop_16</strong></p>

          <p>
                x ∈ set xs ⟹ ⋃<sub>p</sub> xs ≡<sub>p</sub> ⋃<sub>p</sub> xs
            ∪<sub>p</sub> x
          </p>

          <hr />
          <p><strong>Choice_prop_17</strong></p>

          <p>
                size xs &gt; 1 ⟹ x ∈ set xs ⟹ ⋃<sub>p</sub> xs = ⋃<sub>p</sub>
            xs ∪<sub>p</sub> x
          </p>

          <hr />
          <p><strong>Concat_prop_5</strong></p>

          <p>
                xs ≠ [ ] ⟹ ys ≠ [ ] ⟹ Concat (xs@ys) s = Concat xs s ; Concat ys
            s
          </p>

          <hr />
          <p><strong>Concat_prop_6</strong></p>

          <p>
                Concat (a ∪<sub>p</sub> b # xs) s = Concat (a # xs) s ∪<sub
              >p</sub
            >
            Concat (b # xs) s
          </p>

          <hr />
          <p><strong>Concat_prop_7</strong></p>

          <p>
                Concat (xs@[a ∪<sub>p</sub> b]) s ≡<sub>p</sub> Concat (xs@[a])
            s ∪<sub>p</sub> Concat (xs@[b]) s
          </p>

          <hr />
          <p><strong>Concat_prop_8</strong></p>

          <p>
                e ≠ [ ] ⟹ Concat (s@(a ∪<sub>p</sub> b)#e) s’ ≡<sub>p</sub>
            Concat (s@a#e) s’ ∪<sub>p</sub> Concat (s@b#e) s’
          </p>

          <hr />
          <p><strong>Choice_prop_18</strong></p>

          <p>
                size b &gt; 1 ⟹ ⋃<sub>p</sub> b = ⋃<sub>p</sub> b ∪<sub>p</sub>
            Fail {}
          </p>

          <hr />
          <p><strong>Choice_prop_19</strong></p>

          <p>
                size (a@b) &gt; 1 ⟹ ⋃<sub>p</sub> a ∪<sub>p</sub> ⋃<sub>p</sub>
            b = ⋃<sub>p</sub> (a@b)
          </p>

          <hr />
          <p><strong>Choice_prop_20</strong></p>

          <p>
                size (a@b) &gt; 0 ⟹ ⋃<sub>p</sub> a ∪<sub>p</sub> (x ∪<sub
              >p</sub
            >
            ⋃<sub>p</sub> b) = ⋃<sub>p</sub> (a@x#b)
          </p>

          <hr />
          <p><strong>Choice_prop_21</strong></p>

          <p>
                S x ⊆ complete_state (a@b) ⟹ ⋃<sub>p</sub> a ∪<sub>p</sub> (x
            /<sub>p</sub> FALSE ∪<sub>p</sub> ⋃<sub>p</sub> b) = ⋃<sub>p</sub> a
            ∪<sub>p</sub> (Fail {} ∪<sub>p</sub> ⋃<sub>p</sub> b)
          </p>

          <hr />
          <p><strong>list_prop</strong></p>

          <p>
                1 &lt; i ⟹ i &lt; n ⟹ [p . t ← [1 .. int n]] = [p . t ← [1 ..
            int i]] @ [p . t ← [int (i + 1) .. int n]]
          </p>

          <hr />
          <p><strong>list_prop2</strong></p>

          <p>    [p . t ← [1 .. int (n + 1)]] = [p . t ← [1 .. int n]]@[p]</p>

          <hr />
          <p><strong>list_prop3</strong></p>

          <p>    size x = size y ⟹ [p. t ← x] = [p. t ← y]</p>

          <hr />
          <p><strong>list_prop4</strong></p>

          <p>    [p . t ← [1 .. int (n + 1)]] = p#[p . t ← [1 .. int n]]</p>

          <hr />
          <p><strong>Concat_prop_9</strong></p>

          <p>
                0&lt;n ⟹ Concat [p . t ← [1 .. int n]] s ; p = Concat [p . t ←
            [1 .. int (n + 1)]] s
          </p>

          <hr />
          <p><strong>Concat_prop_10</strong></p>

          <p>    xs ≠ [ ] ⟹ Concat (x#xs) s = x ; Concat xs s</p>

          <hr />
          <p><strong>Concat_prop_11</strong></p>

          <p>
                0&lt;n ⟹ p ; Concat [p . t ← [1 .. int n]] s = Concat [p . t ←
            [1 .. int (n + 1)]] s
          </p>

          <hr />
          <p><strong>Choice_prop_22</strong></p>

          <p>
                a ∪<sub>p</sub> ⋃<sub>p</sub> (x#xs) = a ∪<sub>p</sub> (x ∪<sub
              >p</sub
            >
            ⋃<sub>p</sub> xs)
          </p>

          <hr />
          <p><strong>Choice_prop_23</strong></p>

          <p>
                ∀x ∈ set xs. x = y ⟹ ⋃<sub>p</sub> xs = Fail {} ∨ ⋃<sub>p</sub>
            xs = y ∨ ⋃<sub>p</sub> xs = y ∪<sub>p</sub> y
          </p>

          <hr />
          <p><strong>Choice_prop_24</strong></p>

          <p>
                distinct xs ⟹ distinct ys ⟹ set xs = set ys ⟹ size xs = size ys
            ⟹ ⋃<sub>p</sub> xs = ⋃<sub>p</sub> ys
          </p>

          <hr />
          <p><strong>atomic_prop_1</strong></p>

          <p>
                finite F ⟹ ∀x ∈ F. is_atomic x ⟹ get_atomic (⋃<sub>p</sub>
            (set_to_list F)) = F
          </p>

          <hr />
          <p><strong>decomp_programs</strong></p>

          <p>
                Pre a = Pre p - {y} ⟹ post b = {t. t ∈ post p ∧ (fst t=y ∨ snd
            t=y)} ⟹ Pre b = Pre p ∩ ({y} ∪ Domain (post p ∖<sub>r</sub> {y})) ⟹
            post a = {t. t ∈ post p ∧ (fst t ≠ y ∧ snd t ≠ y)} ⟹ a ∪<sub>p</sub>
            b ≡<sub>p</sub> p
          </p>

          <hr />
          <p>
                is_feasible p ⟹ finite (S p) ⟹ ∃xs. ⋃<sub>p</sub> xs ≡<sub
              >p</sub
            >
            p ∧ (∀x ∈ set xs. is_atomic x)
          </p>

          <hr />
          <p><strong>civilized_finite</strong></p>

          <p>    civilized_n x B n ⟹ finite B</p>

          <hr />
          <p><strong>civilized_ind</strong></p>

          <p>    civilized_n x B n ⟹ civilized_n x B (n + 1)</p>

          <hr />
          <p><strong>civilized_ind2</strong></p>

          <p>    ⋀m. n&lt;m ⟹ civilized_n x B n ⟹ civilized_n x B m</p>

          <hr />
          <p><strong>civilized_generic</strong></p>

          <p>
                civilized_n x B n = ((∃a b m m’. m&lt;n ∧ m’&lt;n ∧ civilized_n
            a B m ∧ civilized_n b B m’ ∧ (a ; b = x ∨ a ∪<sub>p</sub> b = x)) ∧
            finite B) ∨ civilized_n x B 0
          </p>

          <hr />
          <p><strong>civ_prop_1</strong></p>

          <p>    civilized_n p B n ⟹ civilized p B</p>

          <hr />
          <p><strong>civ_prop_2</strong></p>

          <p>    civilized p B ⟹ civilized q B ⟹ civilized (p;q) B</p>

          <hr />
          <p><strong>civ_prop_3</strong></p>

          <p>
                civilized p B ⟹ civilized q B ⟹ civilized (p ∪<sub>p</sub> q) B
          </p>

          <hr />
          <p><strong>fold_prop</strong></p>

          <p>    foldl (∪) {} xs = {} ⟹ t ∈ set xs ⟹ t = {}</p>

          <hr />
          <p><strong>fold_prop2</strong></p>

          <p>    x ∈ tr ⟹ tr ∈ set xs ⟹ foldl (∪) {} xs ⊆ B ⟹ x ∈ B</p>

          <hr />
          <p><strong>normal_prop1</strong></p>

          <p>    set x ⊆ {p} ⟹ ∃n. x = replicate n p</p>

          <hr />
          <p><strong>basic_normal</strong></p>

          <p>    basic a = basic b ⟹ normal_of a B = normal_of b B</p>

          <hr />
          <p><strong>basic_normal2</strong></p>

          <p>
                basic a = insert (Fail {}) (basic b) ⟹ normal_of a B = normal_of
            b B
          </p>

          <hr />
          <p><strong>normal_prop2</strong></p>

          <p>    finite B ⟹ normal_of [[ ]] B</p>

          <hr />
          <p><strong>normal_prop3</strong></p>

          <p>
                finite B ⟹ normal_of [[〈State = {}, Pre = {}, post = {}〉]] B
          </p>

          <hr />
          <p><strong>normal_prop4</strong></p>

          <p>    infinite B ⟹ ¬normal_of xs B</p>

          <hr />
          <p><strong>normal_prop5</strong></p>

          <p>    finite B ⟹ normal_of xs B ⟹ normal_of ([ ]#xs) B</p>

          <hr />
          <p><strong>normal_prop6</strong></p>

          <p>    finite B ⟹ normal_of ([ ]#xs) B ⟹ normal_of xs B</p>

          <hr />
          <p><strong>normal_prop7</strong></p>

          <p>    normal_of [x#xs] B = (normal_of [[x]] B ∧ normal_of [xs] B)</p>

          <hr />
          <p><strong>basic_prop0</strong></p>

          <p>    basic [[x]] ∪ basic [xs] = basic [x#xs]</p>

          <hr />
          <p><strong>basic_prop1</strong></p>

          <p>    basic [x] ∪ basic xs = basic (x#xs)</p>

          <hr />
          <p><strong>basic_prop2</strong></p>

          <p>    basic xs ∪ basic ys = basic (xs@ys)</p>

          <hr />
          <p><strong>normal_prop8</strong></p>

          <p>    trace ∈ set xs ⟹ normal_of xs B ⟹ normal_of [trace] B</p>

          <hr />
          <p><strong>normal_prop9</strong></p>

          <p>    normal_of ((a # x) # xs) B ⟹ normal_of [[a]] B</p>

          <hr />
          <p><strong>basic_prop3</strong></p>

          <p>    trace ∈ set xs ⟹ basic [trace] ⊆ basic xs</p>

          <hr />
          <p><strong>basic_prop4</strong></p>

          <p>    x ∈ set trace ⟹ basic [[x]] ⊆ basic [trace]</p>

          <hr />
          <p><strong>normal_prop10</strong></p>

          <p>
                x ∈ set trace ⟹ trace ∈ set xs ⟹ normal_of xs B ⟹ normal_of
            [[x]] B
          </p>

          <hr />
          <p><strong>normal_prop11</strong></p>

          <p>
                normal_of ((a#x)#xs) B = (normal_of [[a]] B ∧ normal_of (x#xs)
            B)
          </p>

          <hr />
          <p><strong>normal_prop12</strong></p>

          <p>    normal_of (x#xs) B = (normal_of [x] B ∧ normal_of xs B)</p>

          <hr />
          <p><strong>normal_prop13</strong></p>

          <p>
                normal_of (a#p) B = normal_of ((〈State = {}, Pre = {}, post =
            {}〉#Skip (complete_state (set_to_list B))#a)#p) B
          </p>

          <hr />
          <p><strong>fold_prop1</strong></p>

          <p>
                trace ∈ set p ⟹ x ∈ set trace ⟹ x ∈ foldl (∪) {} (map set p)
          </p>

          <hr />
          <p><strong>normal_prop14</strong></p>

          <p>
                normal_of p B ⟹ trace ∈ set p ⟹ x ∈ set trace ⟹ x ∈ {Fail {},
            Skip (complete_state (set_to_list B))} ∪ B
          </p>

          <hr />
          <p><strong>basic_monotone1</strong></p>

          <p>    basic a ⊆ basic (x#a)</p>

          <hr />
          <p><strong>basic_monotone2</strong></p>

          <p>    x ∈ set p ⟹ basic [x] ⊆ basic p</p>

          <hr />
          <p><strong>basic_decomp1</strong></p>

          <p>    basic [x] ∪ basic xs = basic (x#xs)</p>

          <hr />
          <p><strong>basic_decomp2</strong></p>

          <p>    basic [x] ∪ basic xs = basic (xs@[x])</p>

          <hr />
          <p><strong>fold_prop3</strong></p>

          <p>
                foldl (∪) (foldl (∪) {} xs) ys = foldl (∪) {} xs ∪ foldl (∪) {}
            ys
          </p>

          <hr />
          <p><strong>basic_decomp</strong></p>

          <p>    basic a ∪ basic b = basic (a@b)</p>

          <hr />
          <p><strong>basic_monotone</strong></p>

          <p>    set a ⊆ set b ⟹ basic a ⊆ basic b</p>

          <hr />
          <p><strong>basic_prop</strong></p>

          <p>    basic (a@b) ⊆ B ⟹ basic b ⊆ B</p>

          <hr />
          <p><strong>basic_prop5</strong></p>

          <p>    basic (a@b) ⊆ B ⟹ basic a ⊆ B</p>

          <hr />
          <p><strong>basic_monotone3</strong></p>

          <p>    basic [a] ⊆ basic [a@b]</p>

          <hr />
          <p><strong>basic_monotone4</strong></p>

          <p>    basic [b] ⊆ basic [a@b]</p>

          <hr />
          <p><strong>basic_monotone5</strong></p>

          <p>    basic [b] ∪ basic [a] = basic [a@b]</p>

          <hr />
          <p><strong>civilized_empty2</strong></p>

          <p>    finite B ⟹ civilized_n (⋃<sub>p</sub> [ ]) B 0</p>

          <hr />
          <p><strong>civilized_empty3</strong></p>

          <p>    finite B ⟹ civilized_n (Fail {}) B 0</p>

          <hr />
          <p><strong>civilized_empty4</strong></p>

          <p>    finite B ⟹ civilized_n (Skip {}) B 0</p>

          <hr />
          <p><strong>normal_civilized</strong></p>

          <p>
                normal_of p B ⟹ civilized (evaluate p (complete_state
            (set_to_list B))) B
          </p>

          <hr />
          <p><strong>concat_prop1</strong></p>

          <p>    evaluate ([ ] ;<sub>c</sub> b) c = Fail {}</p>

          <hr />
          <p><strong>concat_prop2</strong></p>

          <p>    evaluate [ ] c = Fail {}</p>

          <hr />
          <p><strong>concat_prop3</strong></p>

          <p>
                xs ≠ [ ] ⟹ evaluate (x#xs) c = evaluate [x] c ∪<sub>p</sub>
            evaluate xs c
          </p>

          <hr />
          <p><strong>concat_prop4</strong></p>

          <p>
                complete_cnf_state (x#xs) ⊆ c ⟹ xs ≠ [ ] ⟹ evaluate (x#xs) c =
            evaluate [x] c ∪<sub>p</sub> evaluate xs c
          </p>

          <hr />
          <p><strong>concat_prop4_1</strong></p>

          <p>
                evaluate (x#xs) c ≡<sub>p</sub> evaluate [x] c ∪<sub>p</sub>
            evaluate xs c
          </p>

          <hr />
          <p><strong>fail_compose</strong></p>

          <p>    Fail {} ; p ≡<sub>p</sub> Fail {}</p>

          <hr />
          <p><strong>concat_prop5</strong></p>

          <p>
                evaluate (a@b) c ≡<sub>p</sub> evaluate a c ∪<sub>p</sub>
            evaluate b c
          </p>

          <hr />
          <p><strong>Skip_concat</strong></p>

          <p>
                Skip (complete_state a) ; Concat a (complete_state a) ≡<sub
              >p</sub
            >
            Concat a (complete_state a)
          </p>

          <hr />
          <p><strong>concat_prop</strong></p>

          <p>
                a ≠ [ ] ⟹ Concat a (insert x (complete_state a)) ≡<sub>p</sub>
            Concat a (complete_state a)
          </p>

          <hr />
          <p><strong>state_prop1</strong></p>

          <p>
                S (evaluate xs C) ∪ S (evaluate [x] C) = S (evaluate (x#xs) C)
          </p>

          <hr />
          <p><strong>state_prop2</strong></p>

          <p>
                S (evaluate xs C) ∪ S (evaluate ys C) = S (evaluate (ys@xs) C)
          </p>

          <hr />
          <p><strong>eval_prop</strong></p>

          <p>    [ ] ∉ set xs ⟹ evaluate xs C = evaluate xs D</p>

          <hr />
          <p><strong>state_prop3</strong></p>

          <p>
                [ ] ∈ set xs ⟹ complete_cnf_state (xs) ⊆ S (evaluate (xs)
            (complete_cnf_state (xx#xs)))
          </p>

          <hr />
          <p><strong>state_prop4</strong></p>

          <p>
                [ ] ∉ set xs ⟹ complete_cnf_state (xs) ⊆ S (evaluate (xs)
            (complete_cnf_state (xx#xs)))
          </p>

          <hr />
          <p><strong>state_prop5</strong></p>

          <p>
                complete_cnf_state (xs) ⊆ S (evaluate (xs) (complete_cnf_state
            (xx#xs)))
          </p>

          <hr />
          <p><strong>state_prop6</strong></p>

          <p>
                S (evaluate xs (complete_cnf_state xs)) = complete_cnf_state xs
          </p>

          <hr />
          <p><strong>skip_prop2</strong></p>

          <p>
                Skip (complete_cnf_state xs) ; evaluate (xs) (complete_cnf_state
            xs) ≡<sub>p</sub> evaluate (xs) (complete_cnf_state xs)
          </p>

          <hr />
          <p><strong>concat_prop6</strong></p>

          <p>
                evaluate ([ ]#xs) (complete_cnf_state xs) ≡<sub>p</sub> Skip
            (complete_cnf_state xs) ∪<sub>p</sub> evaluate xs
            (complete_cnf_state xs)
          </p>

          <hr />
          <p><strong>non_empty0</strong></p>

          <p>    non_empty (non_empty xs) = non_empty xs</p>

          <hr />
          <p><strong>non_empty1</strong></p>

          <p>    non_empty [ ] = [ ]</p>

          <hr />
          <p><strong>non_empty2</strong></p>

          <p>    non_empty [[ ]] = [ ]</p>

          <hr />
          <p><strong>cnf_choice1</strong></p>

          <p>    [ ] ∪<sub>c</sub> p = non_empty p</p>

          <hr />
          <p><strong>cnf_choice1</strong></p>

          <p>    [ ] ∪<sub>c</sub> p = p</p>

          <hr />
          <p><strong>non_empty3</strong></p>

          <p>    non_empty ([ ]#xs) = non_empty xs</p>

          <hr />
          <p><strong>non_empty4</strong></p>

          <p>    non_empty (a@b) = non_empty a @ non_empty b</p>

          <hr />
          <p><strong>cnf_choice2</strong></p>

          <p>    non_empty (x#xs) = [x] ∪<sub>c</sub> xs</p>

          <hr />
          <p><strong>cnf_choice2</strong></p>

          <p>    (x#xs) = [x] ∪<sub>c</sub> xs</p>

          <hr />
          <p><strong>cnf_choice3</strong></p>

          <p>    ys ∪<sub>c</sub> (x#xs) = (ys@[x]) ∪<sub>c</sub> xs</p>

          <hr />
          <p><strong>non_empty5</strong></p>

          <p>    non_empty ((xx # x) # b) = (xx#x) # (non_empty b)</p>

          <hr />
          <p><strong>non_empty6</strong></p>

          <p>
                non_empty ((xx # x) # b) = [xx#x] ∪<sub>c</sub> (non_empty b)
          </p>

          <hr />
          <p><strong>non_empty6</strong></p>

          <p>    ((xx # x) # b) = [xx#x] ∪<sub>c</sub> b</p>

          <hr />
          <p><strong>non_empty7</strong></p>

          <p>    ((x#xs)@(y#ys)) = (x#xs) ∪<sub>c</sub> (y#ys)</p>

          <hr />
          <p><strong>non_empty7</strong></p>

          <p>    non_empty ((x#xs)@(y#ys)) = (x#xs) ∪<sub>c</sub> (y#ys)</p>

          <hr />
          <p><strong>non_empty8</strong></p>

          <p>
                a ∪<sub>c</sub> b ≠ [[ ]] ⟹ a ∪<sub>c</sub> b = (non_empty a)
            ∪<sub>c</sub> (non_empty b)
          </p>

          <hr />
          <p>    evaluate (non_empty a) = evaluate a</p>

          <hr />
          <p><strong>cnf_choice_4</strong></p>

          <p>
                evaluate (a ∪<sub>c</sub> b) = evaluate (non_empty a ∪<sub
              >c</sub
            >
            non_empty b)
          </p>

          <hr />
          <p><strong>state_prop7</strong></p>

          <p>    S (evaluate [y] (complete_state y)) = complete_state y</p>

          <hr />
          <p><strong>skip_prop</strong></p>

          <p>    S x ⊆ C ⟹ is_feasible x ⟹x ; Skip C ≡<sub>p</sub> x</p>

          <hr />
          <p><strong>concat_prop8</strong></p>

          <p>
                complete_state y ⊆ C ⟹ evaluate [[ ]] C ; evaluate [y] C ≡<sub
              >p</sub
            >
            evaluate ([[ ]] ;<sub>c</sub> [y]) C
          </p>

          <hr />
          <p><strong>concat_prop9</strong></p>

          <p>    x ≠ [ ] ⟹ y ≠ [ ] ⟹ [x] ;<sub>c</sub> [y] = [x@y]</p>

          <hr />
          <p><strong>concat_prop10</strong></p>

          <p>
                complete_state (x#xs) ⊆ C ⟹ all_feasible (x#xs) ⟹ evaluate [[x]]
            C ; evaluate [xs] C ≡<sub>p</sub> evaluate ([[x]] ;<sub>c</sub>
            [xs]) C
          </p>

          <hr />
          <p><strong>feas_prop1</strong></p>

          <p>    all_feasible (x @ y) ⟹ all_feasible x</p>

          <hr />
          <p><strong>feas_prop2</strong></p>

          <p>    all_feasible (x @ y) ⟹ all_feasible y</p>

          <hr />
          <p><strong>concat_prop11</strong></p>

          <p>
                all_feasible (x@y) ⟹ complete_state (x@y) ⊆ C ⟹ evaluate [x] C ;
            evaluate [y] C ≡<sub>p</sub> evaluate ([x] ;<sub>c</sub> [y]) C
          </p>

          <hr />
          <p><strong>concat_prop11_1</strong></p>

          <p>
                all_feasible (x@y) ⟹ evaluate [x] (complete_state (x@y)) ;
            evaluate [y] (complete_state (x@y)) ≡<sub>p</sub> evaluate ([x]
            ;<sub>c</sub> [y]) (complete_state (x@y))
          </p>

          <hr />
          <p><strong>concat_prop12</strong></p>

          <p>
                all_feasible (a#x@y) ⟹ (complete_state (a#x@y)) ⊆ C ⟹ evaluate
            [a # x] C ; evaluate [y] C ≡<sub>p</sub> evaluate ([a # x] ;<sub
              >c</sub
            >
            [y]) C
          </p>

          <hr />
          <p><strong>concat_prop12_1</strong></p>

          <p>
                all_feasible (a#x@y) ⟹ evaluate [a # x] (complete_state (a#x@y))
            ; evaluate [y] (complete_state (a#x@y)) ≡<sub>p</sub> evaluate ([a #
            x] ;<sub>c</sub> [y]) (complete_state (a#x@y))
          </p>

          <hr />
          <p><strong>choice_non_empty</strong></p>

          <p>    non_empty a ∪<sub>c</sub> b = a ∪<sub>c</sub> b</p>

          <hr />
          <p><strong>choice_non_empty2</strong></p>

          <p>    non_empty a ∪<sub>c</sub> non_empty b = a ∪<sub>c</sub> b</p>

          <hr />
          <p><strong>non_empty9</strong></p>

          <p>    x ∈ set (non_empty xs) ⟹ x ∈ set xs</p>

          <hr />
          <p><strong>non_empty10</strong></p>

          <p>    non_empty xs = [y] ⟹ ∃a b. a@y#b = xs</p>

          <hr />
          <p><strong>non_empty11</strong></p>

          <p>    xs = [ ] ⟹ evaluate xs C = Fail {}</p>

          <hr />
          <p><strong>non_empty12</strong></p>

          <p>
                non_empty xs = [x] ⟹ non_empty xs = xs ⟹ evaluate xs = evaluate
            [x]
          </p>

          <hr />
          <p><strong>nonempty_monotonic</strong></p>

          <p>    size (non_empty (x#xs)) &gt; size (non_empty xs)</p>

          <hr />
          <p><strong>non_empty_reduces_size</strong></p>

          <p>    size (non_empty xs) &lt; size xs</p>

          <hr />
          <p><strong>non_empty_13</strong></p>

          <p>    size (x#xs) = size (non_empty (x#xs)) ⟹ x ≠ [ ]</p>

          <hr />
          <p><strong>non_empty_14</strong></p>

          <p>    size b = size (non_empty b) ⟹ b = (non_empty b)</p>

          <hr />
          <p><strong>eval_prop3</strong></p>

          <p>
                size b = 1 ⟹ size (non_empty b) = 1 ⟹ evaluate b = evaluate
            (non_empty b)
          </p>

          <hr />
          <p><strong>comp_cnf3</strong></p>

          <p>
                x ≠ [ ] ⟹ y ≠ [ ] ⟹ Concat x (complete_state (x@y)) ; Concat y
            (complete_state (x@y)) = Concat (x @ y) (complete_state (x@y))
          </p>

          <hr />
          <p><strong>comp_prop1</strong></p>

          <p>    x ; (y ∪<sub>p</sub> Skip {}) ≡<sub>p</sub> x ; y</p>

          <hr />
          <p><strong>choice_cnf_thm</strong></p>

          <p>
                evaluate xs (complete_cnf_state (xs@ys)) ∪<sub>p</sub> evaluate
            ys (complete_cnf_state (xs@ys)) ≡<sub>p</sub> evaluate (xs ∪<sub
              >c</sub
            >
            ys) (complete_cnf_state (xs@ys))
          </p>

          <hr />
          <p><strong>non_empty14</strong></p>

          <p>    ∀t ∈ set xs. t ≠ [ ] ⟹ non_empty xs = xs</p>

          <hr />
          <p><strong>choic_cnf1</strong></p>

          <p>
                (x#xs) ;<sub>c</sub> ys = ([x] ;<sub>c</sub> ys) ∪<sub>c</sub>
            (xs ;<sub>c</sub> ys)
          </p>

          <hr />
          <p><strong>comp_distrib_r</strong></p>

          <p>
                (b ∪<sub>c</sub> c) ;<sub>c</sub> a = (b ;<sub>c</sub> a) ∪<sub
              >c</sub
            >
            (c ;<sub>c</sub> a)
          </p>

          <hr />
          <p><strong>choice_cnf_commute</strong></p>

          <p>
                a ∪<sub>c</sub> (b ∪<sub>c</sub> c) = (a ∪<sub>c</sub> b) ∪<sub
              >c</sub
            >
            c
          </p>

          <hr />
          <p><strong>equal_sym</strong></p>

          <p>    equal_cnf a b = equal_cnf b a</p>

          <hr />
          <p><strong>equal_empty</strong></p>

          <p>    equal_cnf a [ ] ⟹ a = [ ]</p>

          <hr />
          <p><strong>eval_prop1</strong></p>

          <p>
                ys≠[ ] ⟹ evaluate ys C ∪<sub>p</sub> evaluate [y] C = evaluate
            (ys @ [y]) C
          </p>

          <hr />
          <p><strong>evaluate_switch</strong></p>

          <p>    evaluate (y#ys) C = evaluate (ys@[y]) C</p>

          <hr />
          <p><strong>evaluate_split</strong></p>

          <p>
                xs≠[ ] ⟹ ys ≠ [ ] ⟹ evaluate (xs@ys) C = evaluate xs C ∪<sub
              >p</sub
            >
            evaluate ys C
          </p>

          <hr />
          <p><strong>evaluate_switch2</strong></p>

          <p>    evaluate (yss@yse) C = evaluate (yse@yss) C</p>

          <hr />
          <p><strong>eval_perm</strong></p>

          <p>
                a#ys’ ∈ set (permutations ys) ⟹ evaluate (a#ys’) C = evaluate ys
            C
          </p>

          <hr />
          <p><strong>perm_eval</strong></p>

          <p>    xs ∈ set (permutations ys) ⟹ evaluate xs C = evaluate ys C</p>

          <hr />
          <p><strong>perm_prop</strong></p>

          <p>
                [t. t ← xs, ¬p t] @ [t. t ← xs, p t] ∈ set (permutations xs)
          </p>

          <hr />
          <p><strong>size_prop</strong></p>

          <p>    size ([t. t ← xs, ¬p t] @ [t. t ← xs, p t]) = size xs</p>

          <hr />
          <p><strong>evaluate_split1</strong></p>

          <p>
                size (xs@ys) ≠ 1 ⟹ evaluate xs C ∪<sub>p</sub> evaluate ys C =
            evaluate (xs@ys) C
          </p>

          <hr />
          <p><strong>evaluate_split2</strong></p>

          <p>
                size xs ≠1 ⟹ evaluate xs C = evaluate [t. t ← xs, t =x] C ∪<sub
              >p</sub
            >
            evaluate [t. t ← xs, t≠x] C
          </p>

          <hr />
          <p><strong>size_prop1</strong></p>

          <p>    size [t. t←a, t=x] + size [t. t←a, t≠x] = size a</p>

          <hr />
          <p><strong>evaluate_prop</strong></p>

          <p>    size xs = 1 ⟹ ∀t ∈ set xs. t=x ⟹ evaluate xs = evaluate [x]</p>

          <hr />
          <p><strong>evaluate_prop2</strong></p>

          <p>
                size xs &gt; 1 ⟹ ∀t ∈ set xs. t=x ⟹ evaluate xs C = evaluate [x]
            C ∪<sub>p</sub> evaluate [x] C
          </p>

          <hr />
          <p><strong>equal_eval</strong></p>

          <p>    equal_cnf a b ⟹ evaluate a C = evaluate b C</p>

          <hr />
          <p><strong>eval_simp</strong></p>

          <p>    ∀C. evaluate a C = evaluate b C ⟹ evaluate a = evaluate b</p>

          <hr />
          <p><strong>equal_eval2</strong></p>

          <p>    equal_cnf a b ⟹ evaluate a = evaluate b</p>

          <hr />
          <p><strong>eq_reflexive</strong></p>

          <p>    equal xs xs</p>

          <hr />
          <p><strong>comp_prop</strong></p>

          <p>
                tr ∈ set (xs ;<sub>c</sub> ys) ⟹ ∃x y. x ∈ set xs ∧ y ∈ set ys ∧
            x@y = tr
          </p>

          <hr />
          <p><strong>comp_prop2</strong></p>

          <p>    x ∈ set xs ⟹ y ∈ set ys ⟹ x@y ∈ set (xs ;<sub>c</sub> ys)</p>

          <hr />
          <p><strong>choice_prop</strong></p>

          <p>
                tr ∈ set (xs ∪<sub>c</sub> ys) ⟹ (tr ∈ set xs ∨ tr ∈ set ys)
          </p>

          <hr />
          <p><strong>same_traces_size_equal</strong></p>

          <p>
                ∀tr ∈ set xs. tr ∈ set ys ⟹ ∀tr ∈ set ys. tr ∈ set xs ⟹ size xs
            = size ys ⟹ equal_cnf xs ys
          </p>

          <hr />
          <p><strong>same_traces_size_equal2</strong></p>

          <p>
                size xs = size ys ⟹ equal_cnf xs ys ⟹ ∀tr ∈ set xs. tr ∈ set ys
          </p>

          <hr />
          <p><strong>same_traces_size_equal3</strong></p>

          <p>
                size xs = size ys ⟹ equal_cnf xs ys ⟹ ∀tr ∈ set ys. tr ∈ set xs
          </p>

          <hr />
          <p><strong>comp_prop3</strong></p>

          <p>
                ∃q w. q ∈ set a ∧ w ∈ set b ∧ tr = q @ w ∧ q ≠ [ ] ∧ w ≠ [ ] ⟹
            tr ∈ set (a ;<sub>c</sub> b)
          </p>

          <hr />
          <p><strong>choice_prop2</strong></p>

          <p>
                ∃q. (q ∈ set a ∨ q ∈ set b) ∧ tr = q ∧ q ≠ [ ] ⟹ tr ∈ set (a
            ∪<sub>c</sub> b)
          </p>

          <hr />
          <p>    size (a ∪<sub>c</sub> b) = size (a) + size (b)</p>

          <hr />
          <p><strong>comp_size</strong></p>

          <p>
                x ≠ [ ] ⟹ length (((xx # x) # xs) ;<sub>c</sub> b) = length ((x
            # xs) ;<sub>c</sub> b)
          </p>

          <hr />
          <p><strong>comp_size2</strong></p>

          <p>    size ([[a]] ;<sub>c</sub> b) = size b</p>

          <hr />
          <p><strong>comp_size3</strong></p>

          <p>    size (a ;<sub>c</sub> b) = size a * size b</p>

          <hr />
          <p><strong>feas_prop</strong></p>

          <p>    all_feasible xs ⟹ is_feasible (Concat xs C)</p>

          <hr />
          <p><strong>feas_prop3</strong></p>

          <p>    is_feasible (evaluate [ ] C)</p>

          <hr />
          <p><strong>feas_prop4</strong></p>

          <p>    is_feasible (evaluate [[ ]] C)</p>

          <hr />
          <p><strong>feas_prop5</strong></p>

          <p>    is_feasible x ⟹ is_feasible (evaluate [[x]] C)</p>

          <hr />
          <p><strong>eval_prop4</strong></p>

          <p>
                xs ≠ [ ] ⟹ evaluate [x # xs] C = evaluate [[x]] C ; evaluate
            [xs] C
          </p>

          <hr />
          <p><strong>feas_prop6</strong></p>

          <p>    all_feasible xs ⟹ is_feasible (evaluate [xs] C)</p>

          <hr />
          <p><strong>feas_prop7</strong></p>

          <p>    ∀bb ∈ set b. all_feasible bb ⟹ is_feasible (evaluate b C)</p>

          <hr />
          <p><strong>cnf_state_prop</strong></p>

          <p>    complete_cnf_state (x#b) ⊆ C ⟹ complete_cnf_state b ⊆ C</p>

          <hr />
          <p><strong>cnf_state_prop2</strong></p>

          <p>    complete_state xs ⊆ C ⟹ S (evaluate [xs] C) ⊆ C</p>

          <hr />
          <p><strong>cnf_state_prop1</strong></p>

          <p>    complete_cnf_state xs ⊆ C ⟹ S (evaluate xs C) ⊆ C</p>

          <hr />
          <p><strong>skip_left_neutral</strong></p>

          <p>
                complete_cnf_state b ⊆ C ⟹ Skip C ; evaluate b C ≡<sub>p</sub>
            evaluate b C
          </p>

          <hr />
          <p><strong>skip_right_neutral</strong></p>

          <p>
                ∀bb ∈ set b. all_feasible bb ⟹ complete_cnf_state b ⊆ C ⟹
            evaluate b C ; Skip C ≡<sub>p</sub> evaluate b C
          </p>

          <hr />
          <p><strong>feas_prop8</strong></p>

          <p>    all_feasible x ⟹ all_feasible b1 ⟹ all_feasible (x @ b1)</p>

          <hr />
          <p><strong>state_prop</strong></p>

          <p>    y ∈set ys ⟹ complete_state (ys) = complete_state (y#ys)</p>

          <hr />
          <p><strong>state_prop8</strong></p>

          <p>    set xs ⊆ set ys ⟹ complete_state xs ⊆ complete_state ys</p>

          <hr />
          <p><strong>state_prop9</strong></p>

          <p>    complete_cnf_state (xs # [ys]) = complete_state (xs @ ys)</p>

          <hr />
          <p><strong>compose_equiv</strong></p>

          <p>
                complete_cnf_state (x#b) ⊆ C ⟹ all_feasible x ⟹ ∀bb ∈ set b.
            all_feasible bb ⟹ evaluate [x] C ; evaluate b C ≡<sub>p</sub>
            evaluate ([x] ;<sub>c</sub> b) C
          </p>

          <hr />
          <p><strong>state_prop10</strong></p>

          <p>    complete_cnf_state (a) ⊆ complete_cnf_state (a @ b)</p>

          <hr />
          <p><strong>state_prop11</strong></p>

          <p>    complete_cnf_state (b) ⊆ complete_cnf_state (a @ b)</p>

          <hr />
          <p><strong>state_prop12</strong></p>

          <p>
                set xs ⊆ set ys ⟹ complete_cnf_state xs ⊆ complete_cnf_state ys
          </p>

          <hr />
          <p><strong>eval_choice</strong></p>

          <p>
                evaluate xs C ∪<sub>p</sub> evaluate ys C ≡<sub>p</sub> evaluate
            (xs ∪<sub>c</sub> ys) C
          </p>

          <hr />
          <p><strong>comp_choice</strong></p>

          <p>
                ([x] ;<sub>c</sub> b) ∪<sub>c</sub> (a’ ;<sub>c</sub> b) =
            (x#a’) ;<sub>c</sub> b
          </p>

          <hr />
          <p><strong>normal_prop15</strong></p>

          <p>    set a = set b ⟹ normal_of a B = normal_of b B</p>

          <hr />
          <p><strong>normal_prop16</strong></p>

          <p>    set a ⊆ set b ⟹ normal_of b B → normal_of a B</p>

          <hr />
          <p><strong>non_empty_is_smaller</strong></p>

          <p>    set (non_empty xs) ⊆ set xs</p>

          <hr />
          <p><strong>normal_prop17</strong></p>

          <p>    normal_of a B ⟹ normal_of (non_empty a) B</p>

          <hr />
          <p><strong>normal_prop17_5</strong></p>

          <p>    normal_of xs B ⟹ normal_of [x] B ⟹ normal_of (x#xs) B</p>

          <hr />
          <p><strong>normal_prop18</strong></p>

          <p>
                normal_of a B ⟹ normal_of b B ⟹ normal_of (a ∪<sub>c</sub> b) B
          </p>

          <hr />
          <p><strong>basic_prop6</strong></p>

          <p>    basic (map ((@) x) bs) ⊆ basic [x] ∪ basic bs</p>

          <hr />
          <p><strong>normal_prop19</strong></p>

          <p>
                normal_of [x] B ⟹ normal_of b B ⟹ normal_of [x@ys. ys ← b] B
          </p>

          <hr />
          <p><strong>normal_prop20</strong></p>

          <p>
                normal_of a B ⟹ normal_of b B ⟹ normal_of (a ;<sub>c</sub> b) B
          </p>

          <hr />
          <p><strong>state_prop13</strong></p>

          <p>
                normal_of [x] B ⟹ complete_cnf_state [x] ⊆ complete_state
            (set_to_list B)
          </p>

          <hr />
          <p><strong>state_prop14</strong></p>

          <p>
                normal_of xs B ⟹ complete_cnf_state xs ⊆ complete_state
            (set_to_list B)
          </p>

          <hr />
          <p><strong>feas_prop9</strong></p>

          <p>
                all_feasible (set_to_list B) ⟹ normal_of xs B ⟹ ∀tr ∈ set xs.
            all_feasible tr
          </p>

          <hr />
          <p><strong>comp_prop4</strong></p>

          <p>
                all_feasible x ⟹ all_feasible y ⟹ complete_state x ⊆ C ⟹
            complete_state y ⊆ C ⟹ evaluate ([x] ;<sub>c</sub> [y]) C ≡<sub
              >p</sub
            >
            evaluate [x] C ; evaluate [y] C
          </p>

          <hr />
          <p>
                complete_cnf_state (x#ys) ⊆ C ⟹ ∀tr∈set (x#ys). all_feasible tr
            ⟹ evaluate ([x] ;<sub>c</sub> ys) C ≡<sub>p</sub> evaluate ([x]) C ;
            evaluate (ys) C
          </p>

          <hr />
          <p><strong>civilized_thm1</strong></p>

          <p>
                all_feasible (set_to_list B) ⟹ S p ⊆ C ⟹ civilized_n p B n ⟹
            ∃(y::’a CNF). evaluate y C ≡<sub>p</sub> p ∧ normal_of y B
          </p>

          <hr />
          <p><strong>set_to_list_prop</strong></p>

          <p>    finite F ⟹ y ∉ F ⟹ count_list (set_to_list F) y = 0</p>

          <hr />
          <p><strong>set_to_list_prop2</strong></p>

          <p>    finite F ⟹ count_list (set_to_list (F - {y})) y = 0</p>

          <hr />
          <p><strong>set_to_list_prop3</strong></p>

          <p>    count_list (set_to_list {y}) y = 1</p>

          <hr />
          <p><strong>set_to_list_prop4</strong></p>

          <p>    count_list (set_to_list {}) y = 0</p>

          <hr />
          <p><strong>set_to_list_prop5</strong></p>

          <p>
                finite F ⟹ y ∉ F ⟹ set_to_list (insert y F) ∈ set (permutations
            (y # set_to_list F))
          </p>

          <hr />
          <p>    finite F ⟹ count_list (set_to_list (insert x F)) x = 1</p>

          <hr />
          <p><strong>set_to_list_prop6</strong></p>

          <p>
                finite F ⟹ x ∉ F ⟹ count_list (set_to_list (insert x F)) y =
            count_list (x#set_to_list F) y
          </p>

          <hr />
          <p><strong>set_to_list_prop7</strong></p>

          <p>
                finite F ⟹ x ∉ F ⟹ x ≠ y ⟹ count_list (set_to_list (insert x F))
            y = count_list (set_to_list F) y
          </p>

          <hr />
          <p><strong>set_to_list_prop8</strong></p>

          <p>    x=y ⟹ count_list (yst@x#ynd) y = count_list (yst@ynd) y + 1</p>

          <hr />
          <p><strong>set_to_list_prop9</strong></p>

          <p>    x≠y ⟹ count_list (yst@x#ynd) y = count_list (yst@ynd) y</p>

          <hr />
          <p><strong>set_to_list_prop10</strong></p>

          <p>    xs ∈ set (permutations ys) ⟹ count_list xs = count_list ys</p>

          <hr />
          <p><strong>set_to_list_prop11</strong></p>

          <p>    finite F ⟹ count_list (set_to_list F) x &lt; 1</p>

          <hr />
          <p><strong>set_to_list_prop12</strong></p>

          <p>    finite F ⟹ x ∈ F ⟹ count_list (set_to_list F) x = 1</p>

          <hr />
          <p><strong>set_to_list_prop13</strong></p>

          <p>
                count_list xs x = 1 ⟹ count_list (set_to_list (set xs)) x = 1
          </p>

          <hr />
          <p><strong>set_to_list_prop14</strong></p>

          <p>
                finite F ⟹ complete_state (set_to_list (insert y F)) =
            complete_state (set_to_list (F)) ∪ S y
          </p>

          <hr />
          <p><strong>set_to_list_prop15</strong></p>

          <p>    civilized p B ⟹ S p ⊆ complete_state (set_to_list B)</p>

          <hr />
          <p><strong>civilized_thm2</strong></p>

          <p>
                all_feasible (set_to_list B) ⟹ civilized p B ⟹ ∃(y::’a CNF).
            evaluate y (complete_state (set_to_list B)) ≡<sub>p</sub> p ∧
            normal_of y B
          </p>

          <hr />
          <p><strong>fail_is_civilized</strong></p>

          <p>    finite B ⟹ civilized (Fail{}) B</p>

          <hr />
          <p><strong>skip_is_civilized</strong></p>

          <p>
                finite B ⟹ civilized (Skip (complete_state (set_to_list B))) B
          </p>

          <hr />
          <p><strong>civilized_thm3</strong></p>

          <p>
                ∃(y::’a CNF). evaluate y (complete_state (set_to_list B)) = p ∧
            normal_of y B ⟹ civilized p B
          </p>

          <hr />
          <p><strong>composition_cnf_prop1</strong></p>

          <p>    [[x]] ;<sub>c</sub> xs = [x#ys. ys ← xs]</p>

          <hr />
          <p><strong>composition_cnf_prop2</strong></p>

          <p>    [y#ys] ;<sub>c</sub> xs = [( y#ys)@t. t ← xs]</p>

          <hr />
          <p><strong>non2_prop1</strong></p>

          <p>    non_empty x = [ ] ⟹ non_empty2 (x # xs) = non_empty2 xs</p>

          <hr />
          <p><strong>non2_prop2</strong></p>

          <p>
                non_empty x ≠ [ ] ⟹ non_empty2 (x # xs) = non_empty x #
            non_empty2 xs
          </p>

          <hr />
          <p><strong>non2_prop3</strong></p>

          <p>    non_empty2 (xs @ ys) = non_empty2 xs @ non_empty2 ys</p>

          <hr />
          <p><strong>non2_prop4</strong></p>

          <p>    size (non_empty2 xs) &lt; size xs</p>

          <hr />
          <p><strong>non2_prop5</strong></p>

          <p>    non_empty2 (x#xs) = x#xs ⟹ non_empty2 xs = xs</p>

          <hr />
          <p><strong>non2_prop5_5</strong></p>

          <p>    non_empty2 [x] = [x] ⟹ ∀path∈set x. path ≠ [ ]</p>

          <hr />
          <p><strong>non2_prop6</strong></p>

          <p>
                non_empty2 xs = xs ⟹ ∀prog ∈ set xs. prog ≠ [ ] ∧ (∀path ∈ set
            prog. path ≠ [ ])
          </p>

          <hr />
          <p><strong>non_prop1</strong></p>

          <p>    non_empty xs = xs ⟹ ∀path ∈ set xs. path ≠ [ ]</p>

          <hr />
          <p><strong>non2_prop7</strong></p>

          <p>    non_empty2 xs = xs ⟹ x ∈ set xs ⟹ non_empty x = x</p>

          <hr />
          <p><strong>non2_idem</strong></p>

          <p>    non_empty2 xs = non_empty2 (non_empty2 xs)</p>

          <hr />
          <p><strong>inter_head</strong></p>

          <p>    p ∈ set ((x#xs) ⫴ (y#ys)) ⟹ hd p = x ∨ hd p = y</p>

          <hr />
          <p><strong>count_prop</strong></p>

          <p>    count_list (map ((#) x) xs) (x#p) = count_list xs p</p>

          <hr />
          <p><strong>count_prop2</strong></p>

          <p>    x≠y ⟹ count_list (map ((#) x) xs) (y#p) = 0</p>

          <hr />
          <p><strong>interleave_non_empty</strong></p>

          <p>    p ∈ set ((x#xs) ⫴ (y#ys)) ⟹ p ≠ [ ]</p>

          <hr />
          <p><strong>inter2</strong></p>

          <p>    count_list (ys ⫴ xs) p = count_list (xs ⫴ ys) p</p>

          <hr />
          <p><strong>inter_perm</strong></p>

          <p>    ys ⫴ xs ∈ set (permutations (xs ⫴ ys))</p>

          <hr />
          <p><strong>t1</strong></p>

          <p>
                size xs = size ys ⟹ ∀t∈set (zip xs ys). fst t ∈ set
            (permutations (snd t)) ⟹ concat xs ∈ set (permutations (concat ys))
          </p>

          <hr />
          <p><strong>t15</strong></p>

          <p>
                size xs = size ys ⟹ ∃xs’. xs’ ∈ set (permutations xs) ∧ (∀t∈set
            (zip xs’ ys). fst t ∈ set (permutations (snd t))) ⟹ concat xs ∈ set
            (permutations (concat ys))
          </p>

          <hr />
          <p><strong>t2</strong></p>

          <p>    size [f x y. x ← xs, y ← ys] = size xs * size ys</p>

          <hr />
          <p><strong>t3</strong></p>

          <p>
                size [path_m ⫴ path_n. path_m ← xs, path_n ← ys] = size [path_m
            ⫴ path_n. path_m ← ys, path_n ← xs]
          </p>

          <hr />
          <p><strong>index_prop</strong></p>

          <p>    length xs = a ⟹ (xs@ys)!(a+b) = ys!b</p>

          <hr />
          <p><strong>index_prop2</strong></p>

          <p>    a &lt; length xs ⟹ xs!a = (xs@ys)!a</p>

          <hr />
          <p><strong>index_prop3</strong></p>

          <p>
                size (concat (map (λx. f x y # map (f x) ys) xs)) = size xs *
            size (y#ys)
          </p>

          <hr />
          <p><strong>list_comp_index</strong></p>

          <p>
                x_ind &lt; size xs ⟹ y_ind &lt; size ys ⟹ [f x y. x ← xs, y ←
            ys] ! (x_ind * size ys + y_ind) = f (xs ! x_ind) (ys ! y_ind)
          </p>

          <hr />
          <p><strong>interleave_ind_comp</strong></p>

          <p>
                x_ind&lt;size xs ⟹ y_ind&lt;size ys ⟹ [path_m ⫴ path_n. path_m ←
            xs, path_n ← ys] ! ((x_ind* (size ys))+y_ind) = (xs ! x_ind) ⫴ (ys !
            y_ind)
          </p>

          <hr />
          <p>
                x_ind &lt; size xs ⟹ y_ind &lt; size ys ⟹ [path_m ⫴ path_n.
            path_m ← xs, path_n ← ys] ! ((x_ind* (size ys))+y_ind) = [path_m ⫴
            path_n. path_m ← ys, path_n ← xs] ! ((y_ind* (size xs))+x_ind)
          </p>

          <hr />
          <p><strong>all_elements_have_permutation</strong></p>

          <p>
                x_ind &lt; size xs ⟹ y_ind &lt; size ys ⟹ [path_m ⫴ path_n.
            path_m ← xs, path_n ← ys] ! ((x_ind* (size ys))+y_ind) ∈ set
            (permutations ([path_m ⫴ path_n. path_m ← ys, path_n ← xs] !
            ((y_ind* (size xs))+x_ind)))
          </p>

          <hr />
          <p><strong>perm_prop1</strong></p>

          <p>
                xs ∈ set (permutations xs’) ⟹ ys ∈ set (permutations ys’) ⟹
            xs@ys ∈ set (permutations (xs’@ys’))
          </p>

          <hr />
          <p><strong>is_perm</strong></p>

          <p>
                size xy = sx * sy ⟹ [xy ! ((x_ind*sy)+y_ind). x_ind ←
            [0..&lt;sx], y_ind ← [0..&lt;sy]] ∈ set (permutations xy)
          </p>

          <hr />
          <p><strong>is_perm2</strong></p>

          <p>
                size xy = size xs * size ys ⟹ [xy ! ((x_ind*(size ys))+y_ind).
            x_ind ← [0..&lt;size xs], y_ind ← [0..&lt;size ys]] ∈ set
            (permutations xy)
          </p>

          <hr />
          <p><strong>index_prop4</strong></p>

          <p>
                i &lt; size xs * size ys ⟹ concat (map (λx. map (f x) ys) xs) !
            i = f (xs ! (i div length ys)) (ys ! (i mod length ys))
          </p>

          <hr />
          <p><strong>index_prop5</strong></p>

          <p>
                concat (map (λx. map (f x) ys) xs) = [f (xs ! (i div length ys))
            (ys ! (i mod length ys)). i ← [0..&lt;size xs * size ys]]
          </p>

          <hr />
          <p><strong>perm_prop2</strong></p>

          <p>    [ ] ∈ set (permutations xy) ⟹ xy = [ ]</p>

          <hr />
          <p><strong>perm_prop5</strong></p>

          <p>
                concat (map (λy. map (λx. f x y) [x]) (ys)) @ concat (map (λy.
            map (λx. f x y) xs) (ys)) ∈ set (permutations (concat (map (λy. map
            (λx. f x y) (x # xs)) (ys))))
          </p>

          <hr />
          <p><strong>perm_prop3</strong></p>

          <p>
                [f x y. x ← xs, y ← ys] ∈ set (permutations xy) ⟹ [f x y. y ←
            ys, x ← xs] ∈ set (permutations xy)
          </p>

          <hr />
          <p><strong>is_perm4</strong></p>

          <p>
                size xy = sx * sy ⟹ [xy ! ((x_ind*sy)+y_ind). y_ind ←
            [0..&lt;sy], x_ind ← [0..&lt;sx]] ∈ set (permutations xy)
          </p>

          <hr />
          <p><strong>perm_exists</strong></p>

          <p>
                xy = [path_m ⫴ path_n. path_m ← xs, path_n ← ys] ⟹ yx = [path_m
            ⫴ path_n. path_m ← ys, path_n ← xs] ⟹ ∃xy’. xy’ ∈ set (permutations
            xy) ∧ (∀t∈set (zip xy’ yx). fst t ∈ set (permutations (snd t)))
          </p>

          <hr />
          <p><strong>is_permutation</strong></p>

          <p>    (xs ∥ ys) ∈ set (permutations (ys ∥ xs))</p>

          <hr />
          <p><strong>t4</strong></p>

          <p>    size (xs ∥ ys) = size (ys ∥ xs)</p>

          <hr />
          <p><strong>inter_prop1</strong></p>

          <p>    xs ≠ [ ] ⟹ interleave xs ys ≠ [ ]</p>

          <hr />
          <p><strong>perm_is_equal</strong></p>

          <p>    xs ∈ set (permutations ys) ⟹ evaluate xs = evaluate ys</p>

          <hr />
          <p>    evaluate (xs ∥ ys) = evaluate (ys ∥ xs)</p>

          <hr />
          <h2 id="cnf_concurrencythy">CNF_concurrency.thy</h2>

          <p>    (a@b)∥c =(a∥c)@(b∥c)</p>

          <hr />
          <p><strong>fact_eq</strong></p>

          <p>    factorial n = fact n</p>

          <hr />
          <p><strong>factorial_mod_product</strong></p>

          <p>
                factorial (a + b) mod (factorial a * factorial b) = (0::nat)
          </p>

          <hr />
          <p><strong>factorial_bound</strong></p>

          <p>    factorial n &gt; 0</p>

          <hr />
          <p><strong>simp_div</strong></p>

          <p>
                a mod b = 0 ⟹ c mod b = 0 ⟹ (a::nat) div b + c div b = (a + c)
            div b
          </p>

          <hr />
          <p><strong>exits_mulit</strong></p>

          <p>    ∃t::nat. n*t=m ⟹ m mod n = 0</p>

          <hr />
          <p>
                nmb_interleavings_pre (nmb_interleavings_pre x y) z =
            nmb_interleavings_pre x (nmb_interleavings_pre y z)
          </p>

          <hr />
          <p><strong>number_interleav</strong></p>

          <p>    length (xs ⫴ ys) = nmb_interleavings xs ys</p>

          <hr />
          <p><strong>monoton_fact</strong></p>

          <p>    a &lt; b ⟹ factorial a &lt; factorial b</p>

          <hr />
          <p><strong>interleave_size</strong></p>

          <p>    size xs * size ys &lt; size (xs ⫴ ys)</p>

          <hr />
          <p><strong>list_comp_size</strong></p>

          <p>
                size [f path_m path_n. path_m ← xs, path_n ← ys] &gt; size xs *
            size ys
          </p>

          <hr />
          <p><strong>interleav_lower_bound</strong></p>

          <p>    size (xs ⫴ ys) &gt; 1</p>

          <hr />
          <p><strong>concat_prop</strong></p>

          <p>    ∀x ∈ set xs. size x &gt; 1 ⟹ size (concat xs) &gt; size xs</p>

          <hr />
          <p><strong>conc_size</strong></p>

          <p>    size xs * size ys &lt; size (xs ∥ ys)</p>

          <hr />
          <p><strong>size_one1</strong></p>

          <p>    size (xs ∥ ys) = 1 ⟹ size xs = 1</p>

          <hr />
          <p><strong>size_one2</strong></p>

          <p>    size (xs ∥ ys) = 1 ⟹ size ys = 1</p>

          <hr />
          <p><strong>sum_1</strong></p>

          <p>    size (concat xs) = sum [size x. x←xs]</p>

          <hr />
          <p><strong>path_decomp</strong></p>

          <p>
                path ∈ set (p ∥ q) ⟹ ∃path_p path_q. path_p ∈ set p ∧ path_q ∈
            set q ∧ path ∈ set (path_p ⫴ path_q)
          </p>

          <hr />
          <p><strong>path_decomp2</strong></p>

          <p>
                path_p ∈ set p ⟹ path_q ∈ set q ⟹ path ∈ set (path_p ⫴ path_q) ⟹
            path ∈ set (p ∥ q)
          </p>

          <hr />
          <p><strong>inter_leav1</strong></p>

          <p>
                (p#path) ∈ set ((x#xs) ⫴ (y#ys)) ⟹ ((p=x) ∧ path ∈ set (xs ⫴
            (y#ys))) ∨ ((p=y) ∧ path ∈ set ((x#xs) ⫴ (ys)))
          </p>

          <hr />
          <p><strong>inter_leav2</strong></p>

          <p>
                ((p=y) ∧ path ∈ set ((x#xs) ⫴ (ys))) ⟹ (p#path) ∈ set ((x#xs) ⫴
            (y#ys))
          </p>

          <hr />
          <p><strong>inter_leav3</strong></p>

          <p>
                ((p=x) ∧ path ∈ set (xs ⫴ (y#ys))) ⟹ (p#path) ∈ set ((x#xs) ⫴
            (y#ys))
          </p>

          <hr />
          <p><strong>conc_lem1</strong></p>

          <table>
            <tbody>
              <tr>
                <td>    set (xs ∥ ys) = ⋃ {set (path_x ⫴ path_y)</td>
                <td>path_x path_y. path_x ∈ set xs ∧ path_y ∈ set ys}</td>
              </tr>
            </tbody>
          </table>

          <hr />
          <p>    set ((x#xs) ∥ ys) = set ([x]∥ys) ∪ set (xs∥ys)</p>

          <hr />
          <p><strong>assoc_1</strong></p>

          <p>    set (([x] ∥ [y]) ∥ [z]) ⊆ set ([x] ∥ ([y] ∥ [z]))</p>

          <hr />
          <p><strong>assoc_2</strong></p>

          <p>    set ([x] ∥ ([y] ∥ [z])) ⊆ set (([x] ∥ [y]) ∥ [z])</p>

          <hr />
          <p><strong>assoc_3</strong></p>

          <p>    set (([x] ∥ [y]) ∥ [z]) ⊆ set (((x#xs) ∥ (y#ys)) ∥ (z#zs))</p>

          <hr />
          <p><strong>assoc_4</strong></p>

          <p>    set ([x] ∥ ([y] ∥ [z])) ⊆ set ((x#xs) ∥ ((y#ys) ∥ (z#zs)))</p>

          <hr />
          <p><strong>assoc_5</strong></p>

          <p>
                set xs = set xs’ ⟹ set ys = set ys’ ⟹ set (xs ∥ ys) = set (xs’ ∥
            ys’)
          </p>

          <hr />
          <p><strong>assoc_6</strong></p>

          <p>
                y ∈ set ys ⟹ x ∈ set xs ⟹ set ((x#xs) ∥ (y#ys)) = set ((xs) ∥
            (ys))
          </p>

          <hr />
          <p><strong>assoc_7</strong></p>

          <p>    set ((xs ∥ ys) ∥ zs) ⊆ set (xs ∥ (ys ∥ zs))</p>

          <hr />
          <p><strong>assoc_8</strong></p>

          <p>    set (xs ∥ (ys ∥ zs)) ⊆ set ((xs ∥ ys) ∥ zs)</p>

          <hr />
          <p><strong>assoc_9</strong></p>

          <p>    set (xs ∥ (ys ∥ zs)) = set ((xs ∥ ys) ∥ zs)</p>

          <hr />
          <p><strong>inter_size</strong></p>

          <p>    size (x ⫴ y) &gt; 0” apply (cases “x=[ ]</p>

          <hr />
          <p><strong>inter_size2</strong></p>

          <p>    size (x ⫴ y) = 1 ⟹ size x = 0 ∨ size y = 0</p>

          <hr />
          <p><strong>inter_size3</strong></p>

          <p>    size x = 0 ∨ size y = 0 ⟹ size (x ⫴ y) = 1</p>

          <hr />
          <p><strong>interleaving_lemma</strong></p>

          <p>    size ([x] ∥ [y]) = nmb_interleavings_pre (size x) (size y)</p>

          <hr />
          <p><strong>inter_size4</strong></p>

          <p>    size (xs ∥ ys) = 1 ⟹ size xs = 1 ∨ size ys = 1</p>

          <hr />
          <p><strong>conc_prop</strong></p>

          <p>    xs ∥ [[ ]] = xs</p>

          <hr />
          <p><strong>conc_prop2</strong></p>

          <p>    [[ ]] ∥ xs = xs</p>

          <hr />
          <p><strong>assoc_10</strong></p>

          <p>    size (xs ∥ (ys ∥ zs)) = 1 ⟹ size ((xs ∥ ys) ∥ zs) = 1</p>

          <hr />
          <p><strong>assoc_11</strong></p>

          <p>    size ((xs ∥ ys) ∥ zs) = 1 ⟹ size (xs ∥ (ys ∥ zs)) = 1</p>

          <hr />
          <p><strong>assoc_12</strong></p>

          <p>    size (xs ∥ (ys ∥ zs)) = 1 ≡ size ((xs ∥ ys) ∥ zs) = 1</p>

          <hr />
          <p><strong>assoc_cnf1</strong></p>

          <p>    equal_cnf ((xs ∥ ys) ∥ zs) (xs ∥ (ys ∥ zs))</p>

          <hr />
          <p><strong>assoc_cnf</strong></p>

          <p>    evaluate ((xs ∥ ys) ∥ zs) = evaluate (xs ∥ (ys ∥ zs))</p>

          <hr />
          <p><strong>cnf_prop</strong></p>

          <p>    xs ≠ [ ] ⟹ evaluate [x#xs] C = x ; (evaluate [xs] C)</p>

          <hr />
          <p><strong>cnf_prop2</strong></p>

          <p>    xs ≠ [ ] ⟹ evaluate [xs@[x]] C = (evaluate [xs] C) ; x</p>

          <hr />
          <p><strong>restrict_cnf1</strong></p>

          <p>
                D ⊆ C ⟹ evaluate ([x] /<sub>c</sub> C) D = (evaluate [x] D)
            /<sub>p</sub> C
          </p>

          <hr />
          <p><strong>restr_distrib</strong></p>

          <p>
                a /<sub>p</sub> C ∪<sub>p</sub> b /<sub>p</sub> C = (a ∪<sub
              >p</sub
            >
            b) /<sub>p</sub> C
          </p>

          <hr />
          <p><strong>restrict_cnf</strong></p>

          <p>
                D ⊆ C ⟹ evaluate (xs /<sub>c</sub> C) D = (evaluate xs D) /<sub
              >p</sub
            >
            C
          </p>

          <hr />
          <p><strong>corestrict_cnf1</strong></p>

          <p>
                D ⊆ C ⟹ evaluate ([x] ∖<sub>c</sub> C) D = (evaluate [x] D)
            ∖<sub>p</sub> C
          </p>

          <hr />
          <p><strong>corestrict_cnf</strong></p>

          <p>
                D ⊆ C ⟹ evaluate (xs ∖<sub>c</sub> C) D= (evaluate xs D) ∖<sub
              >p</sub
            >
            C
          </p>

          <hr />
          <p><strong>conc_prop1</strong></p>

          <p>    set (xs ∥ ys) ⊆ set (xs ∥ (y#ys))</p>

          <hr />
          <p><strong>conc_prop3</strong></p>

          <p>    set (xs ∥ ys) ⊆ set (xs ∥ (ys ∪<sub>c</sub> zs))</p>

          <hr />
          <p><strong>conc_prop4</strong></p>

          <p>
                set (xs ∥ (ys ∪<sub>c</sub> zs)) = set (xs ∥ (zs ∪<sub>c</sub>
            ys))
          </p>

          <hr />
          <p><strong>conc_choice1_1</strong></p>

          <p>
                set (xs ∥ (ys ∪<sub>c</sub> zs)) = set ((xs ∥ ys) ∪<sub>c</sub>
            (xs ∥ zs))
          </p>

          <hr />
          <p><strong>choice_size1</strong></p>

          <p>
                size (xs ∥ (ys ∪<sub>c</sub> zs)) = 1 ⟹ size ((xs ∥ ys) ∪<sub
              >c</sub
            >
            (xs ∥ zs)) = 1
          </p>

          <hr />
          <p><strong>choice_size2</strong></p>

          <p>
                size ((xs ∥ ys) ∪<sub>c</sub> (xs ∥ zs)) = 1 ⟹ size (xs ∥ (ys
            ∪<sub>c</sub> zs)) = 1
          </p>

          <hr />
          <p><strong>Conc_choice1_1</strong></p>

          <p>
                equal_cnf ((xs ∥ ys) ∪<sub>c</sub> (xs ∥ zs)) (xs ∥ (ys ∪<sub
              >c</sub
            >
            zs))
          </p>

          <hr />
          <p><strong>Conc_choice1_</strong></p>

          <p>
                evaluate ((xs ∥ ys) ∪<sub>c</sub> (xs ∥ zs)) = evaluate (xs ∥
            (ys ∪<sub>c</sub> zs))
          </p>

          <hr />
          <p><strong>conc_prop5</strong></p>

          <p>    set (xs ∥ ys) ⊆ set ((x#xs) ∥ ys)</p>

          <hr />
          <p><strong>conc_prop6</strong></p>

          <p>    set (xs ∥ ys) ⊆ set ((xs ∪<sub>c</sub> zs) ∥ ys)</p>

          <hr />
          <p><strong>conc_prop7</strong></p>

          <p>
                set ((zs ∪<sub>c</sub> xs) ∥ ys) = set ((xs ∪<sub>c</sub> zs) ∥
            ys)
          </p>

          <hr />
          <p><strong>conc_choice2_1</strong></p>

          <p>
                set ((xs ∪<sub>c</sub> ys) ∥ zs) = set ((xs ∥ zs) ∪<sub>c</sub>
            (ys ∥ zs))
          </p>

          <hr />
          <p><strong>choice_size3</strong></p>

          <p>
                size ((xs ∪<sub>c</sub> ys) ∥ zs) = 1 ⟹ size ((xs ∥ zs) ∪<sub
              >c</sub
            >
            (ys ∥ zs)) = 1
          </p>

          <hr />
          <p><strong>choice_size4</strong></p>

          <p>
                size ((xs ∥ zs) ∪<sub>c</sub> (ys ∥ zs)) = 1 ⟹ size ((xs ∪<sub
              >c</sub
            >
            ys) ∥ zs) = 1
          </p>

          <hr />
          <p><strong>Conc_choice2_1</strong></p>

          <p>
                equal_cnf ((xs ∥ zs) ∪<sub>c</sub> (ys ∥ zs)) ((xs ∪<sub>c</sub>
            ys) ∥ zs)
          </p>

          <hr />
          <p><strong>Conc_choice2_</strong></p>

          <p>
                evaluate ((xs ∥ zs) ∪<sub>c</sub> (ys ∥ zs)) = evaluate ((xs
            ∪<sub>c</sub> ys) ∥ zs)
          </p>

          <hr />
          <p><strong>eval_specialize</strong></p>

          <p>    evaluate ys C ⊆<sub>p</sub> evaluate (y # ys) C</p>

          <hr />
          <p><strong>eval_specialize2</strong></p>

          <p>    evaluate [y] C ⊆<sub>p</sub> evaluate (y # ys) C</p>

          <hr />
          <p><strong>eval_specialize3</strong></p>

          <p>
                set xs ⊆ set [y] ⟹ evaluate xs C ⊆<sub>p</sub> evaluate [y] C
          </p>

          <hr />
          <p><strong>eval_specialize4</strong></p>

          <p>
                set [x] ⊆ set ys ⟹ evaluate [x] C ⊆<sub>p</sub> evaluate ys C
          </p>

          <hr />
          <p><strong>eval_specialize5</strong></p>

          <p>
                size xs &gt; 1 ⟹ equal_cnf xs zs ⟹ evaluate xs C = evaluate [ ]
            C ∪<sub>p</sub> evaluate zs C
          </p>

          <hr />
          <p><strong>eval_specialize6</strong></p>

          <p>
                size (ys @ zs) &gt; 1 ⟹ evaluate ys C ∪<sub>p</sub> evaluate zs
            C = evaluate (ys ∪<sub>c</sub> zs) C
          </p>

          <hr />
          <p><strong>eval_specialize7</strong></p>

          <p>
                size xs ≠ 1 ⟹ equal_cnf xs (ys ∪<sub>c</sub> zs) ⟹ evaluate xs C
            = evaluate ys C ∪<sub>p</sub> evaluate zs C
          </p>

          <hr />
          <p><strong>eval_specialize8</strong></p>

          <p>    evaluate [x. x ← xs, f x] C ⊆<sub>p</sub> evaluate xs C</p>

          <hr />
          <p><strong>eval_specialize9</strong></p>

          <p>
                evaluate [x. x ← (x#xx#xs), f x] C ∪<sub>p</sub> evaluate [x. x
            ← x#xx#xs, ¬f x] C = (evaluate [x] C ∪<sub>p</sub> evaluate [xx] C)
            ∪<sub>p</sub> (evaluate [x. x ← (xs), f x] C ∪<sub>p</sub> evaluate
            [x. x ← xs, ¬f x] C)
          </p>

          <hr />
          <p><strong>eval_specialize10</strong></p>

          <p>
                (evaluate [x] C ∪<sub>p</sub> evaluate [xx] C) ∪<sub>p</sub>
            (evaluate [x. x ← (xs), f x] C ∪<sub>p</sub> evaluate [x. x ← xs, ¬f
            x] C) = (evaluate [x] C ∪<sub>p</sub> evaluate [xx] C) ∪<sub>p</sub>
            (evaluate xs C)
          </p>

          <hr />
          <p><strong>eval_specialize11</strong></p>

          <p>
                size xs &gt; 1 ⟹ evaluate [x. x ← xs, f x] C ∪<sub>p</sub>
            evaluate [x. x ← xs, ¬f x] C = evaluate xs C
          </p>

          <hr />
          <p><strong>eval_specialize12</strong></p>

          <p>    set xs ⊆ set ys ⟹ evaluate xs C⊆<sub>p</sub> evaluate ys C</p>

          <hr />
          <p><strong>subset1</strong></p>

          <p>    set (p ;<sub>c</sub> xs) ⊆ set (p ;<sub>c</sub> (x#xs))</p>

          <hr />
          <p><strong>subset2</strong></p>

          <p>    set (xs ;<sub>c</sub> p) ⊆ set ((x#xs) ;<sub>c</sub> p)</p>

          <hr />
          <p><strong>subset3</strong></p>

          <p>    set (p ∪<sub>c</sub> xs) ⊆ set (p ∪<sub>c</sub> (x#xs))</p>

          <hr />
          <p><strong>subset4</strong></p>

          <p>    set (xs ∪<sub>c</sub> p) ⊆ set ((x#xs) ∪<sub>c</sub> p)</p>

          <hr />
          <p><strong>subset5</strong></p>

          <p>
                set q ⊆ set q’ ⟹ set (p ;<sub>c</sub> q) ⊆ set (p ;<sub>c</sub>
            q’)
          </p>

          <hr />
          <p><strong>subset6</strong></p>

          <p>
                set q ⊆ set q’ ⟹ set (q ;<sub>c</sub> p) ⊆ set (q’ ;<sub>c</sub>
            p)
          </p>

          <hr />
          <p><strong>subset7</strong></p>

          <p>
                set q ⊆ set q’ ⟹ set (p ∪<sub>c</sub> q) ⊆ set (p ∪<sub>c</sub>
            q’)
          </p>

          <hr />
          <p><strong>subset8</strong></p>

          <p>
                set q ⊆ set q’ ⟹ set (q ∪<sub>c</sub> p) ⊆ set (q’ ∪<sub>c</sub>
            p)
          </p>

          <hr />
          <p><strong>subset9</strong></p>

          <p>    set q ⊆ set q’ ⟹ set (p ∥ q) ⊆ set (p ∥ q’)</p>

          <hr />
          <p><strong>subset10</strong></p>

          <p>    set q ⊆ set q’ ⟹ set (q ∥ p) ⊆ set (q’ ∥ p)</p>

          <hr />
          <p><strong>interleav_prop</strong></p>

          <p>    ps @ rs ∈ set (ps ⫴ rs)</p>

          <hr />
          <p><strong>prop5</strong></p>

          <table>
            <tbody>
              <tr>
                <td>
                      set (map (λxs. xs @ [p]) (ps ⫴ (qs @ [q]))) = {tr @ [p]
                </td>
                <td>tr. tr ∈ set (ps ⫴ (qs @ [q]))}</td>
              </tr>
            </tbody>
          </table>

          <hr />
          <p><strong>prop6</strong></p>

          <table>
            <tbody>
              <tr>
                <td>
                      set (map (λxs. xs @ [q]) ((ps @ [p]) ⫴ qs )) = {tr @ [q]
                </td>
                <td>tr. tr ∈ set ((ps @ [p]) ⫴ qs)}</td>
              </tr>
            </tbody>
          </table>

          <hr />
          <p><strong>prop3_1</strong></p>

          <p>    [x] ⫴ ys = insert_all x ys</p>

          <hr />
          <p><strong>prop3_2</strong></p>

          <p>    ys ⫴ [x] = rev (insert_all x ys)</p>

          <hr />
          <p><strong>prop3_3</strong></p>

          <p>
                set ([x] ⫴ (y#ys)) = {x#y#ys} ∪ {y#x#ys} ∪ ((#) y) ` set ([x] ⫴
            ys)
          </p>

          <hr />
          <p><strong>prop3_4</strong></p>

          <p>
                set ([x] ⫴ (ys@[y])) = {ys@[x,y]} ∪ {ys@[y,x]} ∪ (λtr. tr@[y]) `
            set ([x] ⫴ ys)
          </p>

          <hr />
          <p><strong>prop3_5</strong></p>

          <p>
                set ([x] ⫴ rev (y#ys)) = {(rev ys)@[x,y]} ∪ {(rev ys)@[y,x]} ∪
            (λtr. tr@[y]) ` set ([x] ⫴ (rev ys))
          </p>

          <hr />
          <p><strong>prop3_6</strong></p>

          <table>
            <tbody>
              <tr>
                <td>    {rev tr</td>
                <td>tr. tr ∈ set ([x] ⫴ (ys))} = set ([x] ⫴ rev ys)</td>
              </tr>
            </tbody>
          </table>

          <hr />
          <p><strong>prop3_7</strong></p>

          <p>    rev ` set ([x] ⫴ ys) = set ([x] ⫴ rev ys)</p>

          <hr />
          <p><strong>prop3_8</strong></p>

          <p>    (λtr. tr @ [y]) ` set ([x] ⫴ ys) ⊆ set ([x] ⫴ (ys @ [y]))</p>

          <hr />
          <p><strong>prop3_9</strong></p>

          <p>
                tr ∈ set ([x] ⫴ rev ys) ⟹ tr @ [y] ∈ set ([x] ⫴ (rev ys @ [y]))
          </p>

          <hr />
          <p><strong>prop3_10</strong></p>

          <p>
                (map (λzs. zs@[y]) (insert_all x ys)) @ [ys@[y,x]] = insert_all
            x (ys@[y])
          </p>

          <hr />
          <p><strong>prop3_10_1</strong></p>

          <p>
                map (λtr. tr @ [y]) ([x] ⫴ ys) @ [ys@[y,x]] = insert_all x
            (ys@[y])
          </p>

          <hr />
          <p><strong>prop3_11</strong></p>

          <p>
                xa ∈ set ([x] ⫴ (rev ys @ [y])) ⟹ xa ∉ (λtr. tr @ [y]) ` set
            ([x] ⫴ rev ys) ⟹ xa = rev ys @ [y, x]
          </p>

          <hr />
          <p><strong>prop3_12</strong></p>

          <p>
                x≠y ⟹ set (map ((#) y) ((x#xs) ⫴ ys)) ∩ set (map ((#) x) (xs ⫴
            (y#ys))) = {}
          </p>

          <hr />
          <p><strong>prop3_13</strong></p>

          <p>
                x≠y ⟹ set (map ((#) x) (xs ⫴ (y#ys))) = set ((x#xs) ⫴ (y#ys)) -
            set (map ((#) y) ((x#xs) ⫴ ys))
          </p>

          <hr />
          <p><strong>prop3_14</strong></p>

          <p>
                (x#xs) ⫴ (x#ys) = map ((#) x) ((xs ⫴ (x#ys)) @ ((x#xs) ⫴ ys))
          </p>

          <hr />
          <p><strong>prop3_15</strong></p>

          <p>
                set [(xs @ [x, y])] ∪ (λtr. tr @ [x]) ` set ((xs ⫴ [y])) = set
            (((xs @ [x]) ⫴ [y]))
          </p>

          <hr />
          <p><strong>prop3_16</strong></p>

          <p>
                set (map (λtr. tr@[y]) (rev (x#xs) ⫴ rev ys)) ∪ set (map (λtr.
            tr@[x]) (rev xs ⫴ rev (y#ys))) = set (rev (x # xs) ⫴ rev (y # ys))
          </p>

          <hr />
          <p><strong>prop3</strong></p>

          <p>    set (map rev (xs ⫴ ys)) = set (rev xs ⫴ rev ys)</p>

          <hr />
          <p><strong>prop4</strong></p>

          <table>
            <tbody>
              <tr>
                <td>    set ((ps @ [p]) ⫴ (qs @ [q])) = {tr @ [p]</td>
                <td>tr. tr ∈ set (ps ⫴ (qs @ [q]))} ∪ {tr @ [q]</td>
                <td>tr. tr ∈ set ((ps @ [p]) ⫴ qs)}</td>
              </tr>
            </tbody>
          </table>

          <hr />
          <p><strong>prop7</strong></p>

          <p>
                set ((ps@[p]) ⫴ (qs@[q])) = set (map (λxs. xs@[p]) (ps ⫴
            (qs@[q])) @ map (λxs. xs@[q]) ((ps@[p]) ⫴ qs))
          </p>

          <hr />
          <p><strong>prop8</strong></p>

          <p>    xs ∈ set ys ⟹ xs@[x] ∈ set (map (λt. t@[x]) ys)</p>

          <hr />
          <p><strong>prop9</strong></p>

          <p>    xs ∈ set (p ⫴ q) ⟹ xs @ r ∈ set (p ⫴ (q @ r))</p>

          <hr />
          <p><strong>prop9_1</strong></p>

          <p>    xs ∈ set ((p ⫴ r)) ⟹ q @ xs ∈ set (p ⫴ (q @ r))</p>

          <hr />
          <p><strong>prop10</strong></p>

          <p>
                set ([p] ∥ [q] ;<sub>c</sub> [r]) ⊆ set ([p] ∥ ([q] ;<sub
              >c</sub
            >
            [r]))
          </p>

          <hr />
          <p><strong>prop10_1</strong></p>

          <p>
                set ([p] ∥ [r] ;<sub>c</sub> [q]) ⊆ set (([p] ;<sub>c</sub> [q])
            ∥ [r])
          </p>

          <hr />
          <p><strong>prop10_2</strong></p>

          <p>
                set ([q] ;<sub>c</sub> [p] ∥ [r]) ⊆ set ([p] ∥ ([q] ;<sub
              >c</sub
            >
            [r]))
          </p>

          <hr />
          <p><strong>prop10_3</strong></p>

          <p>
                set ([p] ;<sub>c</sub> [q] ∥ [r]) ⊆ set (([p] ;<sub>c</sub> [q])
            ∥ [r])
          </p>

          <hr />
          <p><strong>inter1</strong></p>

          <p>
                set ((ps ⫴ qs) ;<sub>c</sub> (rs ⫴ vs)) ⊆ set ((ps @ rs) ⫴ (qs @
            vs))
          </p>

          <hr />
          <p><strong>prop10_3_1</strong></p>

          <p>
                set ([p] ∥ [q] ;<sub>c</sub> [r] ∥ [v]) ⊆ set (([p] ;<sub
              >c</sub
            >
            [r]) ∥ ([q] ;<sub>c</sub> [v]))
          </p>

          <hr />
          <p><strong>prop10_4</strong></p>

          <p>
                set ([p] ∥ [q] ;<sub>c</sub> [r] ∥ vs) ⊆ set (([p] ;<sub>c</sub>
            [r]) ∥ ([q] ;<sub>c</sub> vs))
          </p>

          <hr />
          <p><strong>prop11</strong></p>

          <p>
                set ([p] ∥ qs ;<sub>c</sub> [r]) ⊆ set ([p] ∥ (qs ;<sub>c</sub>
            [r]))
          </p>

          <hr />
          <p><strong>prop12</strong></p>

          <p>
                set (([p] ∥ rs) ;<sub>c</sub> [q]) ⊆ set (([p] ;<sub>c</sub>
            [q]) ∥ rs)
          </p>

          <hr />
          <p><strong>prop13</strong></p>

          <p>
                set ([q] ;<sub>c</sub> [p] ∥ rs) ⊆ set ([p] ∥ ([q] ;<sub>c</sub>
            rs))
          </p>

          <hr />
          <p><strong>prop14</strong></p>

          <p>
                set ([p] ;<sub>c</sub> qs ∥ [r]) ⊆ set (([p] ;<sub>c</sub> qs) ∥
            [r])
          </p>

          <hr />
          <p><strong>prop15</strong></p>

          <p>
                set ([p] ∥ ([q]) ;<sub>c</sub> rs ∥ s) ⊆ set (([p] ;<sub>c</sub>
            rs) ∥ ([q] ;<sub>c</sub> s))
          </p>

          <hr />
          <p><strong>subset12</strong></p>

          <p>
                set (ps ∥ q ;<sub>c</sub> [r]) ⊆ set (ps ∥ (q ;<sub>c</sub>
            [r]))
          </p>

          <hr />
          <p><strong>subset13</strong></p>

          <p>
                set ((ps ∥ r) ;<sub>c</sub> [q]) ⊆ set ((ps ;<sub>c</sub> [q]) ∥
            r)
          </p>

          <hr />
          <p><strong>subset14</strong></p>

          <p>
                set ([q] ;<sub>c</sub> ps ∥ r) ⊆ set (ps ∥ ([q] ;<sub>c</sub>
            r))
          </p>

          <hr />
          <p><strong>subset15</strong></p>

          <p>
                set ([p] ;<sub>c</sub> q ∥ rs) ⊆ set (([p] ;<sub>c</sub> q) ∥
            rs)
          </p>

          <hr />
          <p><strong>subset16</strong></p>

          <p>
                set ([p] ∥ qs ;<sub>c</sub> r ∥ s) ⊆ set (([p] ;<sub>c</sub> r)
            ∥ (qs ;<sub>c</sub> s))
          </p>

          <hr />
          <p><strong>Conc_composeright_1</strong></p>

          <p>
                set ((p ∥ q) ;<sub>c</sub> rs) ⊆ set (p ∥ (q ;<sub>c</sub> rs))
          </p>

          <hr />
          <p><strong>Conc_composeright1_1</strong></p>

          <p>
                set ((p ∥ r) ;<sub>c</sub> qs) ⊆ set ((p ;<sub>c</sub> qs) ∥ r)
          </p>

          <hr />
          <p><strong>Conc_composeleft1_1</strong></p>

          <p>
                set (qs ;<sub>c</sub> (p ∥ r)) ⊆ set (p ∥ (qs ;<sub>c</sub> r))
          </p>

          <hr />
          <p><strong>Conc_composeright_2</strong></p>

          <p>
                set (ps ;<sub>c</sub> (q ∥ r)) ⊆ set ((ps ;<sub>c</sub> q) ∥ r)
          </p>

          <hr />
          <p><strong>Conc_composeleft</strong></p>

          <p>
                evaluate ((p ∥ q) ;<sub>c</sub> r) C ⊆<sub>p</sub> evaluate (p ∥
            (q ;<sub>c</sub> r)) C
          </p>

          <hr />
          <p><strong>Conc_composeleftright</strong></p>

          <p>
                evaluate (q ;<sub>c</sub> (p ∥ r)) C ⊆<sub>p</sub> evaluate (p ∥
            (q ;<sub>c</sub> r)) C
          </p>

          <hr />
          <p><strong>Conc_composeright</strong></p>

          <p>
                evaluate (p ;<sub>c</sub> (q ∥ r)) C ⊆<sub>p</sub> evaluate ((p
            ;<sub>c</sub> q) ∥ r) C
          </p>

          <hr />
          <p><strong>Conc_composerightleft</strong></p>

          <p>
                evaluate ((p ∥ r) ;<sub>c</sub> q) C ⊆<sub>p</sub> evaluate ((p
            ;<sub>c</sub> q) ∥ r) C
          </p>

          <hr />
          <p><strong>Conc_composegeneral</strong></p>

          <p>
                set (([p] ;<sub>c</sub> [q]) ∥ ([u] ;<sub>c</sub> [v])) ⊆ set
            (([p] ;<sub>c</sub> [u]) ∥ ([q] ;<sub>c</sub> [v]))
          </p>

          <hr />
          <p><strong>Conc_composegeneral</strong></p>

          <p>
                set (([p] ;<sub>c</sub> [u]) ∥ ([q] ;<sub>c</sub> [v])) ⊆ set
            (([p] ;<sub>c</sub> [q]) ∥ ([u] ;<sub>c</sub> [v]))
          </p>

          <hr />
          <p><strong>Conc_composegeneral</strong></p>

          <p>
                set ((p ;<sub>c</sub> q) ∥ (u ;<sub>c</sub> v)) ⊆ set ((p ;<sub
              >c</sub
            >
            u) ∥ (q ;<sub>c</sub> v))
          </p>

          <hr />
          <p><strong>Conc_composegeneral_1</strong></p>

          <p>
                set ((ps ∥ q) ;<sub>c</sub> (r ∥ s)) ⊆ set ((ps ;<sub>c</sub> r)
            ∥ (q ;<sub>c</sub> s))
          </p>

          <hr />
          <p><strong>Conc_composegeneral</strong></p>

          <p>
                evaluate ((p ∥ q) ;<sub>c</sub> (r ∥ s)) C ⊆<sub>p</sub>
            evaluate ((p ;<sub>c</sub> r) ∥ (q ;<sub>c</sub> s)) C
          </p>

          <hr />
          <p>    foldl (+) (b::nat) xs = b + foldl (+) 0 xs</p>

          <hr />
          <p><strong>cnf_prop1</strong></p>

          <p>    cnf_concurrency2 [[x]] [[y]] C = evaluate ([x] ⫴ [y]) C</p>

          <hr />
          <p>
                is_rounded a ⟹ (a;b) ∪<sub>p</sub> (a;c) = a;(b ∪<sub>p</sub> c)
          </p>

          <hr />
          <p><strong>cnf2_prop</strong></p>

          <p>
                cnf_feasible ([y]#ys) ⟹ complete_cnf_state ([y]#ys) ⊆ C ⟹ ⋃<sub
              >p</sub
            >
            (map ((λxs. Concat xs C) ∘ (#) y) (ys)) ≡<sub>p</sub> y ; ⋃<sub
              >p</sub
            >
            (map (λxs. Concat xs C) (ys))
          </p>

          <hr />
          <p><strong>cnf2_prop2</strong></p>

          <p>
                cnf_feasible xs ⟹ is_feasible x ⟹ cnf_feasible (map ((#) x)
            (xs))
          </p>

          <hr />
          <p><strong>cnf2_prop3</strong></p>

          <p>    cnf_feasible xs ⟹ cnf_feasible ys ⟹ cnf_feasible (xs@ys)</p>

          <hr />
          <p><strong>cnf2_prop4</strong></p>

          <p>    all_feasible (xs@ys) ⟹ cnf_feasible (xs ⫴ ys)</p>

          <hr />
          <p><strong>cnf2_prop5</strong></p>

          <p>
                xs ≠ [ ] ⟹ complete_cnf_state (map ((#) x) xs) = S x ∪
            complete_cnf_state xs
          </p>

          <hr />
          <p><strong>cnf2_prop6</strong></p>

          <p>
                complete_cnf_state xs ∪ complete_cnf_state ys =
            complete_cnf_state (xs@ys)
          </p>

          <hr />
          <p><strong>cnf2_prop7</strong></p>

          <p>
                complete_state xs ∪ complete_state ys = complete_cnf_state (xs ⫴
            ys)
          </p>

          <hr />
          <p><strong>cnf2_prop8</strong></p>

          <p>
                S y ⊆ C ⟹ is_feasible y ⟹ ⋃<sub>p</sub> (map ((λxs. Concat xs C)
            ∘ (#) y) ys) ≡<sub>p</sub> ⋃<sub>p</sub> (map (λxs. y ; Concat xs C)
            ys)
          </p>

          <hr />
          <p><strong>cnf2_prop9</strong></p>

          <p>
                ⋃<sub>p</sub> (map (λxs. y ; Concat xs C) xs) ≡<sub>p</sub> y ;
            ⋃<sub>p</sub> (map (λxs. Concat xs C) xs)
          </p>

          <hr />
          <p><strong>cnf2_prop10</strong></p>

          <p>
                is_feasible y ⟹ S y ⊆ C ⟹ y ; ⋃<sub>p</sub> (map (λxs. Concat xs
            C) ([x] ⫴ ys)) ≡<sub>p</sub> ⋃<sub>p</sub> (map ((λxs. Concat xs C)
            ∘ (#) y) ([x] ⫴ ys))
          </p>

          <hr />
          <p><strong>cnf2_prop11</strong></p>

          <p>
                size xs = size ys ⟹ ∀z ∈ set (zip xs ys). fst z ≡<sub>p</sub>
            snd z ⟹ ⋃<sub>p</sub> xs ≡<sub>p</sub> ⋃<sub>p</sub> ys
          </p>

          <hr />
          <p><strong>cnf2_prop12</strong></p>

          <p>
                is_feasible x ⟹ S x ⊆ C ⟹ evaluate (map ((#) x) xs) C ≡<sub
              >p</sub
            >
            x ; evaluate xs C
          </p>

          <hr />
          <p><strong>cnf_prop5</strong></p>

          <p>
                all_feasible (xs@ys) ⟹ complete_state (xs@ys) ⊆ C ⟹
            cnf_concurrency2 [xs] [ys] C ≡<sub>p</sub> evaluate (xs ⫴ ys) C
          </p>

          <hr />
          <p><strong>cnf_prop3</strong></p>

          <p>
                all_feasible (x#ys) ⟹ complete_state (x#ys) ⊆ C ⟹
            cnf_concurrency2 [[x]] [ys] C ≡<sub>p</sub> evaluate ([x] ⫴ ys) C
          </p>

          <hr />
          <p><strong>cnf2_prop13</strong></p>

          <p>
                all_feasible (x#xs@[y]) ⟹ complete_state (x#xs@[y]) ⊆ C ⟹ x ;
            cnf_concurrency2 [xs] [[y]] C ≡<sub>p</sub> evaluate (map ((#) x)
            (xs ⫴ [y])) C
          </p>

          <hr />
          <p><strong>cnf2_prop14</strong></p>

          <p>
                all_feasible (xs@ys) ⟹ complete_state (xs@ys) ⊆ C ⟹
            cnf_concurrency2 [xs] [ys] C ≡<sub>p</sub> evaluate ([xs] ∥ [ys]) C
          </p>

          <hr />
          <p><strong>cnf2_prop15</strong></p>

          <p>
                cnf_feasible (x#ys) ⟹ complete_cnf_state (x#ys) ⊆ C ⟹
            cnf_concurrency2 [x] ys C ≡<sub>p</sub> evaluate(concat (map ((⫴) x)
            ys)) C
          </p>

          <hr />
          <p><strong>cnf2_prop16</strong></p>

          <p>    cnf_feasible (xs @ ys) ⟹ cnf_feasible ys</p>

          <hr />
          <p><strong>cnf2_prop17</strong></p>

          <p>    cnf_feasible (xs @ ys) ⟹ cnf_feasible xs</p>

          <hr />
          <p>
                cnf_feasible (xs @ ys) ⟹ complete_cnf_state (xs @ ys) ⊆ C ⟹
            cnf_concurrency2 xs ys C ≡<sub>p</sub> evaluate (xs ∥ ys) C
          </p>

          <hr />
          <h2 id="complex_operation_interactionsthy">
            Complex_operation_interactions.thy
          </h2>

          <p><strong>cond_distrib2_1</strong></p>

          <p>
                GC [(C<sub>1</sub>, p), (C<sub>2</sub>, q)] /<sub>p</sub> D = GC
            [((D ∩ C<sub>1</sub>), p), ((D ∩ C<sub>2</sub>), q)]
          </p>

          <hr />
          <p><strong>Cond_distrib2_2</strong></p>

          <p>
                GC [(C<sub>1</sub>, p), (C<sub>2</sub>, q)] /<sub>p</sub> D
            ≡<sub>p</sub> GC [((D ∩ C<sub>1</sub>), p), ((D ∩ C<sub>2</sub>),
            q)]
          </p>

          <hr />
          <p><strong>restriction_ite</strong></p>

          <p>
                (ITE C a b) /<sub>p</sub> D = (ITE C (a/<sub>p</sub>D)
            (b/<sub>p</sub>D))
          </p>

          <hr />
          <p><strong>restriction_ite</strong></p>

          <p>
                (ITE C a b) /<sub>p</sub> D = (ITE C (a/<sub>p</sub>D)
            (b/<sub>p</sub>D))
          </p>

          <hr />
          <p><strong>restriction_ite</strong></p>

          <p>
                (ITE C a b) /<sub>p</sub> D ≡<sub>p</sub> (ITE C
            (a/<sub>p</sub>D) (b/<sub>p</sub>D))
          </p>

          <hr />
          <p><strong>restriction_fixed_repetition_1</strong></p>

          <p>
                0&lt;n ⟹ (p<sup>n + 1</sup>) /<sub>p</sub> C ≡<sub>p</sub> (p
            /<sub>p</sub> C);(p<sup>n</sup>)
          </p>

          <hr />
          <p><strong>restriction_fixed_repetition_2</strong></p>

          <p>
                is_feasible p ⟹ (p<sup>n</sup>) /<sub>p</sub> C ≡<sub>p</sub>
            (Skip (S p) /<sub>p</sub> C);(p<sup>n</sup>)
          </p>

          <hr />
          <p><strong>restriction_fixed_repetition_3</strong></p>

          <p>
                (p<sup>n</sup>) /<sub>p</sub> C ≡<sub>p</sub> (Skip
            C);(p<sup>n</sup>)
          </p>

          <hr />
          <p>
                loop p s f /<sub>p</sub> C ≡<sub>p</sub> Skip C ; loop p s f
          </p>

          <hr />
          <p><strong>cond_distrib1_gc_1</strong></p>

          <p>
                GC [(C<sub>1</sub>, p<sub>1</sub>), (C<sub>2</sub>, (p<sub
              >2</sub
            >
            ∪<sub>p</sub> p<sub>3</sub>))] = (GC [(C<sub>1</sub>,
            p<sub>1</sub>), (C<sub>2</sub>, p<sub>2</sub>)]) ∪<sub>p</sub> (GC
            [(C<sub>1</sub>, p<sub>1</sub>), (C<sub>2</sub>, p<sub>3</sub>)])
          </p>

          <hr />
          <p><strong>cond_distrib1_gc_2</strong></p>

          <p>
                GC [(C<sub>1</sub>, p<sub>1</sub>), (C<sub>2</sub>, (p<sub
              >2</sub
            >
            ∪<sub>p</sub> p<sub>3</sub>))] ≡<sub>p</sub> (GC [(C<sub>1</sub>,
            p<sub>1</sub>), (C<sub>2</sub>, p<sub>2</sub>)]) ∪<sub>p</sub> (GC
            [(C<sub>1</sub>, p<sub>1</sub>), (C<sub>2</sub>, p<sub>3</sub>)])
          </p>

          <hr />
          <p><strong>cond_distrib1_gc_3</strong></p>

          <p>
                GC [(C<sub>1</sub>, (p<sub>1</sub> ∪<sub>p</sub>
            p<sub>3</sub>)), (C<sub>2</sub>, p<sub>2</sub>)] = GC
            [(C<sub>1</sub>, p<sub>1</sub>), ( C<sub>2</sub>, p<sub>2</sub>)]
            ∪<sub>p</sub> GC [(C<sub>1</sub>, p<sub>3</sub>), ( C<sub>2</sub>,
            p<sub>2</sub>)]
          </p>

          <hr />
          <p><strong>cond_distrib1_gc_4</strong></p>

          <p>
                GC [(C<sub>1</sub>, (p<sub>1</sub> ∪<sub>p</sub>
            p<sub>3</sub>)), ( C<sub>2</sub>, p<sub>2</sub>)] ≡<sub>p</sub> GC
            [(C<sub>1</sub>, p<sub>1</sub>), ( C<sub>2</sub>, p<sub>2</sub>)]
            ∪<sub>p</sub> GC [(C<sub>1</sub>, p<sub>3</sub>), ( C<sub>2</sub>,
            p<sub>2</sub>)]
          </p>

          <hr />
          <p><strong>cond_distrib1_ite_1</strong></p>

          <p>
                (ITE C p<sub>1</sub> (p<sub>2</sub> ∪<sub>p</sub>
            p<sub>3</sub>)) = (ITE C p<sub>1</sub> p<sub>2</sub>) ∪<sub>p</sub>
            (ITE C p<sub>1</sub> p<sub>3</sub>)
          </p>

          <hr />
          <p><strong>cond_distrib1_ite_2</strong></p>

          <p>
                (ITE C p<sub>1</sub> (p<sub>2</sub> ∪<sub>p</sub>
            p<sub>3</sub>)) ≡<sub>p</sub> (ITE C p<sub>1</sub> p<sub>2</sub>)
            ∪<sub>p</sub> (ITE C p<sub>1</sub> p<sub>3</sub>)
          </p>

          <hr />
          <p><strong>cond_distrib1_ite_3</strong></p>

          <p>
                (ITE C (p<sub>1</sub> ∪<sub>p</sub> p<sub>2</sub>)
            p<sub>3</sub>) = (ITE C p<sub>1</sub> p<sub>3</sub>) ∪<sub>p</sub>
            (ITE C p<sub>2</sub> p<sub>3</sub>)
          </p>

          <hr />
          <p><strong>cond_distrib1_ite_4</strong></p>

          <p>
                (ITE C (p<sub>1</sub> ∪<sub>p</sub> p<sub>2</sub>)
            p<sub>3</sub>) ≡<sub>p</sub> (ITE C p<sub>1</sub> p<sub>3</sub>)
            ∪<sub>p</sub> (ITE C p<sub>2</sub> p<sub>3</sub>)
          </p>

          <hr />
          <p><strong>guard_ifthenelse</strong></p>

          <p>
                ITE C p<sub>1</sub> p<sub>2</sub> = GC [(C, p<sub>1</sub>),
            ((-C), p<sub>2</sub>)]
          </p>

          <hr />
          <p><strong>until_def_lemma</strong></p>

          <p>
                until_loop a C b n ≡<sub>p</sub> a;(loop (b/<sub>p</sub>(-C)) 0
            n)∖<sub>p</sub>C
          </p>

          <hr />
          <h2 id="fixed_repetitionthy">Fixed_repetition.thy</h2>

          <p><strong>state_space_is_same</strong></p>

          <p>    S p = S (p <sup> </sup>n)</p>

          <hr />
          <p><strong>state_space_is_same2</strong></p>

          <p>    State (p<sup>n</sup>) = S p</p>

          <hr />
          <p><strong>fixed_pre_decreases</strong></p>

          <p>    Pre (p<sup>n + 1</sup>) ⊆ Pre (p<sup>n</sup>)</p>

          <hr />
          <p><strong>fixed_rep_one_1</strong></p>

          <p>    p<sup>1</sup> ≡<sub>p</sub> p /<sub>p</sub> (Pre p)</p>

          <hr />
          <p><strong>fixed_rep_one_2</strong></p>

          <p>    is_feasible p ⟹ p<sup>1</sup> ≡<sub>p</sub> p</p>

          <hr />
          <p><strong>fixed_rep_one_3</strong></p>

          <p>    x;p<sup>1</sup> ≡<sub>p</sub> x;p</p>

          <hr />
          <p><strong>fixed_rep_two_1</strong></p>

          <p>    p<sup>2</sup> ≡<sub>p</sub> p ; p</p>

          <hr />
          <p><strong>fixed_rep_decomp_front</strong></p>

          <p>    0&lt;i ⟹ p<sup>i + 1</sup> ≡<sub>p</sub> p;p<sup>i</sup></p>

          <hr />
          <p><strong>fixed_rep_decomp_back</strong></p>

          <p>
                is_feasible p ⟹ p<sup>i + 1</sup> ≡<sub>p</sub> p<sup>i</sup>;p
          </p>

          <hr />
          <p><strong>fixed_rep_feasibility</strong></p>

          <p>    is_feasible p ⟹ is_feasible (p<sup>n</sup>)</p>

          <hr />
          <p><strong>fixed_rep_prop_2</strong></p>

          <p>    p<sup>i + 1</sup> ≡<sub>p</sub> p<sup>i</sup>;p</p>

          <hr />
          <p><strong>range_decreases_fixed_repetition</strong></p>

          <p>    0 &lt; n ⟹ Range_p (x <sup> </sup>n) ⊆ Range_p x</p>

          <hr />
          <p><strong>range_decreases_fixed_repetition_2</strong></p>

          <p>
                0 &lt; n ⟹ Range_p (x <sup> </sup>n + 1) ⊆ Range_p (x
            <sup> </sup>n)
          </p>

          <hr />
          <p><strong>fixed_prop</strong></p>

          <p>    x<sup>1</sup> = Skip (Pre x) ; x</p>

          <hr />
          <p><strong>skip_choice</strong></p>

          <p>
                Skip (Pre x) ; x ∪<sub>p</sub> Skip (Pre y) ; y = Skip (Pre x ∪
            Pre y) ; (x ∪<sub>p</sub> y)
          </p>

          <hr />
          <p><strong>comp_prop</strong></p>

          <p>
                Range_p a ∩ Pre d = {} ⟹ Range_p c ∩ Pre b = {} ⟹ a;b ∪<sub
              >p</sub
            >
            c;d = (a ∪<sub>p</sub> c);(b ∪<sub>p</sub> d)
          </p>

          <hr />
          <p><strong>arbitrary_repetition_simplification</strong></p>

          <p>
                0&lt;n ⟹ all_feasible [x,y] ⟹ Range_p x ∩ Pre y = {} ⟹ Range_p y
            ∩ Pre x = {} ⟹ x<sup>n</sup> ∪<sub>p</sub> y<sup>n</sup> = (x ∪<sub
              >p</sub
            >
            y)<sup>n</sup>
          </p>

          <hr />
          <p><strong>arbitrary_repetition_simplification2</strong></p>

          <p>
                0&lt;n ⟹ all_feasible [x,y] ⟹ Range_p x ∩ Pre y = {} ⟹ Range_p y
            ∩ Pre x = {} ⟹ x<sup>n</sup> ∪<sub>p</sub> y<sup>n</sup> ≡<sub
              >p</sub
            >
            (x ∪<sub>p</sub> y)<sup>n</sup>
          </p>

          <hr />
          <p><strong>equality_is_maintained_by_fixed_repetition</strong></p>

          <p>
                p<sub>1</sub> = p<sub>2</sub> ⟹ p<sub>1</sub><sup>n</sup> =
            p<sub>2</sub><sup>n</sup>
          </p>

          <hr />
          <p><strong>equiv_is_maintained_by_fixed_repetition</strong></p>

          <p>
                0&lt;n ⟹ all_feasible [p<sub>1</sub>, p<sub>2</sub>] ⟹ p<sub
              >1</sub
            >
            ≡<sub>p</sub> p<sub>2</sub> ⟹ p<sub>1</sub><sup>n</sup> ≡<sub
              >p</sub
            >
            p<sub>2</sub><sup>n</sup>
          </p>

          <hr />
          <p><strong>skip_compose_r_of_fixed_rep_1</strong></p>

          <p>
                is_feasible p ⟹ p<sup>n</sup> ≡<sub>p</sub> p<sup>n</sup> ; Skip
            (S p)
          </p>

          <hr />
          <p><strong>skip_compose_l_of_fixed_rep_1</strong></p>

          <p>    p<sup>n</sup> ≡<sub>p</sub> Skip (S p) ; p<sup>n</sup></p>

          <hr />
          <p><strong>fail_stays_fail_fixed</strong></p>

          <p>
                p<sup>n</sup> ≡<sub>p</sub> Fail {} ⟹ p<sup>n</sup> + 1 ≡<sub
              >p</sub
            >
            Fail {}
          </p>

          <hr />
          <p><strong>repetition_fail</strong></p>

          <p>
                i&lt;j ⟹ p<sup>i</sup> ≡<sub>p</sub> Fail {} ⟹ p<sup>j</sup>
            ≡<sub>p</sub> Fail {}
          </p>

          <hr />
          <p><strong>fix_rep_prop1</strong></p>

          <p>
                0&lt;i ⟹ p<sup>i</sup> = Skip (S p) /<sub>p</sub> (Pre p) ;
            Concat [p . t ← [1 .. int i]] (S p)
          </p>

          <hr />
          <p><strong>fix_rep_prop2</strong></p>

          <p>
                p<sup>i</sup> = Concat ((Skip (S p) /<sub>p</sub> (Pre p))#[p .
            t ← [1 .. int i]]) (S p)
          </p>

          <hr />
          <h2 id="guarded_conditionalthy">Guarded_conditional.thy</h2>

          <p><strong>gc_S</strong></p>

          <p>    S (GC ((C,p)#xs)) = S p ∪ S (GC xs)</p>

          <hr />
          <p><strong>gc_S_1</strong></p>

          <p>    S (GC (xs)) = complete_state ([snd t. t ← (xs)])</p>

          <hr />
          <p><strong>cond_helper_1</strong></p>

          <p>    GC (x#xs) = GC (xs @ [x])</p>

          <hr />
          <p><strong>cond_helper_2</strong></p>

          <p>    xs≠[ ] ⟹ GC (x#xs) = GC [x] ∪<sub>p</sub> GC xs</p>

          <hr />
          <p><strong>cond_helper_3</strong></p>

          <p>    a ≠[ ] ⟹ b≠ [ ] ⟹ GC (a@b) = GC a ∪<sub>p</sub> GC b</p>

          <hr />
          <p><strong>cond_commute</strong></p>

          <p>    xs ∈ set (permutations ys) ⟹ GC xs = GC ys</p>

          <hr />
          <p><strong>cond_sub1</strong></p>

          <p>
                D<sub>1</sub> ⊆ C<sub>1</sub> ⟹ D<sub>2</sub> ⊆ C<sub>2</sub> ⟹
            (GC [(D<sub>1</sub>, p), (D<sub>2</sub>, q)]) ⊆<sub>p</sub> (GC
            [(C<sub>1</sub>, p), (C<sub>2</sub>, q)])
          </p>

          <hr />
          <p><strong>property_on_gc_3</strong></p>

          <p>
                all_feasible [p<sub>1</sub>, p<sub>2</sub>] ⟹ GC
            [(C<sub>1</sub>, p<sub>1</sub>), (C<sub>2</sub>, p<sub>2</sub>)]
            ⊑<sub>p</sub> p<sub>1</sub> /<sub>p</sub> C<sub>1</sub>
          </p>

          <hr />
          <p><strong>property_on_gc_3_1</strong></p>

          <p>
                weakens (GC [(C<sub>1</sub>, p<sub>1</sub>), (C<sub>2</sub>,
            p<sub>2</sub>)]) (p<sub>1</sub> /<sub>p</sub> C<sub>1</sub>)
          </p>

          <hr />
          <p><strong>property_on_gc_3_2</strong></p>

          <p>
                strengthens (p<sub>1</sub> /<sub>p</sub> C<sub>1</sub>) (GC
            [(C<sub>1</sub>, p<sub>1</sub>), (C<sub>2</sub>, p<sub>2</sub>)])
          </p>

          <hr />
          <p><strong>cond_sub4</strong></p>

          <p>
                (p<sub>1</sub> /<sub>p</sub> C<sub>1</sub>) ⊆<sub>p</sub> (GC
            [(C<sub>1</sub>, p<sub>1</sub>), (C<sub>2</sub>, p<sub>2</sub>)])
          </p>

          <hr />
          <p><strong>refinement_safety_gc_1</strong></p>

          <p>
                all_feasible [p, q] ⟹ D<sub>1</sub> ⊆ C<sub>1</sub> ⟹ D<sub
              >2</sub
            >
            ⊆ C<sub>2</sub> ⟹ GC [(D<sub>1</sub>, p), (D<sub>2</sub>, q)] ⊑<sub
              >p</sub
            >
            GC [(C<sub>1</sub>, p), (C<sub>2</sub>, q)]
          </p>

          <hr />
          <p><strong>refinement_safety_gc_2</strong></p>

          <p>
                all_feasible [p, q] ⟹ D<sub>1</sub> ⊆ C<sub>1</sub> ⟹ D<sub
              >2</sub
            >
            ⊆ C<sub>2</sub> ⟹ GC [(C<sub>1</sub>, p), (C<sub>2</sub>, q)] ⊑<sub
              >p</sub
            >
            GC [(D<sub>1</sub>, p), (D<sub>2</sub>, q)]
          </p>

          <hr />
          <p><strong>refinement_safety_gc_weakens</strong></p>

          <p>
                D<sub>1</sub> ⊆ C<sub>1</sub> ⟹ D<sub>2</sub> ⊆ C<sub>2</sub> ⟹
            weakens (GC [(C<sub>1</sub>, p), (C<sub>2</sub>, q)]) (GC
            [(D<sub>1</sub>, p), (D<sub>2</sub>, q)])
          </p>

          <hr />
          <p><strong>refinement_safety_gc_strengthens</strong></p>

          <p>
                D<sub>1</sub> ⊆ C<sub>1</sub> ⟹ D<sub>2</sub> ⊆ C<sub>2</sub> ⟹
            strengthens (GC [(D<sub>1</sub>, p), (D<sub>2</sub>, q)]) (GC
            [(C<sub>1</sub>, p), (C<sub>2</sub>, q)])
          </p>

          <hr />
          <p><strong>cond_refine1</strong></p>

          <p>
                D<sub>1</sub> ⊆ C<sub>1</sub> ⟹ D<sub>2</sub> ⊆ C<sub>2</sub> ⟹
            (GC [(D<sub>1</sub>, p), (D<sub>2</sub>, q)]) ⊑<sub>p</sub> (GC
            [(C<sub>1</sub>, p), (C<sub>2</sub>, q)])
          </p>

          <hr />
          <p><strong>cond_refine2</strong></p>

          <p>
                q<sub>1</sub> ⊑<sub>p</sub> p<sub>1</sub> ⟹ q<sub>2</sub> ⊑<sub
              >p</sub
            >
            p<sub>2</sub> ⟹ GC [(C, q<sub>1</sub>), (C, q<sub>2</sub>)] ⊑<sub
              >p</sub
            >
            GC [(C, p<sub>1</sub>), (C, p<sub>2</sub>)]
          </p>

          <hr />
          <p><strong>refinement_safety_gc_3</strong></p>

          <p>
                all_feasible [p<sub>1</sub>, p<sub>2</sub>, q<sub>1</sub>,
            q<sub>2</sub>] ⟹ strengthens q<sub>1</sub> p<sub>2</sub> ⟹
            strengthens q<sub>2</sub> p<sub>1</sub> ⟹ q<sub>1</sub> ⊑<sub
              >p</sub
            >
            p<sub>1</sub> ⟹ q<sub>2</sub> ⊑<sub>p</sub> p<sub>2</sub> ⟹ GC [(C,
            q<sub>1</sub>), (C, q<sub>2</sub>)] ⊑<sub>p</sub> GC [(C,
            p<sub>1</sub>), (C, p<sub>2</sub>)]
          </p>

          <hr />
          <p><strong>refinement_safety_gc_4</strong></p>

          <p>
                all_feasible [p<sub>1</sub>, p<sub>2</sub>, q<sub>1</sub>,
            q<sub>2</sub>] ⟹ independent q<sub>1</sub> p<sub>2</sub> ⟹
            independent q<sub>2</sub> p<sub>1</sub> ⟹ q<sub>1</sub> ⊑<sub
              >p</sub
            >
            p<sub>1</sub> ⟹ q<sub>2</sub> ⊑<sub>p</sub> p<sub>2</sub> ⟹ GC [(C,
            q<sub>1</sub>), (C, q<sub>2</sub>)] ⊑<sub>p</sub> GC [(C,
            p<sub>1</sub>), (C, p<sub>2</sub>)]
          </p>

          <hr />
          <p><strong>cond_refine4</strong></p>

          <p>
                GC [(C<sub>1</sub>, p<sub>1</sub>), (C<sub>2</sub>,
            p<sub>2</sub>)] ⊑<sub>p</sub> p<sub>1</sub> /<sub>p</sub> C<sub
              >1</sub
            >
          </p>

          <hr />
          <p><strong>cond_sub2</strong></p>

          <p>
                q<sub>1</sub> ⊆<sub>p</sub> p<sub>1</sub> ⟹ q<sub>2</sub> ⊆<sub
              >p</sub
            >
            p<sub>2</sub> ⟹ GC [(C, q<sub>1</sub>), (C, q<sub>2</sub>)] ⊆<sub
              >p</sub
            >
            GC [(C, p<sub>1</sub>), (C, p<sub>2</sub>)]
          </p>

          <hr />
          <p><strong>cond_distrib</strong></p>

          <p>
                GC xs /<sub>p</sub> C ≡<sub>p</sub> GC [(fst t ∩ C, snd t) . t ←
            xs]
          </p>

          <hr />
          <p><strong>GC_prop_22</strong></p>

          <p>
                a ∪<sub>p</sub> GC (x#xs) = a ∪<sub>p</sub> (GC [x] ∪<sub
              >p</sub
            >
            GC xs)
          </p>

          <hr />
          <p><strong>gc_prop1</strong></p>

          <p>
                S (snd x) ⊆ complete_state (map snd xs) ⟹ fst x = FALSE ⟹ 1 &lt;
            length xs ⟹ GC (x # xs) = GC xs
          </p>

          <hr />
          <p><strong>gc_prop2</strong></p>

          <p>
                S (snd x) ⊆ complete_state (map snd (a@b)) ⟹ fst x = FALSE ⟹
            size (a@b) &gt; 1 ⟹ GC (a@x#b) = GC(a@b)
          </p>

          <hr />
          <p><strong>if_false2</strong></p>

          <p>    fst x = FALSE ⟹ GC (a@x#b) ≡<sub>p</sub> GC(a@b)</p>

          <hr />
          <p><strong>gc_prop4</strong></p>

          <p>
                S (snd x) ⊆ complete_state (map snd (a@b)) ⟹ fst x = FALSE ⟹
            size (a@b) = 0 ⟹ GC (a@x#b) = GC(a@b)
          </p>

          <hr />
          <p><strong>fail_choice</strong></p>

          <p>
                S q ⊆ S p ⟹ q ≡<sub>p</sub> Fail {} ⟹ q ∪<sub>p</sub> p = Fail
            {} ∪<sub>p</sub> p
          </p>

          <hr />
          <p><strong>gc_prop5</strong></p>

          <p>
                S (snd x) ⊆ complete_state (map snd (a@b)) ⟹ fst x = FALSE ⟹
            size (a@b) = 1 ⟹ GC (a@x#b) = Fail {} ∪<sub>p</sub> GC(a@b)
          </p>

          <hr />
          <p><strong>cond_one</strong></p>

          <p>    GC [(C,p)] = p/<sub>p</sub>C</p>

          <hr />
          <p><strong>gc_prop6</strong></p>

          <p>    x /<sub>p</sub> C ⊆<sub>p</sub> GC ((C,x) # xs)</p>

          <hr />
          <p><strong>gc_prop7</strong></p>

          <p>    GC a ⊆<sub>p</sub> GC (a@b)</p>

          <hr />
          <p><strong>cond_sub3</strong></p>

          <p>    (C, x) ∈ set (xs) ⟹ x/<sub>p</sub>C ⊆<sub>p</sub> GC xs</p>

          <hr />
          <h2 id="if_then_elsethy">If_then_else.thy</h2>

          <p><strong>ite_S</strong></p>

          <p>
                S (ITE C q<sub>1</sub> q<sub>2</sub>) = S q<sub>1</sub> ∪ S
            q<sub>2</sub>
          </p>

          <hr />
          <p><strong>cond_swap</strong></p>

          <p>
                ITE C p<sub>1</sub> p<sub>2</sub> = ITE (-C) p<sub>2</sub> p<sub
              >1</sub
            >
          </p>

          <hr />
          <p><strong>property_on_ite_2</strong></p>

          <p>    Pre (p /<sub>p</sub> C) = Pre (ITE C p (Skip (S p)))</p>

          <hr />
          <p><strong>cond_refine3</strong></p>

          <p>
                q<sub>1</sub> ⊑<sub>p</sub> p<sub>1</sub> ⟹ q<sub>2</sub> ⊑<sub
              >p</sub
            >
            p<sub>2</sub> ⟹ ITE C q<sub>1</sub> q<sub>2</sub> ⊑<sub>p</sub> ITE
            C p<sub>1</sub> p<sub>2</sub>
          </p>

          <hr />
          <p><strong>cond_refine4</strong></p>

          <p>
                q<sub>1</sub> ⊆<sub>p</sub> p<sub>1</sub> ⟹ q<sub>2</sub> ⊆<sub
              >p</sub
            >
            p<sub>2</sub> ⟹ ITE C q<sub>1</sub> q<sub>2</sub> ⊆<sub>p</sub> ITE
            C p<sub>1</sub> p<sub>2</sub>
          </p>

          <hr />
          <h2 id="non_atomic_concurrencythy">Non_atomic_concurrency.thy</h2>

          <p><strong>non_atomic_prop1</strong></p>

          <p>    [ ] ∥ x = x</p>

          <hr />
          <p><strong>non_atomic_prop2</strong></p>

          <p>
                ((a # xs) ∥ x) ≡<sub>p</sub> a;(xs ∥ x) ∪<sub>p</sub> Concat
            (x#a#xs)
          </p>

          <hr />
          <p><strong>compose_distrib</strong></p>

          <p>
                (b ∪<sub>p</sub> (a ; c ∪<sub>p</sub> a ; d)) = (b ∪<sub>p</sub>
            a ; (c ∪<sub>p</sub> d))
          </p>

          <hr />
          <p><strong>concur_two</strong></p>

          <p>    [a]∥b = a;b ∪<sub>p</sub> b;a</p>

          <hr />
          <p><strong>concur_commute</strong></p>

          <p>    [a]∥b = ([b]∥a)</p>

          <hr />
          <p><strong>compose_distrib2</strong></p>

          <p>
                ∀x ∈ set xs. x ≠ [ ] ⟹ xs ≠ [ ] ⟹ b ∪<sub>p</sub> ⋃<sub>p</sub>
            [a;(Concat t). t ← xs] = b ∪<sub>p</sub> a;⋃<sub>p</sub> [(Concat
            t). t ← xs]
          </p>

          <hr />
          <p><strong>concur_recursive</strong></p>

          <p>    ((a # xs) ∥ x) = a;(xs ∥ x) ∪<sub>p</sub> Concat (x#a#xs)</p>

          <hr />
          <p><strong>non_atomic_conc_S</strong></p>

          <p>    S (xs∥x) = complete_state (x#xs)</p>

          <hr />
          <p><strong>concor_three_1</strong></p>

          <p>
                [p<sub>1</sub>, p<sub>2</sub>] ∥ q = ((q;p<sub>1</sub>);p<sub
              >2</sub
            >
            ∪<sub>p</sub> ((p<sub>1</sub>;q);p<sub>2</sub>)) ∪<sub>p</sub>
            ((p<sub>1</sub>;p<sub>2</sub>);q)
          </p>

          <hr />
          <p><strong>concor_three_2</strong></p>

          <p>
                [p<sub>1</sub>, p<sub>2</sub>] ∥ q = ((q;p<sub>1</sub>);p<sub
              >2</sub
            >
            ∪<sub>p</sub> ((p<sub>1</sub>;q);p<sub>2</sub>)) ∪<sub>p</sub>
            ((p<sub>1</sub>;p<sub>2</sub>);q)
          </p>

          <hr />
          <p><strong>concor_three_3</strong></p>

          <p>
                [p<sub>1</sub>, p<sub>2</sub>] ∥ q ≡<sub>p</sub>
            ((q;p<sub>1</sub>);p<sub>2</sub> ∪<sub>p</sub>
            ((p<sub>1</sub>;q);p<sub>2</sub>)) ∪<sub>p</sub>
            ((p<sub>1</sub>;p<sub>2</sub>);q)
          </p>

          <hr />
          <p><strong>Concat_feasible</strong></p>

          <p>    all_feasible xs ⟹ is_feasible (Concat xs)</p>

          <hr />
          <p><strong>Choice_feasible</strong></p>

          <p>    all_feasible xs ⟹ is_feasible (⋃<sub>p</sub> xs)</p>

          <hr />
          <p><strong>all_feasible_prop</strong></p>

          <p>    all_feasible xs ⟹ x ∈ set xs ⟹ is_feasible x</p>

          <hr />
          <p><strong>all_feasible_prop_1</strong></p>

          <p>    ∀x ∈ set xs. is_feasible x ≡ all_feasible xs</p>

          <hr />
          <p><strong>all_feasible_prop_2</strong></p>

          <p>
                xs ∈ set (permutations ys) ⟹ all_feasible ys ⟹ all_feasible xs
          </p>

          <hr />
          <p><strong>non_atomic_conc_feasible_preserving</strong></p>

          <p>    all_feasible (x#xs) ⟹ is_feasible (xs ∥ x)</p>

          <hr />
          <p><strong>atomic_conc_refinement_safe</strong></p>

          <p>
                q<sub>1</sub> ⊑<sub>p</sub> p<sub>1</sub> ⟹ q<sub>2</sub> ⊑<sub
              >p</sub
            >
            p<sub>2</sub> ⟹ q<sub>3</sub> ⊑<sub>p</sub> p<sub>3</sub> ⟹
            ([q<sub>1</sub>, q<sub>2</sub>] ∥ q<sub>3</sub>) ⊑<sub>p</sub>
            ([p<sub>1</sub>, p<sub>2</sub>] ∥ p<sub>3</sub>)
          </p>

          <hr />
          <p>
                ((ys@[x])@xs) ∥<sub>G</sub> q ≡<sub>p</sub> (ys@([x]@xs)) ∥<sub
              >G</sub
            >
            q
          </p>

          <hr />
          <p><strong>atomic_restrict_1</strong></p>

          <p>
                (xs ∥ x) /<sub>p</sub> C ≡<sub>p</sub> ⋃<sub>p</sub> [Concat t
            /<sub>p</sub> C. t ← insert_all x xs]
          </p>

          <hr />
          <p><strong>concur_restrict</strong></p>

          <p>
                (xs ∥ x) /<sub>p</sub> C = ⋃<sub>p</sub> [Concat t /<sub>p</sub>
            C. t ← insert_all x xs]
          </p>

          <hr />
          <p><strong>atomic_corestrict_1</strong></p>

          <p>
                (xs ∥ x) ∖<sub>p</sub> C ≡<sub>p</sub> ⋃<sub>p</sub> [Concat t
            ∖<sub>p</sub> C. t ← insert_all x xs]
          </p>

          <hr />
          <p><strong>equiv_list_prop_2</strong></p>

          <p>
                equiv_list xs ys ⟹ ⋃<sub>p</sub> xs ≡<sub>p</sub> ⋃<sub>p</sub>
            ys
          </p>

          <hr />
          <p><strong>equiv_list_prop_1</strong></p>

          <p>
                ∀a ∈ set xs. a ≠ [ ] ⟹ equiv_list [Concat t /<sub>p</sub> C. t ←
            xs] [Concat (hd t /<sub>p</sub> C # tl t). t ← xs]
          </p>

          <hr />
          <p><strong>equiv_list_prop_3</strong></p>

          <p>
                ∀a ∈ set xs. a ≠ [ ] ⟹ equiv_list [Concat t ∖<sub>p</sub> C. t ←
            xs] [Concat (butlast t @ [(last t)∖<sub>p</sub> C]). t ← xs]
          </p>

          <hr />
          <p><strong>concur_restrict</strong></p>

          <p>
                (xs ∥ x) /<sub>p</sub> C ≡<sub>p</sub> ⋃<sub>p</sub> [Concat (hd
            t/<sub>p</sub>C#tl t). t ← insert_all x xs]
          </p>

          <hr />
          <p><strong>concur_corestrict</strong></p>

          <p>
                (xs ∥ x) ∖<sub>p</sub> C ≡<sub>p</sub> ⋃<sub>p</sub> [Concat
            (butlast t @ [(last t)∖<sub>p</sub> C]). t ← insert_all x xs]
          </p>

          <hr />
          <p><strong>concur_specialize1</strong></p>

          <p>    p ; q ⊆<sub>p</sub> ([p] ∥ q)</p>

          <hr />
          <p><strong>non_atomic_specialize</strong></p>

          <p>
                ys ∈ set (insert_all x xs) ⟹ (Concat ys) ⊆<sub>p</sub> (xs ∥ x)
          </p>

          <hr />
          <p><strong>commute_compose</strong></p>

          <p>    commute_programs3 a b ⟹ [a] ∥ b ≡<sub>p</sub> a;b</p>

          <hr />
          <p><strong>concur_distrib1</strong></p>

          <p>
                xs∥(b ∪<sub>p</sub> c) ≡<sub>p</sub> (xs∥b) ∪<sub>p</sub> (xs∥c)
          </p>

          <hr />
          <p><strong>concur_choice1</strong></p>

          <p>    [a∪<sub>p</sub>b]∥(c) = ([a]∥c) ∪<sub>p</sub> ([b]∥c)</p>

          <hr />
          <p><strong>concur_choice2</strong></p>

          <p>    xs∥(b ∪<sub>p</sub> c) = (xs∥b) ∪<sub>p</sub> (xs∥c)</p>

          <hr />
          <p><strong>concur_specialize2</strong></p>

          <p>    ([Concat xs] ∥ x) ⊆<sub>p</sub> (xs ∥ x)</p>

          <hr />
          <h2 id="permutationsthy">Permutations.thy</h2>

          <p><strong>simp_2</strong></p>

          <p>
                ∀x<sub>1</sub> x<sub>2</sub> x<sub>3</sub>. f (f x<sub>1</sub>
            x<sub>2</sub>) x<sub>3</sub> = f x<sub>1</sub> (f x<sub>2</sub>
            x<sub>3</sub>) ⟹ foldl f (f a x) xs = f a (foldl f x xs)
          </p>

          <hr />
          <p><strong>fold_composition_assoc</strong></p>

          <p>    foldl (;) x (as @ [a]) = (foldl (;) x as) ; a</p>

          <hr />
          <p><strong>S_foldl_composition</strong></p>

          <p>    S (foldl (;) x as) = ⋃ (S ` (set (x # as)))</p>

          <hr />
          <p><strong>main_theorem</strong></p>

          <p>    S (foldl (;) x (a # as)) = S ((foldl (;) x as) ; a)</p>

          <hr />
          <p><strong>skip_fold_complete_state</strong></p>

          <p>
                S (Skip (complete_state (x # xs))) ∪ S x ∪ S (foldl (;) x xs) =
            complete_state (x # xs) ∪ S x ∪ complete_state xs
          </p>

          <hr />
          <p><strong>simp_5</strong></p>

          <p>
                S (foldl (;) (Skip (complete_state xs)) xs) = complete_state xs
          </p>

          <hr />
          <p><strong>simp_4_right</strong></p>

          <p>
                S (foldl (;) (Skip (complete_state xs)) xs) ⊆ complete_state xs
          </p>

          <hr />
          <p><strong>fold_composition_state_inv</strong></p>

          <p>    S (fold (;) t b) = S (foldl (;) b t)</p>

          <hr />
          <p>
                S (fold (;) t (Skip (complete_state t))) = S (foldl (;) (Skip
            (complete_state t)) t)
          </p>

          <hr />
          <p><strong>permutation_fold_subset_complete_state</strong></p>

          <p>
                t ∈ set (permutations xs) ⟹ S (fold (;) t (Skip (complete_state
            t))) ⊆ complete_state xs
          </p>

          <hr />
          <p><strong>state_composition</strong></p>

          <p>    x ∈ S a ⟹ x ∈ S (a ; b)</p>

          <hr />
          <p><strong>state_composition_1</strong></p>

          <p>    x ∈ S p ⟹ x ∈ S (foldl (;) p (xs))</p>

          <hr />
          <p><strong>state_composition_2</strong></p>

          <p>    x ∈ S a ⟹ x ∈ S (foldl (;) p (a#xs))</p>

          <hr />
          <p><strong>state_composition_3</strong></p>

          <p>    x ∈ S a ⟹ x ∈ S (foldl (;) p (ys@a#xs))</p>

          <hr />
          <p><strong>complete_state_subset</strong></p>

          <p>    complete_state xs ⊆ S (Skip (complete_state xs))</p>

          <hr />
          <p><strong>foldl_composition_preserves_state</strong></p>

          <p>    S p ⊆ S (foldl (;) p xs)</p>

          <hr />
          <p><strong>Union_prop_1</strong></p>

          <p>    ⋃ (set (xs@[x])) = x ∪ ⋃ (set xs)</p>

          <hr />
          <p><strong>Union_prop_2</strong></p>

          <p>    ⋃ (xs ∪ {x}) = x ∪ ⋃ xs</p>

          <hr />
          <p><strong>fold_comp_prop1</strong></p>

          <p>    xs ≠ [ ] ⟹ foldl (;) x xs = foldl (;) (x;Skip (S x)) xs</p>

          <hr />
          <p><strong>fold_comp_prop2</strong></p>

          <p>
                xs ≠ [ ] ⟹ foldl (;) x xs = foldl (;) (x;Skip (complete_state
            (x#xs))) xs
          </p>

          <hr />
          <p><strong>fold_comp_prop3</strong></p>

          <p>    S (foldl (;) x xs) = complete_state (x # xs)</p>

          <hr />
          <p><strong>fold_comp_prop4</strong></p>

          <p>
                xs ≠ [ ] ⟹ foldl (;) x xs = foldl (;) (x;Skip (complete_state
            (xs))) xs
          </p>

          <hr />
          <p><strong>perm_prop_1</strong></p>

          <p>
                (filter (p) xs) @ (filter (λx. ¬p x) xs) ∈ set (permutations xs)
          </p>

          <hr />
          <p><strong>perm_prop_2</strong></p>

          <p>
                xs ∈ set (permutations ys) ⟹ map p xs ∈ set (permutations (map p
            ys))
          </p>

          <hr />
          <h2 id="until_loopthy">Until_loop.thy</h2>

          <p><strong>until_conncetion</strong></p>

          <p>    until_loop a C b n = until_support a C b 0 n</p>

          <hr />
          <p><strong>until_decomposition</strong></p>

          <p>
                until_loop a C b (n + 1) ≡<sub>p</sub>
            a;((b/<sub>p</sub>(-C))<sup>n + 1</sup> ∪<sub>p</sub> (loop
            (b/<sub>p</sub>(-C)) 0 n)) ∖<sub>p</sub> C
          </p>

          <hr />
          <p><strong>until_decomposition_2</strong></p>

          <p>
                until_loop a C b (n + 1) ≡<sub>p</sub>
            a;((b/<sub>p</sub>(-C))<sup>n + 1</sup>) ∖<sub>p</sub> C ∪<sub
              >p</sub
            >
            until_loop a C b n
          </p>

          <hr />
          <p><strong>until_def_lemma_3</strong></p>

          <p>
                until_loop a C b n ≡<sub>p</sub> a;((Skip (S
            (b/<sub>p</sub>(-C))) /<sub>p</sub> (Pre (b/<sub>p</sub>(-C))))
            ∪<sub>p</sub> (loop (b/<sub>p</sub>(-C)) 1 n)) ∖<sub>p</sub> C
          </p>

          <hr />
          <p><strong>loop_choice1</strong></p>

          <p>
                until_loop a C b n ≡<sub>p</sub> ⋃<sub>p</sub> [a;((b /<sub
              >p</sub
            >
            (- C))<sup>nat i</sup>)∖<sub>p</sub>C. i ← [0..int n]]
          </p>

          <hr />
          <p><strong>loop_choice2</strong></p>

          <p>
                Range_p (until_loop a C b n) = ⋃ (set [Range_p (a;((b /<sub
              >p</sub
            >
            (- C))<sup>nat i</sup>)∖<sub>p</sub>C). i ← [0..int n]])
          </p>

          <hr />
          <p><strong>until_loop_feasible</strong></p>

          <p>    all_feasible [a, b] ⟹ is_feasible (until_loop a C b n)</p>

          <hr />
          <p><strong>equiv_is_maintained_by_until_loop_2</strong></p>

          <p>
                a<sub>1</sub> ≡<sub>p</sub> a<sub>2</sub> ⟹ b<sub>1</sub> ≡<sub
              >p</sub
            >
            b<sub>2</sub> ⟹ S b<sub>1</sub> = S b<sub>2</sub> ⟹ all_feasible
            [b<sub>1</sub>, b<sub>2</sub>] ⟹ until_loop a<sub>1</sub> C b<sub
              >1</sub
            >
            n ≡<sub>p</sub> until_loop a<sub>2</sub> C b<sub>2</sub> n
          </p>

          <hr />
          <p><strong>until_decom</strong></p>

          <p>
                k&lt;n ⟹ until_loop a C b n ≡<sub>p</sub> until_loop a C b n
            ∪<sub>p</sub> until_loop a C b k
          </p>

          <hr />
          <p><strong>range_until_loop_1</strong></p>

          <p>
                m&lt;n ⟹ x ∉ Range_p (until_loop a C b n) ⟹ x ∉ Range_p
            (until_loop a C b m)
          </p>

          <hr />
          <p><strong>range_until_loop_2</strong></p>

          <p>
                m&lt;n ⟹ x ∉ Range_p (until_loop a C b n) ⟹ x ∉ Range_p
            (until_support a C b s m)
          </p>

          <hr />
          <p><strong>loop_range</strong></p>

          <p>    Range_p (until_loop a C b n) ⊆ C</p>

          <hr />
          <p><strong>split_front</strong></p>

          <p>    until_loop (x;a) C b n ≡<sub>p</sub> x ; until_loop a C b n</p>

          <hr />
          <p><strong>fail_until</strong></p>

          <p>
                until_loop a C b (n + 1) ≡<sub>p</sub> Fail {} ⟹ until_loop a C
            b n ≡<sub>p</sub> Fail {}
          </p>

          <hr />
          <p><strong>fail_until_2</strong></p>

          <p>
                k&lt;n ⟹ until_loop a C b n ≡<sub>p</sub> Fail {} ⟹ until_loop a
            C b k ≡<sub>p</sub> Fail {}
          </p>

          <hr />
          <p><strong>loop_prop1</strong></p>

          <p>    S (loop (b/<sub>p</sub>(-C)) 0 n) = S b</p>

          <hr />
          <p><strong>loop_prop2</strong></p>

          <p>    State (loop (b/<sub>p</sub>(-C)) 0 n) = S b</p>

          <hr />
          <p><strong>loop_prop3</strong></p>

          <p>    S (until_loop a C b n) = S a ∪ S b</p>

          <hr />
          <p><strong>loop_prop4</strong></p>

          <p>    State (until_loop a C b n) = S (until_loop a C b n)</p>

          <hr />
          <p><strong>loop_prop5</strong></p>

          <p>    State (until_loop a C b n) = S a ∪ S b</p>

          <hr />
          <p><strong>loop_prop6</strong></p>

          <p>    until_loop (Skip D) FALSE (Skip D) n = Fail D</p>

          <hr />
          <h2 id="until_supportthy">Until_support.thy</h2>

          <p><strong>until_decomp_1</strong></p>

          <p>
                until_support a C b 0 n ≡<sub>p</sub> until_support a C b 0 0
            ∪<sub>p</sub> until_support a C b (0 + 1) n
          </p>

          <hr />
          <p><strong>until_decomp_2</strong></p>

          <p>
                until_support a C b 0 (n + 1) ≡<sub>p</sub> until_support a C b
            0 n ∪<sub>p</sub> until_support a C b (n + 1) (n + 1)
          </p>

          <hr />
          <p><strong>until_decomp_3</strong></p>

          <p>
                s &lt; f ⟹ until_support a C b s f ≡<sub>p</sub> until_support a
            C b s s ∪<sub>p</sub> until_support a C b (s + 1) f
          </p>

          <hr />
          <p><strong>until_decomp_4</strong></p>

          <p>
                s &lt; f ⟹ until_support a C b s (f + 1) ≡<sub>p</sub>
            until_support a C b (f + 1) (f + 1) ∪<sub>p</sub> until_support a C
            b s f
          </p>

          <hr />
          <p><strong>until_decomp_5</strong></p>

          <p>
                0 &lt; k ⟹ k &lt; n ⟹ until_support a C b 0 n ≡<sub>p</sub>
            until_support a C b 0 k ∪<sub>p</sub> until_support a C b (k + 1) n
          </p>

          <hr />
          <p><strong>until_decomp_6</strong></p>

          <p>
                s &lt; k ⟹ k &lt; f ⟹ until_support a C b s f ≡<sub>p</sub>
            until_support a C b s k ∪<sub>p</sub> until_support a C b (k + 1) f
          </p>

          <hr />
          <p><strong>until_decomp_7</strong></p>

          <p>
                s = f ⟹ until_support a C b s f ≡<sub>p</sub> a ; ((b /<sub
              >p</sub
            >
            (- C))<sup>f</sup>) ∖<sub>p</sub> C
          </p>

          <hr />
          <p><strong>until_support_feasible</strong></p>

          <p>    all_feasible [a, b] ⟹ is_feasible (until_support a C b s f)</p>

          <hr />
          <p><strong>equiv_is_maintained_by_until_support_1</strong></p>

          <p>
                a<sub>1</sub> ≡<sub>p</sub> a<sub>2</sub> ⟹ b<sub>1</sub> ≡<sub
              >p</sub
            >
            b<sub>2</sub> ⟹ S b<sub>1</sub> = S b<sub>2</sub> ⟹ all_feasible
            [b<sub>1</sub>, b<sub>2</sub>] ⟹ until_support a<sub>1</sub> C b<sub
              >1</sub
            >
            s f ≡<sub>p</sub> until_support a<sub>2</sub> C b<sub>2</sub> s f
          </p>

          <hr />
          <p><strong>equiv_is_maintained_by_until_support_2</strong></p>

          <p>
                a<sub>1</sub> ≡<sub>p</sub> a<sub>2</sub> ⟹ b<sub>1</sub> ≡<sub
              >p</sub
            >
            b<sub>2</sub> ⟹ 0&lt;s ⟹ all_feasible [b<sub>1</sub>, b<sub>2</sub>]
            ⟹ until_support a<sub>1</sub> C b<sub>1</sub> s f ≡<sub>p</sub>
            until_support a<sub>2</sub> C b<sub>2</sub> s f
          </p>

          <hr />
          <p><strong>bad_index_is_fail_support</strong></p>

          <p>    f &lt; s ⟹ until_support a C b s f ≡<sub>p</sub> Fail {}</p>

          <hr />
          <p><strong>bad_index_range_support</strong></p>

          <p>    f &lt; s ⟹ Range_p (until_support a C b s f) = {}</p>

          <hr />
          <p><strong>until_support_decomp</strong></p>

          <p>
                s&lt;s’ ⟹ f’&lt;f ⟹ until_support a C b s f ≡<sub>p</sub>
            until_support a C b s f ∪<sub>p</sub> until_support a C b s’ f’
          </p>

          <hr />
          <h2 id="contractthy">Contract.thy</h2>

          <p><strong>consequence_rule</strong></p>

          <p>
                post<sub>1</sub> ⊆ post<sub>2</sub> ⟹ Pre<sub>2</sub> ⊆ Pre<sub
              >1</sub
            >
            ⟹ is_correct 〈a_specification=〈State=Pre<sub>1</sub> ∪ Field
            post<sub>2</sub>, Pre=Pre<sub>1</sub>, post=post<sub>1</sub>〉,
            a_implementation=b〉 ⟹ is_correct 〈a_specification=〈State=Pre<sub
              >1</sub
            >
            ∪ Field post<sub>2</sub>, Pre=Pre<sub>2</sub>,
            post=post<sub>2</sub>〉, a_implementation=b〉
          </p>

          <hr />
          <p><strong>post_charac_old</strong></p>

          <p>
                is_correct 〈a_specification=s, a_implementation=b〉 ⟹ b sp (Pre
            s) ⊆ post s
          </p>

          <hr />
          <p><strong>pre_charac_old</strong></p>

          <p>
                is_correct 〈a_specification=s, a_implementation=b〉 ⟹ Pre s ⊆ b
            wp (post s)
          </p>

          <hr />
          <p><strong>correct_program_1</strong></p>

          <p>
                is_correct 〈a_specification=s, a_implementation=b〉 ⟹ Pre s ⊆
            Pre b - Domain (post b - post s)
          </p>

          <hr />
          <p><strong>correct_program_2</strong></p>

          <p>
                S s = S b ⟹ is_feasible b ⟹ Pre s ⊆ Pre b - Domain (post b -
            post s) ⟹ is_correct 〈a_specification=s, a_implementation=b〉
          </p>

          <hr />
          <p><strong>correct_program</strong></p>

          <p>
                S s = S b ⟹ is_feasible b ⟹ is_correct 〈a_specification=s,
            a_implementation=b〉 = (Pre s ⊆ Pre b - Domain (post b - post s))
          </p>

          <hr />
          <p><strong>fail_false</strong></p>

          <p>    b sp FALSE = FALSE</p>

          <hr />
          <p><strong>false_fail</strong></p>

          <p>    is_feasible b ⟹ b wp FALSE = FALSE</p>

          <hr />
          <p>    b wp FALSE = Pre b - Domain (post b)</p>

          <hr />
          <p><strong>fail_pre</strong></p>

          <p>    Fail S’ sp Pre’ = {}</p>

          <hr />
          <p><strong>sp_prop1</strong></p>

          <p>    p sp TRUE (S p) = post p</p>

          <hr />
          <p><strong>wp_prop1</strong></p>

          <p>    p wp TRUE<sub>r</sub> (S p) = Pre p</p>

          <hr />
          <p>    Havoc C sp pre = {(x,y). x ∈ pre ∧ x ∈ C ∧ y ∈ C}</p>

          <hr />
          <p>    Havoc C sp pre = post (Havoc C) /<sub>r</sub> pre</p>

          <hr />
          <p><strong>fail_post</strong></p>

          <p>    Fail S’ wp post’ = FALSE</p>

          <hr />
          <p><strong>sp_distrib</strong></p>

          <p>    b sp (p ∪ q) = b sp p ∪ b sp q</p>

          <hr />
          <p><strong>wp_distrib2</strong></p>

          <p>    (b wp p) ∪ (b wp q) ⊆ b wp (p ∪ q)</p>

          <hr />
          <p><strong>sanity</strong></p>

          <p>
                q ⊑<sub>p</sub> p ⟹ 〈a_specification=s, a_implementation=q〉
            ⊑<sub>c</sub> 〈a_specification=s, a_implementation=p〉
          </p>

          <hr />
          <p><strong>mai_theorem_1</strong></p>

          <p>    is_feasible p ⟹ is_correct (MAI p)</p>

          <hr />
          <p><strong>state_feasible_1</strong></p>

          <p>
                (∀s ∈ Pre p . is_trivial (post p) s ∨ is_relevant (post p) s) =
            is_feasible p
          </p>

          <hr />
          <p>    (Infeas D) wp C = TRUE D</p>

          <hr />
          <p>    (Infeas D) sp C = FALSE</p>

          <hr />
          <p>    (Havoc D) sp C = (TRUE<sub>r</sub> D) /<sub>r</sub> C</p>

          <hr />
          <p>    (Infeas D) sp C = FALSE</p>

          <hr />
          <p><strong>post_charac</strong></p>

          <p>    implements a b ⟹ a sp (Pre b) ⊆ post b</p>

          <hr />
          <p><strong>pre_charac</strong></p>

          <p>    implements i s ⟹ Pre s ⊆ i wp (post s)</p>

          <hr />
          <h2 id="invariantthy">Invariant.thy</h2>

          <p><strong>invariant_disjoint_from_pre</strong></p>

          <p>    I ∩ (Pre p) = {} ⟹ is_invariant I p</p>

          <hr />
          <p><strong>false_is_invariant</strong></p>

          <p>    is_invariant FALSE p</p>

          <hr />
          <p><strong>equiv_inv</strong></p>

          <p>
                p<sub>1</sub> ≡<sub>p</sub> p<sub>2</sub> ⟹ is_invariant I p<sub
              >1</sub
            >
            = is_invariant I p<sub>2</sub>
          </p>

          <hr />
          <p><strong>invariant_relation_1</strong></p>

          <p>
                is_invariant I p ⟹ is_invariant J p ⟹ is_invariant (I ∪ J) p
          </p>

          <hr />
          <p><strong>invariant_relation_2</strong></p>

          <p>
                is_invariant I p ⟹ is_invariant J p ⟹ is_invariant (I ∩ J) p
          </p>

          <hr />
          <p><strong>invariant_refinement</strong></p>

          <p>
                is_invariant I p<sub>1</sub> ⟹ p<sub>2</sub> ⊑<sub>p</sub> p<sub
              >1</sub
            >
            ⟹ is_invariant I (p<sub>2</sub> /<sub>p</sub> (Pre p<sub>1</sub>))
          </p>

          <hr />
          <p><strong>invariant_prop_specialize</strong></p>

          <p>
                is_invariant I p<sub>1</sub> ⟹ p<sub>2</sub> ⊆<sub>p</sub> p<sub
              >1</sub
            >
            ⟹ is_invariant I (p<sub>2</sub>)
          </p>

          <hr />
          <p><strong>invariant_prop_2</strong></p>

          <p>    is_invariant I (Fail C)</p>

          <hr />
          <p><strong>invariant_prop_3</strong></p>

          <p>    C ⊆ I ⟹ is_invariant I (Havoc C)</p>

          <hr />
          <p><strong>invariant_prop_4</strong></p>

          <p>    is_invariant I (Skip C)</p>

          <hr />
          <p><strong>composition_invariant_preserve</strong></p>

          <p>
                is_invariant I p<sub>1</sub> ⟹ is_invariant I p<sub>2</sub> ⟹
            is_invariant I (p<sub>1</sub> ; p<sub>2</sub>)
          </p>

          <hr />
          <p><strong>choice_invariant_preserve</strong></p>

          <p>
                is_invariant I p<sub>1</sub> ⟹ is_invariant I p<sub>2</sub> ⟹
            is_invariant I (p<sub>1</sub> ∪<sub>p</sub> p<sub>2</sub>)
          </p>

          <hr />
          <p><strong>choice_invariant_preserve_2</strong></p>

          <p>
                is_invariant I (p<sub>1</sub> ∪<sub>p</sub> p<sub>2</sub>) ⟹
            is_invariant I p<sub>1</sub>
          </p>

          <hr />
          <p><strong>choice_invariant_preserve_3</strong></p>

          <p>
                is_invariant I (p<sub>1</sub> ∪<sub>p</sub> p<sub>2</sub>) ⟹
            is_invariant I p<sub>2</sub>
          </p>

          <hr />
          <p><strong>choice_invariant_preserve_4</strong></p>

          <p>
                is_invariant I (p<sub>1</sub> ∪<sub>p</sub> p<sub>2</sub>) =
            (is_invariant I p<sub>1</sub> ∧ is_invariant I p<sub>2</sub>)
          </p>

          <hr />
          <p><strong>restriction_invariant_preserve</strong></p>

          <p>    is_invariant I p ⟹ is_invariant I (p /<sub>p</sub> C)</p>

          <hr />
          <p><strong>restriction_invariant_preserve_2</strong></p>

          <p>
                I ⊆ C ⟹ is_invariant I (p /<sub>p</sub> C) ⟹ is_invariant I p
          </p>

          <hr />
          <p><strong>corestriction_invariant_preserve</strong></p>

          <p>    is_invariant I p ⟹ is_invariant I (p ∖<sub>p</sub> C)</p>

          <hr />
          <p><strong>c_is_invariant</strong></p>

          <p>    is_invariant C (p ∖<sub>p</sub> C)</p>

          <hr />
          <p><strong>guarded_conditional_invariant_preserve</strong></p>

          <p>
                is_invariant I p ⟹ is_invariant I q ⟹ is_invariant I (GC [(C,
            p), (D, q)])
          </p>

          <hr />
          <p><strong>if_then_else_invariant_preserve</strong></p>

          <p>
                is_invariant I p ⟹ is_invariant I q ⟹ is_invariant I (ITE C p q)
          </p>

          <hr />
          <p><strong>fixed_repetition_invariant_preserve</strong></p>

          <p>     is_invariant I p ⟹ is_invariant I (p<sup>n</sup>)</p>

          <hr />
          <p><strong>arbitrary_repetition_invariant_preserve</strong></p>

          <p>    is_invariant I p ⟹ is_invariant I (loop p s f)</p>

          <hr />
          <p><strong>until_support_invariant_preserve</strong></p>

          <p>
                0&lt;s ⟹ is_invariant I a ⟹ is_invariant I b ⟹ is_invariant I
            (until_support a C b s f)
          </p>

          <hr />
          <p><strong>until_loop_invariant_preserve</strong></p>

          <p>
                is_invariant I a ⟹ is_invariant I b ⟹ is_invariant I (until_loop
            a C b n)
          </p>

          <hr />
          <p><strong>inverse_is_not_invariant_preseving</strong></p>

          <p>
                Pre p ⊆ I ⟹ is_invariant I p ⟹ is_invariant I (p<sup>-</sup
            ><sup>1</sup>)
          </p>

          <hr />
          <p><strong>true_is_invariant</strong></p>

          <p>    S p ⊆ C ⟹ is_invariant (TRUE C) p</p>

          <hr />
          <p><strong>invariant_exp</strong></p>

          <p>
                is_invariant I b ⟹ x ∈ Pre b ⟹ (x,y) ∈ post b ⟹ x ∈ I ⟹ y ∈ I
          </p>

          <hr />
          <p><strong>invariant_preserve</strong></p>

          <p>
                is_invariant I b ⟹ Range_p a ⊆ I ⟹ x ∈ Pre a ⟹ (x,y) ∈ post
            (a;b) ⟹ y ∈ I
          </p>

          <hr />
          <h2 id="loop_invariantthy">Loop_invariant.thy</h2>

          <p><strong>false_is_loop_invariant</strong></p>

          <p>    is_loop_invariant FALSE a C b</p>

          <hr />
          <p><strong>true_is_loop_invariant</strong></p>

          <p>    S a ∪ S b ∪ C ⊆ D ⟹ is_loop_invariant (TRUE D) a C b</p>

          <hr />
          <p><strong>loop_invariant_is_invariant_of_loop</strong></p>

          <p>
                0&lt;s ⟹ is_loop_invariant I a C b ⟹ is_invariant I (loop
            (b/<sub>p</sub>(-C)) s n)
          </p>

          <hr />
          <p><strong>loop_correct_1</strong></p>

          <p>
                is_loop_invariant I a C b ⟹ Range_p (a ; loop (b /<sub>p</sub>
            (- C)) n n) ⊆ I
          </p>

          <hr />
          <p><strong>loop_correct_2</strong></p>

          <p>
                is_loop_invariant I a C b ⟹ Range_p (until_support a C b n n) ⊆
            I
          </p>

          <hr />
          <p><strong>loop_correct_3</strong></p>

          <p>
                s&lt;f ⟹ is_loop_invariant I a C b ⟹ Range_p (until_support a C
            b s f) ⊆ I
          </p>

          <hr />
          <p><strong>loop_correct</strong></p>

          <p>
                is_loop_invariant I a C b ⟹ Range_p (until_loop a C b n) ⊆ C ∩ I
          </p>

          <hr />
          <p><strong>is_invariant_is_preserved</strong></p>

          <p>    p ≡<sub>p</sub> q ⟹ is_invariant I p ⟹ is_invariant I q</p>

          <hr />
          <p><strong>is_loop_invariant_is_preserved</strong></p>

          <p>
                a ≡<sub>p</sub> a’ ⟹ b ≡<sub>p</sub> b’ ⟹ is_loop_invariant I a
            C b ⟹ is_loop_invariant I a’ C b’
          </p>

          <hr />
          <p><strong>loop_inv_is_inv_for_a</strong></p>

          <p>    is_loop_invariant I a C b ⟹ is_invariant I a</p>

          <hr />
          <p><strong>Loop_inv_1</strong></p>

          <p>
                is_loop_invariant I a C b ⟹ is_invariant I (b /<sub>p</sub> (-
            C))
          </p>

          <hr />
          <p><strong>loop_inv_is_inv_of_loop</strong></p>

          <p>
                is_loop_invariant I a C b ⟹ is_invariant I (loop
            (b/<sub>p</sub>(-C)) 0 n)
          </p>

          <hr />
          <p><strong>Loop_invinv</strong></p>

          <p>
                is_loop_invariant I a C b ⟹ is_invariant I (until_loop a C b n)
          </p>

          <hr />
        </main>
      </div>
    </div>

    <div class="flex-1"></div>
  </body>
</html>
